[{"content":"\rOverview\rGhostESP can control a Chameleon Ultra over BLE. Once paired, use the same NFC scan/save flows as with a PN532.\nPrerequisites\rFirmware: GhostESP build with BLE and Chameleon Ultra features enabled. Hardware: A powered Chameleon Ultra advertising over BLE. Supported Devices\rChameleon Ultra support is available on the following GhostESP builds:\nesp32-generic.zip esp32s3-generic.zip esp32c3-generic.zip esp32c5-generic-v01.zip esp32c6-generic.zip MarauderV4_FlipperHub.zip MarauderV6_AwokDual.zip ghostboard.zip ESP32-S3-Cardputer.zip CYD2USB.zip CYDMicroUSB.zip CYDDualUSB.zip CYD2USB2.4Inch.zip CYD2USB2.4Inch_C.zip CYD2432S028R.zip LilyGo-T-Deck.zip LilyGo-TEmbedC1101.zip LilyGo-S3TWatch-2020.zip LilyGo-TDisplayS3-Touch.zip JCMK_DevBoardPro.zip RabbitLabs_Minion.zip Lolin_S3_Pro.zip CardputerADV.zip Connecting to Chameleon Ultra\rNote: GhostESP suspends the access point and Wi-Fi services during BLE sessions (including Chameleon connections) to free memory. The radio comes back automatically after you disconnect or run stop.\nOn-Device UI\rOpen Main Menu → NFC → Chameleon Ultra → Connect. The device scans for nearby Chameleon Ultra devices. Wait for the connection popup to show \u0026ldquo;Connected\u0026rdquo;. Battery voltage and percentage appear below the status. Use Disconnect from the same menu when finished. Wi-Fi services resume automatically after disconnecting. Command Line\rRun chameleon connect to start pairing. Optional arguments: timeout in seconds (default 10) if you need more time for discovery. pin if your Chameleon Ultra requires a 4–6 digit security code. Example: chameleon connect 15 1234 Wait for pairing confirmation in the terminal. The CLI announces when the link succeeds. Check status with chameleon status or battery with chameleon battery. Voltage and percentage display before starting long dumps. Run chameleon disconnect when finished. BLE releases and the Wi-Fi services will restore automatically. Saving Dumps\rSave HF scans: After chameleon scanhf completes, run chameleon savehf \u0026lt;name\u0026gt; to write the dump to /mnt/ghostesp/chameleon/. Name files clearly: Use short descriptive names without spaces, for example office_door. Troubleshooting\rConnection timeouts: Keep the Chameleon Ultra awake (press any button) and re-run chameleon connect 20 for a longer window. PIN failures: Verify the configured code on the Chameleon Ultra; three failed attempts may force a power cycle. No BLE advertisements: Check the Chameleon Ultra’s BLE settings or reboot it; GhostESP only connects to active broadcasts. Next Steps\rScanning: Continue with PN532-based scanning guide. Saving: Store remote dumps using Saving Tags. Compatibility: Review what tag families work via Supported Tags. ","description":"Connect GhostESP to a Chameleon Ultra reader","permalink":"/latest/nfc/chameleon-ultra/","title":"Chameleon Ultra"},{"content":"\rOverview\rGhostESP can control a Chameleon Ultra over Bluetooth Low Energy. Once paired you can reuse the same NFC scan, save, and dump flows as if you had a PN532 module attached.\nPrerequisites\rFirmware: GhostESP build with BLE enabled and the Chameleon Ultra features compiled in. Hardware: A powered Chameleon Ultra advertising over BLE and charged enough for the session. Supported Devices\rChameleon Ultra support is available on the following GhostESP builds:\nesp32-generic.zip esp32s3-generic.zip esp32c3-generic.zip esp32c5-generic-v01.zip esp32c6-generic.zip MarauderV4_FlipperHub.zip MarauderV6_AwokDual.zip ghostboard.zip ESP32-S3-Cardputer.zip CYD2USB.zip CYDMicroUSB.zip CYDDualUSB.zip CYD2USB2.4Inch.zip CYD2USB2.4Inch_C.zip CYD2432S028R.zip LilyGo-T-Deck.zip LilyGo-TEmbedC1101.zip LilyGo-S3TWatch-2020.zip LilyGo-TDisplayS3-Touch.zip JCMK_DevBoardPro.zip RabbitLabs_Minion.zip Lolin_S3_Pro.zip CardputerADV.zip Connecting to Chameleon Ultra\rNote: GhostESP suspends the access point and Wi-Fi services during BLE sessions (including Chameleon connections) to free memory. The radio comes back automatically after you disconnect or run stop.\nOn-Device UI\rOpen Main Menu → NFC → Chameleon Ultra → Connect. The device scans for nearby Chameleon Ultra devices. Wait for the connection popup to show \u0026ldquo;Connected\u0026rdquo;. Battery voltage and percentage appear below the status. Use Disconnect from the same menu when finished. Wi-Fi services resume automatically after disconnecting. Command Line\rRun chameleon connect to start pairing. Optional arguments: timeout in seconds (default 10) if you need more time for discovery. pin if your Chameleon Ultra requires a 4–6 digit security code. Example: chameleon connect 15 1234 Wait for pairing confirmation in the terminal. The CLI announces when the link succeeds. Check status with chameleon status or battery with chameleon battery. Voltage and percentage display before starting long dumps. Run chameleon disconnect when finished. BLE releases and the Wi-Fi services will restore automatically. Saving Dumps\rSave HF scans: After chameleon scanhf completes, run chameleon savehf \u0026lt;name\u0026gt; to write the dump to /mnt/ghostesp/chameleon/. Name files clearly: Use short descriptive names without spaces, for example office_door. Troubleshooting\rConnection timeouts: Keep the Chameleon Ultra awake (press any button) and re-run chameleon connect 20 for a longer window. PIN failures: Verify the configured code on the Chameleon Ultra; three failed attempts may force a power cycle. No BLE advertisements: Check the Chameleon Ultra’s BLE settings or reboot it; GhostESP only connects to active broadcasts. Next Steps\rScanning: Continue with PN532-based scanning guide. Saving: Store remote dumps using Saving Tags. Compatibility: Review what tag families work via Supported Tags. ","description":"Connect GhostESP to a Chameleon Ultra reader","permalink":"/v1.8.1/nfc/chameleon-ultra/","title":"Chameleon Ultra"},{"content":"\rOverview\rGhostESP can control a Chameleon Ultra over Bluetooth Low Energy. Once paired you can reuse the same NFC scan, save, and dump flows as if you had a PN532 module attached.\nPrerequisites\rFirmware: GhostESP build with BLE enabled and the Chameleon Ultra features compiled in. Hardware: A powered Chameleon Ultra advertising over BLE and charged enough for the session. Supported Devices\rChameleon Ultra support is available on the following GhostESP builds:\nesp32-generic.zip esp32s3-generic.zip esp32c3-generic.zip esp32c5-generic-v01.zip esp32c6-generic.zip MarauderV4_FlipperHub.zip MarauderV6_AwokDual.zip ghostboard.zip ESP32-S3-Cardputer.zip CYD2USB.zip CYDMicroUSB.zip CYDDualUSB.zip CYD2USB2.4Inch.zip CYD2USB2.4Inch_C.zip CYD2432S028R.zip LilyGo-T-Deck.zip LilyGo-TEmbedC1101.zip LilyGo-S3TWatch-2020.zip LilyGo-TDisplayS3-Touch.zip JCMK_DevBoardPro.zip RabbitLabs_Minion.zip Lolin_S3_Pro.zip CardputerADV.zip Connecting to Chameleon Ultra\rNote: GhostESP automatically suspends the access point and Wi-Fi services during the connection to free memory for BLE operations. Services restore when you disconnect.\nOn-Device UI\rOpen Main Menu → NFC → Chameleon Ultra → Connect. The device scans for nearby Chameleon Ultra devices. Wait for the connection popup to show \u0026ldquo;Connected\u0026rdquo;. Battery voltage and percentage appear below the status. Use Disconnect from the same menu when finished. Wi-Fi services resume automatically after disconnecting. Command Line\rRun chameleon connect to start pairing. Optional arguments: timeout in seconds (default 10) if you need more time for discovery. pin if your Chameleon Ultra requires a 4–6 digit security code. Example: chameleon connect 15 1234 Wait for pairing confirmation in the terminal. The CLI announces when the link succeeds. Check status with chameleon status or battery with chameleon battery. Voltage and percentage display before starting long dumps. Run chameleon disconnect when finished. BLE releases and the Wi-Fi services will restore automatically. Saving Dumps\rSave HF scans: After chameleon scanhf completes, run chameleon savehf \u0026lt;name\u0026gt; to write the dump to /mnt/ghostesp/chameleon/. Name files clearly: Use short descriptive names without spaces, for example office_door. Troubleshooting\rConnection timeouts: Keep the Chameleon Ultra awake (press any button) and re-run chameleon connect 20 for a longer window. PIN failures: Verify the configured code on the Chameleon Ultra; three failed attempts may force a power cycle. No BLE advertisements: Check the Chameleon Ultra’s BLE settings or reboot it; GhostESP only connects to active broadcasts. Next Steps\rScanning: Continue with PN532-based scanning guide. Saving: Store remote dumps using Saving Tags. Compatibility: Review what tag families work via Supported Tags. ","description":"Connect GhostESP to a Chameleon Ultra reader","permalink":"/v1.8/nfc/chameleon-ultra/","title":"Chameleon Ultra"},{"content":"\rOverview\rGhostESP can control a Chameleon Ultra over BLE. Once paired, use the same NFC scan/save flows as with a PN532.\nPrerequisites\rFirmware: GhostESP build with BLE and Chameleon Ultra features enabled. Hardware: A powered Chameleon Ultra advertising over BLE. Supported Devices\rChameleon Ultra support is available on the following GhostESP builds:\nesp32-generic.zip esp32s3-generic.zip esp32c3-generic.zip esp32c5-generic-v01.zip esp32c6-generic.zip MarauderV4_FlipperHub.zip MarauderV6_AwokDual.zip ghostboard.zip ESP32-S3-Cardputer.zip CYD2USB.zip CYDMicroUSB.zip CYDDualUSB.zip CYD2USB2.4Inch.zip CYD2USB2.4Inch_C.zip CYD2432S028R.zip LilyGo-T-Deck.zip LilyGo-TEmbedC1101.zip LilyGo-S3TWatch-2020.zip LilyGo-TDisplayS3-Touch.zip JCMK_DevBoardPro.zip RabbitLabs_Minion.zip Lolin_S3_Pro.zip CardputerADV.zip Connecting to Chameleon Ultra\rNote: GhostESP suspends the access point and Wi-Fi services during BLE sessions (including Chameleon connections) to free memory. The radio comes back automatically after you disconnect or run stop.\nOn-Device UI\rOpen Main Menu → NFC → Chameleon Ultra → Connect. The device scans for nearby Chameleon Ultra devices. Wait for the connection popup to show \u0026ldquo;Connected\u0026rdquo;. Battery voltage and percentage appear below the status. Use Disconnect from the same menu when finished. Wi-Fi services resume automatically after disconnecting. Command Line\rRun chameleon connect to start pairing. Optional arguments: timeout in seconds (default 10) if you need more time for discovery. pin if your Chameleon Ultra requires a 4–6 digit security code. Example: chameleon connect 15 1234 Wait for pairing confirmation in the terminal. The CLI announces when the link succeeds. Check status with chameleon status or battery with chameleon battery. Voltage and percentage display before starting long dumps. Run chameleon disconnect when finished. BLE releases and the Wi-Fi services will restore automatically. Saving Dumps\rSave HF scans: After chameleon scanhf completes, run chameleon savehf \u0026lt;name\u0026gt; to write the dump to /mnt/ghostesp/chameleon/. Name files clearly: Use short descriptive names without spaces, for example office_door. Troubleshooting\rConnection timeouts: Keep the Chameleon Ultra awake (press any button) and re-run chameleon connect 20 for a longer window. PIN failures: Verify the configured code on the Chameleon Ultra; three failed attempts may force a power cycle. No BLE advertisements: Check the Chameleon Ultra’s BLE settings or reboot it; GhostESP only connects to active broadcasts. Next Steps\rScanning: Continue with PN532-based scanning guide. Saving: Store remote dumps using Saving Tags. Compatibility: Review what tag families work via Supported Tags. ","description":"Connect GhostESP to a Chameleon Ultra reader","permalink":"/v1.9/nfc/chameleon-ultra/","title":"Chameleon Ultra"},{"content":"Manage your Ethernet connection with configuration and status commands.\nConnection Status\rCheck if Ethernet is connected and view link information:\nethup Displays connection status, IP address, and link speed.\nDisconnecting\rBring down the Ethernet interface:\nethdown Configuration\rView Current Configuration\rethconfig show Displays current IP settings (DHCP or static).\nDHCP Configuration\rEnable DHCP to automatically obtain an IP address:\nethconfig dhcp Static IP Configuration\rSet a static IP address:\nethconfig static \u0026lt;ip\u0026gt; \u0026lt;netmask\u0026gt; \u0026lt;gateway\u0026gt; Example:\nethconfig static 192.168.1.100 255.255.255.0 192.168.1.1 MAC Address Management\rView or modify the MAC address:\nethmac Shows current MAC address. Use with caution—changing MAC addresses may affect network access.\nSystem Time\rGet Current Time\rtime Displays the current system time in Unix timestamp format.\nSet System Time\rsettime \u0026lt;unix_timestamp\u0026gt; Example:\nsettime 1703001600 Sync Time via NTP\rSynchronize system time with an NTP server:\nethntp \u0026lt;time_server\u0026gt; If no server is specified, uses pool.ntp.org by default:\nethntp Example with custom server:\nethntp time.nist.gov ","description":"Connect and configure your Ethernet interface.","permalink":"/latest/ethernet/connection/","title":"Connection Management"},{"content":"Manage your Ethernet connection with configuration and status commands.\nConnection Status\rCheck if Ethernet is connected and view link information:\nethup Displays connection status, IP address, and link speed.\nDisconnecting\rBring down the Ethernet interface:\nethdown Configuration\rView Current Configuration\rethconfig show Displays current IP settings (DHCP or static).\nDHCP Configuration\rEnable DHCP to automatically obtain an IP address:\nethconfig dhcp Static IP Configuration\rSet a static IP address:\nethconfig static \u0026lt;ip\u0026gt; \u0026lt;netmask\u0026gt; \u0026lt;gateway\u0026gt; Example:\nethconfig static 192.168.1.100 255.255.255.0 192.168.1.1 MAC Address Management\rView or modify the MAC address:\nethmac Shows current MAC address. Use with caution—changing MAC addresses may affect network access.\nSystem Time\rGet Current Time\rtime Displays the current system time in Unix timestamp format.\nSet System Time\rsettime \u0026lt;unix_timestamp\u0026gt; Example:\nsettime 1703001600 Sync Time via NTP\rSynchronize system time with an NTP server:\nethntp \u0026lt;time_server\u0026gt; If no server is specified, uses pool.ntp.org by default:\nethntp Example with custom server:\nethntp time.nist.gov ","description":"Connect and configure your Ethernet interface.","permalink":"/v1.9/ethernet/connection/","title":"Connection Management"},{"content":"Wi-Fi attacks sound complex, but they\u0026rsquo;re built on a few simple ideas. This page explains what each attack does, why someone might use it, and what you need to know before trying the tools in GhostESP.\nWhat is a Wi-Fi attack?\rA Wi-Fi attack is any action that disrupts, intercepts, or tricks Wi-Fi networks or devices. Most attacks fall into two categories:\nPassive: You listen and record without sending anything. Example: capturing packets to see what devices are on a network. Active: You send frames or signals to change how the network behaves. Example: sending deauth frames to kick devices off. Common attacks explained\rPacket Capture\rWhat it does: Records all Wi-Fi traffic on a channel and saves it to a file (PCAP format).\nWhy: You can analyze the data later to see what devices are connecting, what SSIDs they\u0026rsquo;re looking for, or extract handshakes for password testing.\nLegal note: Capturing traffic on networks you don\u0026rsquo;t own is illegal in most places. Only do this on your own network or with explicit permission.\nLearn more: Capturing packets\nDeauthentication (Deauth)\rWhat it does: Sends a fake \u0026ldquo;disconnect\u0026rdquo; message to a device, forcing it off the network.\nWhy: Tests network stability, forces devices to reconnect (so you can capture their handshake), or disrupts a specific device.\nLegal note: Deauthing devices you don\u0026rsquo;t own is illegal. Only test on your own network.\nLearn more: Deauthentication attacks\nKarma Attack\rWhat it does: Pretends to be a Wi-Fi network that a device is looking for, tricking the device into connecting.\nWhy: Intercept traffic from devices or test how they behave when connecting to fake networks.\nLegal note: Tricking devices into connecting without consent is illegal in most jurisdictions.\nLearn more: Karma attacks\nEvil Portal\rWhat it does: Creates a fake Wi-Fi network with a login page that looks real (like a coffee shop Wi-Fi).\nWhy: Capture credentials, redirect users to a phishing site, or test how users respond to fake login pages.\nLegal note: Impersonating a real network or capturing credentials without consent is illegal.\nLearn more: Evil portals\nHandshake Capture\rWhat it does: Records the WPA/WPA2 authentication handshake between a device and router.\nWhy: Export the handshake to offline password cracking tools to test weak passwords.\nLegal note: Cracking passwords on networks you don\u0026rsquo;t own is illegal.\nLearn more: Handshakes\nBefore you start\rPrerequisites\rA GhostESP device (flashed and working) An SD card (for saving captures) A network you own or have permission to test Basic understanding of Wi-Fi (SSIDs, channels, 2.4 GHz vs 5 GHz) Legal and ethical rules\rOnly test networks you own or have written permission to test. Unauthorized access to networks or devices is illegal in most countries. Disrupting networks (deauth, jamming) without permission is illegal. Impersonating networks or capturing credentials is illegal. Check your local laws before testing. Typical workflow\rScan the area to find networks and devices (see Survey). Choose an attack based on what you want to learn (see attack descriptions above). Capture or execute using the GhostESP menu or CLI. Analyze the results on your computer (e.g., open PCAP files in Wireshark). Next steps\rPick an attack that interests you and read the detailed guide:\nCapturing packets — Record Wi-Fi traffic Handshakes — Extract authentication data Karma attacks — Trick devices into connecting Evil portals — Create fake login pages Survey — Scan for networks and devices ","description":"Learn what Wi-Fi attacks are and how they work before diving into tools.","permalink":"/latest/wifi/basics/","title":"Wi-Fi Basics"},{"content":"Wi-Fi attacks sound complex, but they\u0026rsquo;re built on a few simple ideas. This page explains what each attack does, why someone might use it, and what you need to know before trying the tools in GhostESP.\nWhat is a Wi-Fi attack?\rA Wi-Fi attack is any action that disrupts, intercepts, or tricks Wi-Fi networks or devices. Most attacks fall into two categories:\nPassive: You listen and record without sending anything. Example: capturing packets to see what devices are on a network. Active: You send frames or signals to change how the network behaves. Example: sending deauth frames to kick devices off. Common attacks explained\rPacket Capture\rWhat it does: Records all Wi-Fi traffic on a channel and saves it to a file (PCAP format).\nWhy: You can analyze the data later to see what devices are connecting, what SSIDs they\u0026rsquo;re looking for, or extract handshakes for password testing.\nLegal note: Capturing traffic on networks you don\u0026rsquo;t own is illegal in most places. Only do this on your own network or with explicit permission.\nLearn more: Capturing packets\nDeauthentication (Deauth)\rWhat it does: Sends a fake \u0026ldquo;disconnect\u0026rdquo; message to a device, forcing it off the network.\nWhy: Tests network stability, forces devices to reconnect (so you can capture their handshake), or disrupts a specific device.\nLegal note: Deauthing devices you don\u0026rsquo;t own is illegal. Only test on your own network.\nKarma Attack\rWhat it does: Pretends to be a Wi-Fi network that a device is looking for, tricking the device into connecting.\nWhy: Intercept traffic from devices, test how devices behave when connecting to fake networks, or study device behavior.\nLegal note: Tricking devices into connecting without consent is illegal in most jurisdictions.\nLearn more: Karma attacks\nEvil Portal\rWhat it does: Creates a fake Wi-Fi network with a login page that looks real (like a coffee shop Wi-Fi).\nWhy: Capture credentials, redirect users to a phishing site, or test how users respond to fake login pages.\nLegal note: Impersonating a real network or capturing credentials without consent is illegal.\nLearn more: Evil portals\nHandshake Capture\rWhat it does: Records the WPA/WPA2 authentication handshake between a device and router.\nWhy: Export the handshake to offline password cracking tools to test weak passwords.\nLegal note: Cracking passwords on networks you don\u0026rsquo;t own is illegal.\nLearn more: Handshakes\nBefore you start\rPrerequisites\rA GhostESP device (flashed and working) An SD card (for saving captures) A network you own or have permission to test Basic understanding of Wi-Fi (SSIDs, channels, 2.4 GHz vs 5 GHz) Legal and ethical rules\rOnly test networks you own or have written permission to test. Unauthorized access to networks or devices is illegal in most countries. Disrupting networks (deauth, jamming) without permission is illegal. Impersonating networks or capturing credentials is illegal. Check your local laws before testing. Typical workflow\rScan the area to find networks and devices (see Survey). Choose an attack based on what you want to learn (see attack descriptions above). Capture or execute using the GhostESP menu or CLI. Analyze the results on your computer (e.g., open PCAP files in Wireshark). Next steps\rPick an attack that interests you and read the detailed guide:\nCapturing packets — Record Wi-Fi traffic Handshakes — Extract authentication data Karma attacks — Trick devices into connecting Evil portals — Create fake login pages Survey — Scan for networks and devices ","description":"Learn what Wi-Fi attacks are and how they work before diving into tools.","permalink":"/v1.8.1/wifi/basics/","title":"Wi-Fi Basics"},{"content":"Wi-Fi attacks sound complex, but they\u0026rsquo;re built on a few simple ideas. This page explains what each attack does, why someone might use it, and what you need to know before trying the tools in GhostESP.\nWhat is a Wi-Fi attack?\rA Wi-Fi attack is any action that disrupts, intercepts, or tricks Wi-Fi networks or devices. Most attacks fall into two categories:\nPassive: You listen and record without sending anything. Example: capturing packets to see what devices are on a network. Active: You send frames or signals to change how the network behaves. Example: sending deauth frames to kick devices off. Common attacks explained\rPacket Capture\rWhat it does: Records all Wi-Fi traffic on a channel and saves it to a file (PCAP format).\nWhy: You can analyze the data later to see what devices are connecting, what SSIDs they\u0026rsquo;re looking for, or extract handshakes for password testing.\nLegal note: Capturing traffic on networks you don\u0026rsquo;t own is illegal in most places. Only do this on your own network or with explicit permission.\nLearn more: Capturing packets\nDeauthentication (Deauth)\rWhat it does: Sends a fake \u0026ldquo;disconnect\u0026rdquo; message to a device, forcing it off the network.\nWhy: Tests network stability, forces devices to reconnect (so you can capture their handshake), or disrupts a specific device.\nLegal note: Deauthing devices you don\u0026rsquo;t own is illegal. Only test on your own network.\nKarma Attack\rWhat it does: Pretends to be a Wi-Fi network that a device is looking for, tricking the device into connecting.\nWhy: Intercept traffic from devices, test how devices behave when connecting to fake networks, or study device behavior.\nLegal note: Tricking devices into connecting without consent is illegal in most jurisdictions.\nLearn more: Karma attacks\nEvil Portal\rWhat it does: Creates a fake Wi-Fi network with a login page that looks real (like a coffee shop Wi-Fi).\nWhy: Capture credentials, redirect users to a phishing site, or test how users respond to fake login pages.\nLegal note: Impersonating a real network or capturing credentials without consent is illegal.\nLearn more: Evil portals\nHandshake Capture\rWhat it does: Records the WPA/WPA2 authentication handshake between a device and router.\nWhy: Export the handshake to offline password cracking tools to test weak passwords.\nLegal note: Cracking passwords on networks you don\u0026rsquo;t own is illegal.\nLearn more: Handshakes\nBefore you start\rPrerequisites\rA GhostESP device (flashed and working) An SD card (for saving captures) A network you own or have permission to test Basic understanding of Wi-Fi (SSIDs, channels, 2.4 GHz vs 5 GHz) Legal and ethical rules\rOnly test networks you own or have written permission to test. Unauthorized access to networks or devices is illegal in most countries. Disrupting networks (deauth, jamming) without permission is illegal. Impersonating networks or capturing credentials is illegal. Check your local laws before testing. Typical workflow\rScan the area to find networks and devices (see Survey). Choose an attack based on what you want to learn (see attack descriptions above). Capture or execute using the GhostESP menu or CLI. Analyze the results on your computer (e.g., open PCAP files in Wireshark). Next steps\rPick an attack that interests you and read the detailed guide:\nCapturing packets — Record Wi-Fi traffic Handshakes — Extract authentication data Karma attacks — Trick devices into connecting Evil portals — Create fake login pages Survey — Scan for networks and devices ","description":"Learn what Wi-Fi attacks are and how they work before diving into tools.","permalink":"/v1.8/wifi/basics/","title":"Wi-Fi Basics"},{"content":"Wi-Fi attacks sound complex, but they\u0026rsquo;re built on a few simple ideas. This page explains what each attack does, why someone might use it, and what you need to know before trying the tools in GhostESP.\nWhat is a Wi-Fi attack?\rA Wi-Fi attack is any action that disrupts, intercepts, or tricks Wi-Fi networks or devices. Most attacks fall into two categories:\nPassive: You listen and record without sending anything. Example: capturing packets to see what devices are on a network. Active: You send frames or signals to change how the network behaves. Example: sending deauth frames to kick devices off. Common attacks explained\rPacket Capture\rWhat it does: Records all Wi-Fi traffic on a channel and saves it to a file (PCAP format).\nWhy: You can analyze the data later to see what devices are connecting, what SSIDs they\u0026rsquo;re looking for, or extract handshakes for password testing.\nLegal note: Capturing traffic on networks you don\u0026rsquo;t own is illegal in most places. Only do this on your own network or with explicit permission.\nLearn more: Capturing packets\nDeauthentication (Deauth)\rWhat it does: Sends a fake \u0026ldquo;disconnect\u0026rdquo; message to a device, forcing it off the network.\nWhy: Tests network stability, forces devices to reconnect (so you can capture their handshake), or disrupts a specific device.\nLegal note: Deauthing devices you don\u0026rsquo;t own is illegal. Only test on your own network.\nLearn more: Deauthentication attacks\nKarma Attack\rWhat it does: Pretends to be a Wi-Fi network that a device is looking for, tricking the device into connecting.\nWhy: Intercept traffic from devices or test how they behave when connecting to fake networks.\nLegal note: Tricking devices into connecting without consent is illegal in most jurisdictions.\nLearn more: Karma attacks\nEvil Portal\rWhat it does: Creates a fake Wi-Fi network with a login page that looks real (like a coffee shop Wi-Fi).\nWhy: Capture credentials, redirect users to a phishing site, or test how users respond to fake login pages.\nLegal note: Impersonating a real network or capturing credentials without consent is illegal.\nLearn more: Evil portals\nHandshake Capture\rWhat it does: Records the WPA/WPA2 authentication handshake between a device and router.\nWhy: Export the handshake to offline password cracking tools to test weak passwords.\nLegal note: Cracking passwords on networks you don\u0026rsquo;t own is illegal.\nLearn more: Handshakes\nBefore you start\rPrerequisites\rA GhostESP device (flashed and working) An SD card (for saving captures) A network you own or have permission to test Basic understanding of Wi-Fi (SSIDs, channels, 2.4 GHz vs 5 GHz) Legal and ethical rules\rOnly test networks you own or have written permission to test. Unauthorized access to networks or devices is illegal in most countries. Disrupting networks (deauth, jamming) without permission is illegal. Impersonating networks or capturing credentials is illegal. Check your local laws before testing. Typical workflow\rScan the area to find networks and devices (see Survey). Choose an attack based on what you want to learn (see attack descriptions above). Capture or execute using the GhostESP menu or CLI. Analyze the results on your computer (e.g., open PCAP files in Wireshark). Next steps\rPick an attack that interests you and read the detailed guide:\nCapturing packets — Record Wi-Fi traffic Handshakes — Extract authentication data Karma attacks — Trick devices into connecting Evil portals — Create fake login pages Survey — Scan for networks and devices ","description":"Learn what Wi-Fi attacks are and how they work before diving into tools.","permalink":"/v1.9/wifi/basics/","title":"Wi-Fi Basics"},{"content":"build.py wraps Espressif\u0026rsquo;s build tools so you can change GhostESP feature flags without manual setup. Follow these steps to run menuconfig, persist changes, and rebuild.\nPrerequisites\rPython 3 installed with access to the command line. ESP-IDF v5.4.1, v5.5 or v5.5.1 on disk. build.py can auto-detect common locations or also download it for you. GhostESP repository cloned locally. Clone from GitHub and navigate into the project directory before running the script. 1. Launch the helper\rFrom the project root:\npython build.py Skip the interactive picker if you know your targets:\npython build.py --targets 2 3 Use --targets all to queue every board profile.\nWhen prompted for ESP-IDF, confirm a detected path or allow the script to download v5.5. Use --idf-path \u0026lt;path\u0026gt; to skip the prompt.\n2. Select a build target\rGhostESP ships configs for multiple boards inside configs/. The helper lists them with numeric IDs. Enter the index for the target whose Kconfig you want to edit (for example esp32s3-generic).\nThe script copies that entry\u0026rsquo;s sdkconfig.* file into sdkconfig and sdkconfig.defaults, then runs idf.py set-target so menuconfig matches the board.\n3. Run menuconfig for GhostESP options\rAfter applying the base config, build.py launches:\nidf.py menuconfig Use the menu to browse GhostESP Options → GhostESP Features. Save and exit when finished.\nEnabling NFC features\rOpen Ghost ESP Options → NFC Options to toggle the backends:\nEnable PN532 NFC turns on the PN532 reader and exposes pin settings for SCL/SDA/IRQ/RST. Enable Chameleon Ultra NFC lets GhostESP use a Chameleon Ultra over BLE as the NFC front-end. This option defaults to enabled when BLE is compiled in. Turning on either backend automatically sets the internal HAS_NFC flag, which enables the UI and shared NFC code paths.\nEnabling displays\rNavigate to Ghost ESP Options → Display Options for screen hardware:\nToggle Enable Screen Support to bring the LCD driver into the build. Adjust resolution via TFT Width and TFT Height, or enable board-specific panels such as Enable Waveshare LCD, Enable Crowtech LCD, Enable Sunton LCD, or Enable JC3248W535EN LCD depending on your hardware. Optional helpers like Enable Touchscreen, Use 7-inch Display, and Enable Status Display expose extra pins and I2C settings when needed. Status Display Configuration\rWhen Enable Status Display is enabled, you can configure:\nStatus Display SDA Pin and Status Display SCL Pin: I2C pins for the OLED display (default: GPIO 6/7 for shared IO expander bus, or GPIO 17/18 for Heltec V3). Status Display I2C Port: I2C controller port (0 or 1). Status Display I2C Address: I2C address (default: 0x3C for most OLED displays). Status Display Power Control Pin (Vext): GPIO pin for power control. For Heltec V3, set this to GPIO 36. Set to -1 to disable. Status Display Reset Pin: GPIO pin for display reset. For Heltec V3, set this to GPIO 21. Set to -1 to disable. Rotate status display 180 degrees: Optional rotation setting. The status display shows system information, attack status, and idle animations when configured. It\u0026rsquo;s particularly useful for boards like the Heltec V3 which includes an onboard OLED display.\nConfiguring LVGL display driver\rAfter enabling Enable Screen Support, navigate to Component config → LVGL to configure the display driver:\nUnder LVGL TFT Display, select your display controller (e.g., ILI9341, ST7789, etc.). Configure LVGL Touch Input if your screen has a touchscreen. Adjust LVGL Display Settings for rotation, color depth, and refresh rate as needed for your hardware. 4. Decide where to store your changes\rOnce menuconfig exits, build.py asks whether to write the new configuration back into the source tree:\nYes — Copies the generated sdkconfig into the original configs/sdkconfig.* file and into sdkconfig.defaults. Choose this when you want the board profile to permanently carry the new settings. No — Keeps sdkconfig.defaults updated for the current build only without altering the source file. This is useful when experimenting. Regardless of your choice, the helper syncs sdkconfig.defaults so the next build uses the options you just saved.\n5. Rebuild firmware (optional)\rIf you continue through the prompts, build.py can clean, rebuild, and package artifacts automatically. Otherwise, rerun later with:\npython build.py --targets \u0026lt;index\u0026gt; The script will reuse the modified sdkconfig.defaults unless you overwrite it.\nTips\rRunning python build.py --no-auto-download disables the ESP-IDF fetch prompt if you prefer manual installs only. Delete sdkconfig and sdkconfig.defaults to revert to the pristine profile before another run. Use separate directories or virtual environments per ESP-IDF version to avoid mixing toolchains when switching targets. ","description":"Use the build helper to edit GhostESP configuration options.","permalink":"/latest/development/build-py-kconfig/","title":"Adjusting build options"},{"content":"The build.py helper wraps Espressif\u0026rsquo;s build tools so you can change GhostESP feature flags without setting up the environment manually. Follow the steps below to run menuconfig, persist your changes, and rebuild with the updated settings.\nPrerequisites\rPython 3 installed with access to the command line. ESP-IDF v5.4.1, v5.5 or v5.5.1 on disk. build.py can auto-detect common locations or also download it for you. GhostESP repository cloned locally. Clone from GitHub and navigate into the project directory before running the script. 1. Launch the helper\rFrom the project root, run:\npython build.py If you already know which boards you want to modify, you can skip the interactive picker:\npython build.py --targets 2 3 Use --targets all to queue every board profile.\nWhen prompted for ESP-IDF, confirm a detected path or allow the script to download v5.5 automatically. Supplying --idf-path \u0026lt;path\u0026gt; bypasses the prompt entirely.\n2. Select a build target\rGhostESP ships configs for multiple boards inside configs/. The helper lists them with numeric IDs. Enter the index for the target whose Kconfig you want to edit (for example esp32s3-generic).\nThe script copies that entry\u0026rsquo;s sdkconfig.* file into sdkconfig and sdkconfig.defaults, then runs idf.py set-target so menuconfig matches the board.\n3. Run menuconfig for GhostESP options\rAfter applying the base config, build.py launches:\nidf.py menuconfig Use the curses UI to browse GhostESP Options → GhostESP Features and any other menus you need. When finished, save and exit menuconfig.\nEnabling NFC features\rOpen Ghost ESP Options → NFC Options to toggle the backends:\nEnable PN532 NFC turns on the PN532 reader and exposes pin settings for SCL/SDA/IRQ/RST. Enable Chameleon Ultra NFC lets GhostESP use a Chameleon Ultra over BLE as the NFC front-end. This option defaults to enabled when BLE is compiled in. Turning on either backend automatically sets the internal HAS_NFC flag, which enables the UI and shared NFC code paths.\nEnabling displays\rNavigate to Ghost ESP Options → Display Options for screen hardware:\nToggle Enable Screen Support to bring the LCD driver into the build. Adjust resolution via TFT Width and TFT Height, or enable board-specific panels such as Enable Waveshare LCD, Enable Crowtech LCD, Enable Sunton LCD, or Enable JC3248W535EN LCD depending on your hardware. Optional helpers like Enable Touchscreen, Use 7-inch Display, and Enable Status Display expose extra pins and I2C settings when needed. Configuring LVGL display driver\rAfter enabling Enable Screen Support, navigate to Component config → LVGL to configure the display driver:\nUnder LVGL TFT Display, select your display controller (e.g., ILI9341, ST7789, etc.). Configure LVGL Touch Input if your screen has a touchscreen. Adjust LVGL Display Settings for rotation, color depth, and refresh rate as needed for your hardware. 4. Decide where to store your changes\rOnce menuconfig exits, build.py asks whether to write the new configuration back into the source tree:\nYes — Copies the generated sdkconfig into the original configs/sdkconfig.* file and into sdkconfig.defaults. Choose this when you want the board profile to permanently carry the new settings. No — Keeps sdkconfig.defaults updated for the current build only without altering the source file. This is useful when experimenting. Regardless of your choice, the helper syncs sdkconfig.defaults so the next build uses the options you just saved.\n5. Rebuild firmware (optional)\rIf you continue through the prompts, build.py can clean, rebuild, and package artifacts automatically. Otherwise, rerun later with:\npython build.py --targets \u0026lt;index\u0026gt; The script will reuse the modified sdkconfig.defaults unless you overwrite it.\nTips\rRunning python build.py --no-auto-download disables the ESP-IDF fetch prompt if you prefer manual installs only. Delete sdkconfig and sdkconfig.defaults to revert to the pristine profile before another run. Use separate directories or virtual environments per ESP-IDF version to avoid mixing toolchains when switching targets. ","description":"Use the build helper to edit GhostESP configuration options.","permalink":"/v1.8.1/development/build-py-kconfig/","title":"Adjusting build options"},{"content":"The build.py helper wraps Espressif\u0026rsquo;s build tools so you can change GhostESP feature flags without setting up the environment manually. Follow the steps below to run menuconfig, persist your changes, and rebuild with the updated settings.\nPrerequisites\rPython 3 installed with access to the command line. ESP-IDF v5.4.1, v5.5 or v5.5.1 on disk. build.py can auto-detect common locations or also download it for you. GhostESP repository cloned locally. Clone from GitHub and navigate into the project directory before running the script. 1. Launch the helper\rFrom the project root, run:\npython build.py If you already know which boards you want to modify, you can skip the interactive picker:\npython build.py --targets 2 3 Use --targets all to queue every board profile.\nWhen prompted for ESP-IDF, confirm a detected path or allow the script to download v5.5 automatically. Supplying --idf-path \u0026lt;path\u0026gt; bypasses the prompt entirely.\n2. Select a build target\rGhostESP ships configs for multiple boards inside configs/. The helper lists them with numeric IDs. Enter the index for the target whose Kconfig you want to edit (for example esp32s3-generic).\nThe script copies that entry\u0026rsquo;s sdkconfig.* file into sdkconfig and sdkconfig.defaults, then runs idf.py set-target so menuconfig matches the board.\n3. Run menuconfig for GhostESP options\rAfter applying the base config, build.py launches:\nidf.py menuconfig Use the curses UI to browse GhostESP Options → GhostESP Features and any other menus you need. When finished, save and exit menuconfig.\nEnabling NFC features\rOpen Ghost ESP Options → NFC Options to toggle the backends:\nEnable PN532 NFC turns on the PN532 reader and exposes pin settings for SCL/SDA/IRQ/RST. Enable Chameleon Ultra NFC lets GhostESP use a Chameleon Ultra over BLE as the NFC front-end. This option defaults to enabled when BLE is compiled in. Turning on either backend automatically sets the internal HAS_NFC flag, which enables the UI and shared NFC code paths.\nEnabling displays\rNavigate to Ghost ESP Options → Display Options for screen hardware:\nToggle Enable Screen Support to bring the LCD driver into the build. Adjust resolution via TFT Width and TFT Height, or enable board-specific panels such as Enable Waveshare LCD, Enable Crowtech LCD, Enable Sunton LCD, or Enable JC3248W535EN LCD depending on your hardware. Optional helpers like Enable Touchscreen, Use 7-inch Display, and Enable Status Display expose extra pins and I2C settings when needed. Configuring LVGL display driver\rAfter enabling Enable Screen Support, navigate to Component config → LVGL to configure the display driver:\nUnder LVGL TFT Display, select your display controller (e.g., ILI9341, ST7789, etc.). Configure LVGL Touch Input if your screen has a touchscreen. Adjust LVGL Display Settings for rotation, color depth, and refresh rate as needed for your hardware. 4. Decide where to store your changes\rOnce menuconfig exits, build.py asks whether to write the new configuration back into the source tree:\nYes — Copies the generated sdkconfig into the original configs/sdkconfig.* file and into sdkconfig.defaults. Choose this when you want the board profile to permanently carry the new settings. No — Keeps sdkconfig.defaults updated for the current build only without altering the source file. This is useful when experimenting. Regardless of your choice, the helper syncs sdkconfig.defaults so the next build uses the options you just saved.\n5. Rebuild firmware (optional)\rIf you continue through the prompts, build.py can clean, rebuild, and package artifacts automatically. Otherwise, rerun later with:\npython build.py --targets \u0026lt;index\u0026gt; The script will reuse the modified sdkconfig.defaults unless you overwrite it.\nTips\rRunning python build.py --no-auto-download disables the ESP-IDF fetch prompt if you prefer manual installs only. Delete sdkconfig and sdkconfig.defaults to revert to the pristine profile before another run. Use separate directories or virtual environments per ESP-IDF version to avoid mixing toolchains when switching targets. ","description":"Use the build helper to edit GhostESP configuration options.","permalink":"/v1.8/development/build-py-kconfig/","title":"Adjusting build options"},{"content":"build.py wraps Espressif\u0026rsquo;s build tools so you can change GhostESP feature flags without manual setup. Follow these steps to run menuconfig, persist changes, and rebuild.\nPrerequisites\rPython 3 installed with access to the command line. ESP-IDF v5.4.1, v5.5 or v5.5.1 on disk. build.py can auto-detect common locations or also download it for you. GhostESP repository cloned locally. Clone from GitHub and navigate into the project directory before running the script. 1. Launch the helper\rFrom the project root:\npython build.py Skip the interactive picker if you know your targets:\npython build.py --targets 2 3 Use --targets all to queue every board profile.\nWhen prompted for ESP-IDF, confirm a detected path or allow the script to download v5.5. Use --idf-path \u0026lt;path\u0026gt; to skip the prompt.\n2. Select a build target\rGhostESP ships configs for multiple boards inside configs/. The helper lists them with numeric IDs. Enter the index for the target whose Kconfig you want to edit (for example esp32s3-generic).\nThe script copies that entry\u0026rsquo;s sdkconfig.* file into sdkconfig and sdkconfig.defaults, then runs idf.py set-target so menuconfig matches the board.\n3. Run menuconfig for GhostESP options\rAfter applying the base config, build.py launches:\nidf.py menuconfig Use the menu to browse GhostESP Options → GhostESP Features. Save and exit when finished.\nEnabling NFC features\rOpen Ghost ESP Options → NFC Options to toggle the backends:\nEnable PN532 NFC turns on the PN532 reader and exposes pin settings for SCL/SDA/IRQ/RST. Enable Chameleon Ultra NFC lets GhostESP use a Chameleon Ultra over BLE as the NFC front-end. This option defaults to enabled when BLE is compiled in. Turning on either backend automatically sets the internal HAS_NFC flag, which enables the UI and shared NFC code paths.\nEnabling displays\rNavigate to Ghost ESP Options → Display Options for screen hardware:\nToggle Enable Screen Support to bring the LCD driver into the build. Adjust resolution via TFT Width and TFT Height, or enable board-specific panels such as Enable Waveshare LCD, Enable Crowtech LCD, Enable Sunton LCD, or Enable JC3248W535EN LCD depending on your hardware. Optional helpers like Enable Touchscreen, Use 7-inch Display, and Enable Status Display expose extra pins and I2C settings when needed. Status Display Configuration\rWhen Enable Status Display is enabled, you can configure:\nStatus Display SDA Pin and Status Display SCL Pin: I2C pins for the OLED display (default: GPIO 6/7 for shared IO expander bus, or GPIO 17/18 for Heltec V3). Status Display I2C Port: I2C controller port (0 or 1). Status Display I2C Address: I2C address (default: 0x3C for most OLED displays). Status Display Power Control Pin (Vext): GPIO pin for power control. For Heltec V3, set this to GPIO 36. Set to -1 to disable. Status Display Reset Pin: GPIO pin for display reset. For Heltec V3, set this to GPIO 21. Set to -1 to disable. Rotate status display 180 degrees: Optional rotation setting. The status display shows system information, attack status, and idle animations when configured. It\u0026rsquo;s particularly useful for boards like the Heltec V3 which includes an onboard OLED display.\nConfiguring LVGL display driver\rAfter enabling Enable Screen Support, navigate to Component config → LVGL to configure the display driver:\nUnder LVGL TFT Display, select your display controller (e.g., ILI9341, ST7789, etc.). Configure LVGL Touch Input if your screen has a touchscreen. Adjust LVGL Display Settings for rotation, color depth, and refresh rate as needed for your hardware. 4. Decide where to store your changes\rOnce menuconfig exits, build.py asks whether to write the new configuration back into the source tree:\nYes — Copies the generated sdkconfig into the original configs/sdkconfig.* file and into sdkconfig.defaults. Choose this when you want the board profile to permanently carry the new settings. No — Keeps sdkconfig.defaults updated for the current build only without altering the source file. This is useful when experimenting. Regardless of your choice, the helper syncs sdkconfig.defaults so the next build uses the options you just saved.\n5. Rebuild firmware (optional)\rIf you continue through the prompts, build.py can clean, rebuild, and package artifacts automatically. Otherwise, rerun later with:\npython build.py --targets \u0026lt;index\u0026gt; The script will reuse the modified sdkconfig.defaults unless you overwrite it.\nTips\rRunning python build.py --no-auto-download disables the ESP-IDF fetch prompt if you prefer manual installs only. Delete sdkconfig and sdkconfig.defaults to revert to the pristine profile before another run. Use separate directories or virtual environments per ESP-IDF version to avoid mixing toolchains when switching targets. ","description":"Use the build helper to edit GhostESP configuration options.","permalink":"/v1.9/development/build-py-kconfig/","title":"Adjusting build options"},{"content":"Flash GhostESP firmware to your ESP32 board using the web flasher, manual USB tool, or Flipper Zero app. Choose the method that works best for your setup.\nPrerequisites\rA compatible ESP32 board (see Supported Hardware) A USB cable (Micro USB or USB-C; must be a data cable, not charge-only) A modern web browser (Chrome, Brave, or Edge; Firefox doesn\u0026rsquo;t support WebSerial) 7-Zip or similar tool to extract firmware files VPN/firewall disabled (some configurations interfere with the web flasher) Flashing Methods\rChoose one:\nWeb Flasher Method (Recommended)\rOpen the flasher\nGo to flasher.ghostesp.net in Chrome, Brave, or Edge. Close any apps using the serial port. Enter bootloader mode\nHold BOOT, plug in USB, then release BOOT. If that doesn\u0026rsquo;t work: hold BOOT, tap RESET, keep BOOT held for 1–2 seconds, then release. Flash the firmware\nSelect your ESP32 variant from the dropdown. Click Connect and follow the on-screen prompts. Restart the device\nUnplug and replug the USB cable. If the flasher times out, try again. Note: If the flasher site glitches, clear your browser cache and reload.\nUSB Connection Method\rUse this method if you prefer manual control or the web flasher doesn\u0026rsquo;t work.\nDownload the firmware\nGo to GhostESP Releases. Download the .zip file for your board. Extract it with 7-Zip or your preferred tool. Enter bootloader mode\nHold BOOT, plug in USB, then release BOOT. If that doesn\u0026rsquo;t work: hold BOOT, tap RESET, keep BOOT held for 1–2 seconds, then release. Flash using ESP Huhn Tool\nOpen ESP Huhn Tool in your browser. Click Connect and select your device\u0026rsquo;s COM port. Load the three binary files with the correct offsets: Chip bootloader.bin partitions.bin firmware.bin ESP32-S2 0x1000 0x8000 0x10000 ESP32-S3 / C3 / C6 0x0 0x8000 0x10000 Click Flash and wait for completion. Verify the flash\nUnplug and replug the USB cable. Open a serial console to see device logs. Flipper Zero Method\rFlash GhostESP using your Flipper Zero as the programmer. No PC required.\nInstall the GhostESP app\nDownload from the Flipper app store or releases. Copy the .fap file to your Flipper\u0026rsquo;s SD card. Download the firmware\nGo to GhostESP Releases. Download the .zip file that matches your ESP32 chip (e.g., esp32-generic.zip for a generic ESP32). Extract the .zip file. Copy firmware files to Flipper\nUse qFlipper or pull out the Flipper\u0026rsquo;s SD card and insert it into your computer. Copy the three .bin files to SDCard/apps_data/esp_flasher/. Do not put them in assets/. Wire the ESP32 to Flipper\nConnect the ESP32 to the Flipper\u0026rsquo;s GPIO pins (refer to the GhostESP app for pinout). Enter bootloader mode on the ESP32 (hold BOOT, plug USB, release BOOT). Flash the firmware\nOpen the ESP flasher app on your Flipper. Select Manual Flash. Choose bootloader.bin, partitions.bin, and GhostESP.bin. Verify the device variant is correct. Start the flash and wait for completion. Reset the ESP32 when done. After Flashing\rGhostESP boots automatically and creates a Wi-Fi access point called GhostNet (password: GhostNet). Choose how you want to control it.\nControl Methods\rWeb Interface (Easiest)\nConnect to the GhostNet Wi-Fi network. Open a browser and go to ghostesp.local or 192.168.4.1. No authentication required by default. Run webauth on in the terminal to enable login. Limitation: Wi-Fi and BLE commands don\u0026rsquo;t work here (the radio is hosting the AP). Use GhostLink to run attacks remotely. Serial Terminal (Full Control)\nConnect via USB and open a serial console at 115200 baud. Access all CLI commands. See Command Line Reference. On Android, use Serial USB Terminal. Flipper Zero App\nDownload from the Flipper app store. Control GhostESP directly from your Flipper. Qt6 Desktop App\nDownload and install for advanced features and customization. Touch Screen (Supported Boards Only)\nNavigate menus with touch gestures. Use the on-screen terminal for keyboard input. Troubleshooting\rDevice won\u0026rsquo;t boot or loops\nVerify you flashed the correct firmware for your chip. Try a different USB cable (some are charge-only). Reboot the device and wait 10 seconds. Flash fails or times out\nEnsure the chip is in bootloader mode (hold BOOT while plugging in USB). Try a different USB port or hub. Close other apps using the serial port. Can\u0026rsquo;t connect to GhostNet\nReboot the device. Check that you\u0026rsquo;re using the correct password: GhostNet. Move closer to the device. Web flasher doesn\u0026rsquo;t work\nClear your browser cache. Try Chrome, Brave, or Edge (Firefox doesn\u0026rsquo;t support WebSerial). Disable VPN or firewall temporarily. Serial connection issues\nInstall the USB-to-UART driver. Verify the correct COM port is selected. Flipper Zero flashing fails\nDouble-check GPIO wiring between ESP32 and Flipper. Confirm all .bin files are in SDCard/apps_data/esp_flasher/ (not assets/). Verify the device variant matches your ESP32 chip. ","description":"Flash GhostESP firmware to your ESP32 device","permalink":"/latest/getting-started/installation-guide/","title":"Installation Guide"},{"content":"\rPrerequisites\rBefore starting, make sure you have:\nA compatible ESP32 board (see Supported Hardware) A modern web browser (Google Chrome, Brave, or Microsoft Edge is recommended, as Firefox doesn\u0026rsquo;t support WebSerial) An appropriate USB cable (Micro USB or USB-C, ensure it\u0026rsquo;s a data cable, not a charge-only cable) File Extraction Tool: Install 7-Zip or a similar program for extracting .zip bundles. Note\nFor best results, disable any VPN or firewall that might block the flashing process, as some network configurations may interfere with the web flasher.\nFlashing Methods\rChoose your preferred method:\nWeb Flasher Method (Recommended) USB Connection Method Flipper Zero Method (Doesn\u0026rsquo;t require a PC) Web Flasher Method\rPrepare\nOpen flasher.ghostesp.net in Chrome. Close apps using the serial port. If the site glitches, clear cache. Enter Bootloader\nHold BOOT → plug USB → release. If needed: hold BOOT, tap RESET, keep holding BOOT 1–2 s, release. Flash\nPick your the ESP32 variant your board uses, click Connect, and follow the prompts. Verify\nUnplug and replug. Continue with Post-Installation. Tips: After flashing, you will need to restart the device to initialize the new firmware. Disconnect and reconnect your ESP32. If the flasher times out, retry after a fresh USB reconnection.\nUSB Connection Method\rUse when selecting files and offsets manually.\nDownload\nGet firmware from GhostESP Releases. Extract the .zip with your preferred tool. Connect\nEnter bootloader Hold BOOT → plug USB → release. If needed: hold BOOT, tap RESET, keep holding BOOT 1–2 s, release. Flash via ESP Huhn Tool\nClick Connect, select the COM port labeled with your chipset. Load binaries with offsets: Chip family bootloader.bin partitions.bin (Partition table) firmware.bin (GhostESP_IDF) ESP32-S2 and similar 0x1000 0x8000 0x10000 ESP32-S3 / C3 / C6 0x0 0x8000 0x10000 Click Flash and wait. Verify\nReplug the board and connect to a serial console to see logs from your device. Flipper Zero Method\rDownload\nInstall GhostESP app (.fap) from the Flipper app store\nor releases. Download firmware from GhostESP Releases. Prepare\nExtract archives. Choose the firmware that matches your chip\n(e.g., Flipper Dev Board = ESP32-S2 generic). Copy to Flipper\nUse qFlipper (either the mobile app or the desktop app) or pull out the sd card and use the sd card directly. Put the .bin files in SDCard/apps_data/esp_flasher/. Do not use assets/. Connect Hardware\nWire ESP32 to Flipper GPIO. Enter bootloader (see Web Flasher Method). Flash on Flipper\nOpen ESP flasher → Manual Flash. Select bootloader.bin, partitions.bin, GhostESP.bin and make sure to check the option if your device is one of the specified variants. Start flash. Reset the ESP32 when done. Post-Installation\rAs soon as the flash finishes, GhostESP boots its default access point so you can pick the control surface that fits your hardware and workflow.\nControl Options\rWeb Interface\nConnect to the GhostNet AP with the password GhostNet Open a browser and connect to either ghostesp.local (requires mDNS support) or 192.168.4.1 to access device settings. WebUI authentication starts disabled. Run webauth on in the serial/Web CLI if you want to enable HTTP Digest login (defaults: GhostNet / GhostNet). Use the auto-updating configuration panel to manage settings, Evil Portal controls, and device info. Qt6 Control App\nDownload and install the Qt6-based desktop application for more advanced control options. Offers access to advanced features, customizable settings, and an improved interface for interacting with GhostESP. Serial Command Line\nConnect via a serial interface for direct command-line control. Provides full access to GhostESP\u0026rsquo;s command suite and is ideal for advanced users or troubleshooting. Refer to the Command Line Reference for available commands and examples. Android devices can interface with the serial command line directly using the Serial USB Terminal app Flipper Zero App\nControl GhostESP directly from the Flipper Zero. Now available directly from the official flipper app store! Ensure you have the latest .fap version on your Flipper Zero for full functionality and access to features like Evil Portal, Wi-Fi control, and more. Touch Screen Interface (for supported boards)\nNavigate through menus using touch gestures Access all major features through the graphical interface Terminal App available for keyboard-based command input on boards with keyboards Common Installation Issues\rBoot loops: Usually power or board-target mismatches—verify you flashed the right image and try a known-good USB-C cable. Flash errors: Ensure the chip is in bootloader mode (Refer back to the Web Flasher section) ; swap USB ports or hubs if it times out. Connection issues: Try installing the USB-to-UART driver. Browser issues: If the web flasher misbehaves, reload the page, clear cached site data or switch to a different broswer like Chrome, Brave or Microsoft Edge. Troubleshooting Tip: When flashing from the Flipper Zero app, double-check GPIO wiring and confirm every firmware blob lives under SDCard/apps_data/esp_flasher/ before you start the transfer.\n","description":"Instructions for installing GhostESP firmware on ESP32 devices","permalink":"/v1.8.1/getting-started/installation-guide/","title":"Installation Guide"},{"content":"\rPrerequisites\rBefore starting, make sure you have:\nA compatible ESP32 board (see Supported Hardware) A modern web browser (Google Chrome, Brave, or Microsoft Edge is recommended, as Firefox doesn\u0026rsquo;t support WebSerial) An appropriate USB cable (Micro USB or USB-C, ensure it\u0026rsquo;s a data cable, not a charge-only cable) File Extraction Tool: Install 7-Zip or a similar program for extracting .zip bundles. Note\nFor best results, disable any VPN or firewall that might block the flashing process, as some network configurations may interfere with the web flasher.\nFlashing Methods\rChoose your preferred method:\nWeb Flasher Method (Recommended) USB Connection Method Flipper Zero Method (Doesn\u0026rsquo;t require a PC) Web Flasher Method\rPrepare\nOpen flasher.ghostesp.net in Chrome. Close apps using the serial port. If the site glitches, clear cache. Enter Bootloader\nHold BOOT → plug USB → release. If needed: hold BOOT, tap RESET, keep holding BOOT 1–2 s, release. Flash\nPick your the ESP32 variant your board uses, click Connect, and follow the prompts. Verify\nUnplug and replug. Continue with Post-Installation. Tips: After flashing, you will need to restart the device to initialize the new firmware. Disconnect and reconnect your ESP32. If the flasher times out, retry after a fresh USB reconnection.\nUSB Connection Method\rUse when selecting files and offsets manually.\nDownload\nGet firmware from GhostESP Releases. Extract the .zip with your preferred tool. Connect\nEnter bootloader Hold BOOT → plug USB → release. If needed: hold BOOT, tap RESET, keep holding BOOT 1–2 s, release. Flash via ESP Huhn Tool\nClick Connect, select the COM port labeled with your chipset. Load binaries with offsets: Chip family bootloader.bin partitions.bin (Partition table) firmware.bin (GhostESP_IDF) ESP32-S2 and similar 0x1000 0x8000 0x10000 ESP32-S3 / C3 / C6 0x0 0x8000 0x10000 Click Flash and wait. Verify\nReplug the board and connect to a serial console to see logs from your device. Flipper Zero Method\rDownload\nInstall GhostESP app (.fap) from the Flipper app store\nor releases. Download firmware from GhostESP Releases. Prepare\nExtract archives. Choose the firmware that matches your chip\n(e.g., Flipper Dev Board = ESP32-S2 generic). Copy to Flipper\nUse qFlipper (either the mobile app or the desktop app) or pull out the sd card and use the sd card directly. Put the .bin files in SDCard/apps_data/esp_flasher/. Do not use assets/. Connect Hardware\nWire ESP32 to Flipper GPIO. Enter bootloader (see Web Flasher Method). Flash on Flipper\nOpen ESP flasher → Manual Flash. Select bootloader.bin, partitions.bin, GhostESP.bin and make sure to check the option if your device is one of the specified variants. Start flash. Reset the ESP32 when done. Post-Installation\rAs soon as the flash finishes, GhostESP boots its default access point so you can pick the control surface that fits your hardware and workflow.\nControl Options\rWeb Interface\nConnect to the GhostNet AP with the password GhostNet Open a browser and connect to either ghostesp.local (requires mDNS support) or 192.168.4.1 to access device settings. Sign in with the default credentials GhostNet / GhostNet. Run webauth off in the serial/Web CLI if you want to disable the WebUI authentication. Use the auto-updating configuration panel to manage settings, Evil Portal controls, and device info. Qt6 Control App\nDownload and install the Qt6-based desktop application for more advanced control options. Offers access to advanced features, customizable settings, and an improved interface for interacting with GhostESP. Serial Command Line\nConnect via a serial interface for direct command-line control. Provides full access to GhostESP\u0026rsquo;s command suite and is ideal for advanced users or troubleshooting. Refer to the Command Line Reference for available commands and examples. Android devices can interface with the serial command line directly using the Serial USB Terminal app Flipper Zero App\nControl GhostESP directly from the Flipper Zero. Now available directly from the official flipper app store! Ensure you have the latest .fap version on your Flipper Zero for full functionality and access to features like Evil Portal, Wi-Fi control, and more. Touch Screen Interface (for supported boards)\nNavigate through menus using touch gestures Access all major features through the graphical interface Terminal App available for keyboard-based command input on boards with keyboards Common Installation Issues\rBoot loops: Usually power or board-target mismatches—verify you flashed the right image and try a known-good USB-C cable. Flash errors: Ensure the chip is in bootloader mode (Refer back to the Web Flasher section) ; swap USB ports or hubs if it times out. Connection issues: Try installing the USB-to-UART driver. Browser issues: If the web flasher misbehaves, reload the page, clear cached site data or switch to a different broswer like Chrome, Brave or Microsoft Edge. Troubleshooting Tip: When flashing from the Flipper Zero app, double-check GPIO wiring and confirm every firmware blob lives under SDCard/apps_data/esp_flasher/ before you start the transfer.\n","description":"Instructions for installing GhostESP firmware on ESP32 devices","permalink":"/v1.8/getting-started/installation-guide/","title":"Installation Guide"},{"content":"Flash GhostESP firmware to your ESP32 board using the web flasher, manual USB tool, or Flipper Zero app. Choose the method that works best for your setup.\nPrerequisites\rA compatible ESP32 board (see Supported Hardware) A USB cable (Micro USB or USB-C; must be a data cable, not charge-only) A modern web browser (Chrome, Brave, or Edge; Firefox doesn\u0026rsquo;t support WebSerial) 7-Zip or similar tool to extract firmware files VPN/firewall disabled (some configurations interfere with the web flasher) Flashing Methods\rChoose one:\nWeb Flasher Method (Recommended)\rOpen the flasher\nGo to flasher.ghostesp.net in Chrome, Brave, or Edge. Close any apps using the serial port. Enter bootloader mode\nHold BOOT, plug in USB, then release BOOT. If that doesn\u0026rsquo;t work: hold BOOT, tap RESET, keep BOOT held for 1–2 seconds, then release. Flash the firmware\nSelect your ESP32 variant from the dropdown. Click Connect and follow the on-screen prompts. Restart the device\nUnplug and replug the USB cable. If the flasher times out, try again. Note: If the flasher site glitches, clear your browser cache and reload.\nUSB Connection Method\rUse this method if you prefer manual control or the web flasher doesn\u0026rsquo;t work.\nDownload the firmware\nGo to GhostESP Releases. Download the .zip file for your board. Extract it with 7-Zip or your preferred tool. Enter bootloader mode\nHold BOOT, plug in USB, then release BOOT. If that doesn\u0026rsquo;t work: hold BOOT, tap RESET, keep BOOT held for 1–2 seconds, then release. Flash using ESP Huhn Tool\nOpen ESP Huhn Tool in your browser. Click Connect and select your device\u0026rsquo;s COM port. Load the three binary files with the correct offsets: Chip bootloader.bin partitions.bin firmware.bin ESP32-S2 0x1000 0x8000 0x10000 ESP32-S3 / C3 / C6 0x0 0x8000 0x10000 Click Flash and wait for completion. Verify the flash\nUnplug and replug the USB cable. Open a serial console to see device logs. Flipper Zero Method\rFlash GhostESP using your Flipper Zero as the programmer. No PC required.\nInstall the GhostESP app\nDownload from the Flipper app store or releases. Copy the .fap file to your Flipper\u0026rsquo;s SD card. Download the firmware\nGo to GhostESP Releases. Download the .zip file that matches your ESP32 chip (e.g., esp32-generic.zip for a generic ESP32). Extract the .zip file. Copy firmware files to Flipper\nUse qFlipper or pull out the Flipper\u0026rsquo;s SD card and insert it into your computer. Copy the three .bin files to SDCard/apps_data/esp_flasher/. Do not put them in assets/. Wire the ESP32 to Flipper\nConnect the ESP32 to the Flipper\u0026rsquo;s GPIO pins (refer to the GhostESP app for pinout). Enter bootloader mode on the ESP32 (hold BOOT, plug USB, release BOOT). Flash the firmware\nOpen the ESP flasher app on your Flipper. Select Manual Flash. Choose bootloader.bin, partitions.bin, and GhostESP.bin. Verify the device variant is correct. Start the flash and wait for completion. Reset the ESP32 when done. After Flashing\rGhostESP boots automatically and creates a Wi-Fi access point called GhostNet (password: GhostNet). Choose how you want to control it.\nControl Methods\rWeb Interface (Easiest)\nConnect to the GhostNet Wi-Fi network. Open a browser and go to ghostesp.local or 192.168.4.1. No authentication required by default. Run webauth on in the terminal to enable login. Limitation: Wi-Fi and BLE commands don\u0026rsquo;t work here (the radio is hosting the AP). Use GhostLink to run attacks remotely. Serial Terminal (Full Control)\nConnect via USB and open a serial console at 115200 baud. Access all CLI commands. See Command Line Reference. On Android, use Serial USB Terminal. Flipper Zero App\nDownload from the Flipper app store. Control GhostESP directly from your Flipper. Qt6 Desktop App\nDownload and install for advanced features and customization. Touch Screen (Supported Boards Only)\nNavigate menus with touch gestures. Use the on-screen terminal for keyboard input. Troubleshooting\rDevice won\u0026rsquo;t boot or loops\nVerify you flashed the correct firmware for your chip. Try a different USB cable (some are charge-only). Reboot the device and wait 10 seconds. Flash fails or times out\nEnsure the chip is in bootloader mode (hold BOOT while plugging in USB). Try a different USB port or hub. Close other apps using the serial port. Can\u0026rsquo;t connect to GhostNet\nReboot the device. Check that you\u0026rsquo;re using the correct password: GhostNet. Move closer to the device. Web flasher doesn\u0026rsquo;t work\nClear your browser cache. Try Chrome, Brave, or Edge (Firefox doesn\u0026rsquo;t support WebSerial). Disable VPN or firewall temporarily. Serial connection issues\nInstall the USB-to-UART driver. Verify the correct COM port is selected. Flipper Zero flashing fails\nDouble-check GPIO wiring between ESP32 and Flipper. Confirm all .bin files are in SDCard/apps_data/esp_flasher/ (not assets/). Verify the device variant matches your ESP32 chip. ","description":"Flash GhostESP firmware to your ESP32 device","permalink":"/v1.9/getting-started/installation-guide/","title":"Installation Guide"},{"content":"ESP32-S3 devices can use USB Host mode to accept input from a USB keyboard.\nRequirements\rESP32-S3 based device (Cardputer ADV, T-Deck, etc.) USB OTG adapter (Type-C to USB-A) USB keyboard CONFIG_USE_USB_KEYBOARD enabled in build config Enabling USB Host Mode\rUSB Host mode can be enabled in two ways:\nVia Settings Menu\rNavigate to Settings → System \u0026amp; Hardware Find USB Host Mode Toggle to On Via Command\rusbkbd on To disable:\nusbkbd off To check status:\nusbkbd status Keyboard Controls\rOnce enabled, the following keys control navigation:\nKey Action ↑ Arrow Navigate up ↓ Arrow Navigate down ← Arrow Back / Left → Arrow Right Enter Select ESC Back / Exit All other keys work as normal keyboard input for text fields.\nRemote Keyboard\rWhen two GhostESP devices are connected via Dual Comm, keyboard events are transmitted between them. This allows one device with a USB keyboard to control another device remotely.\nImportant Notes\rCDC Console: USB console is unavailable while in Host mode (port switches from Device to Host). Flashing: You must disable USB Host mode (or reboot) to flash new firmware via USB Not Persistent: The USB Host mode setting is runtime-only and resets on reboot ","description":"Using a USB keyboard to control GhostESP","permalink":"/latest/usb/keyboard/","title":"Keyboard Control"},{"content":"ESP32-S3 devices can use USB Host mode to accept input from a USB keyboard.\nRequirements\rESP32-S3 based device (Cardputer ADV, T-Deck, etc.) USB OTG adapter (Type-C to USB-A) USB keyboard CONFIG_USE_USB_KEYBOARD enabled in build config Enabling USB Host Mode\rUSB Host mode can be enabled in two ways:\nVia Settings Menu\rNavigate to Settings → System \u0026amp; Hardware Find USB Host Mode Toggle to On Via Command\rusbkbd on To disable:\nusbkbd off To check status:\nusbkbd status Keyboard Controls\rOnce enabled, the following keys control navigation:\nKey Action ↑ Arrow Navigate up ↓ Arrow Navigate down ← Arrow Back / Left → Arrow Right Enter Select ESC Back / Exit All other keys work as normal keyboard input for text fields.\nRemote Keyboard\rWhen two GhostESP devices are connected via Dual Comm, keyboard events are transmitted between them. This allows one device with a USB keyboard to control another device remotely.\nImportant Notes\rCDC Console: USB console is unavailable while in Host mode (port switches from Device to Host). Flashing: You must disable USB Host mode (or reboot) to flash new firmware via USB Not Persistent: The USB Host mode setting is runtime-only and resets on reboot ","description":"Using a USB keyboard to control GhostESP","permalink":"/v1.9/usb/keyboard/","title":"Keyboard Control"},{"content":"\rBefore you start\rHardware: Board with IR RX support (see hardware requirements). SD card: Inserted and mounted so GhostESP can save .ir files under /mnt/ghostesp/infrared/. Easy Learn: Optional assistant that suggests button names. Toggle via settings. Learn a remote or button\rOpen Infrared and choose Learn Remote or Learn Button to append to an existing remote.\nAlign the source remote with the IR receiver window, hold it steady within a few centimeters, then press the button once.\nConfirm the button name. Easy Learn provides a suggested label during learning, otherwise use the on-screen keyboard.\nWatch the preview popup for carrier frequency, protocol name, and decoded address/command details. Cancel and retry if you recieve a raw decode on a known non-raw signal.\nConfirm to save. GhostESP will create a new .ir file for fresh remotes or append the button to the currently open file automatically.\nStorage layout\rNew remotes are written to /mnt/ghostesp/infrared/remotes/\u0026lt;name\u0026gt;.ir. Adding to an existing remote appends another named button block inside the same .ir file. Tips\rKeep the remote within a few centimeters of the receiver and avoid direct sunlight. If learning fails, exit and re-open the Infrared learning popup to try to reinitialize the RMT RX channel. CLI Support\rYou can learn signals via the command line using ir learn.\n# Learn a signal and auto-save to a new file under /mnt/ghostesp/infrared/remotes ir learn # Learn and append to a specific file ir learn /mnt/ghostesp/infrared/remotes/my_remote.ir Without a path, GhostESP generates a new .ir file name based on the decoded protocol/address/command (or a RAW timestamp) in /mnt/ghostesp/infrared/remotes/. With a path, the learned signal is appended to the given .ir file. Manual File Creation\rYou can manually create .ir files if you know the protocol details. Save them as text files with the .ir extension in /mnt/ghostesp/infrared/remotes/.\nExample .ir file content:\nFiletype: IR signals file Version: 1 name: Power type: parsed protocol: NEC address: 00 FF command: 00 FF ","description":"Capture IR buttons and remotes with GhostESP","permalink":"/latest/infrared/learning/","title":"Learning Signals"},{"content":"\rBefore you start\rHardware: Use a board with IR RX support (see hardware requirements). SD card: Inserted and mounted so GhostESP can save .ir files under /ghostesp/infrared/. Easy Learn: Optional assistant that suggests button names; toggle it via infrared_easy in the command line config or the settings menu. Learn a remote or button\rOpen the Infrared view from the main menu and choose Learn Remote for a new file or Learn Button inside a saved remote to append a new signal to an existing remote.\nAlign the source remote with the IR receiver window, hold it steady within a few centimeters, then press the button once.\nConfirm the button name. Easy Learn provides a suggested label during learning, otherwise use the on-screen keyboard.\nWatch the preview popup for carrier frequency, protocol name, and decoded address/command details. Cancel and retry if you recieve a raw decode on a known non-raw signal.\nConfirm to save. GhostESP will create a new .ir file for fresh remotes or append the button to the currently open file automatically.\nStorage layout\rNew remotes are written to /ghostesp/infrared/remotes/\u0026lt;name\u0026gt;.ir. Adding to an existing remote appends another named button block inside the same .ir file. Tips\rKeep the remote within a few centimeters of the receiver and avoid direct sunlight. If learning fails, exit and re-open the Infrared learning popup to try to reinitialize the RMT RX channel. ","description":"Capture IR buttons and remotes with GhostESP","permalink":"/v1.8.1/infrared/learning/","title":"Learning Signals"},{"content":"\rBefore you start\rHardware: Use a board with IR RX support (see hardware requirements). SD card: Inserted and mounted so GhostESP can save .ir files under /ghostesp/infrared/. Easy Learn: Optional assistant that suggests button names; toggle it via infrared_easy in the command line config or the settings menu. Learn a remote or button\rOpen the Infrared view from the main menu and choose Learn Remote for a new file or Learn Button inside a saved remote to append a new signal to an existing remote.\nAlign the source remote with the IR receiver window, hold it steady within a few centimeters, then press the button once.\nConfirm the button name. Easy Learn provides a suggested label during learning, otherwise use the on-screen keyboard.\nWatch the preview popup for carrier frequency, protocol name, and decoded address/command details. Cancel and retry if you recieve a raw decode on a known non-raw signal.\nConfirm to save. GhostESP will create a new .ir file for fresh remotes or append the button to the currently open file automatically.\nStorage layout\rNew remotes are written to /ghostesp/infrared/remotes/\u0026lt;name\u0026gt;.ir. Adding to an existing remote appends another named button block inside the same .ir file. Tips\rKeep the remote within a few centimeters of the receiver and avoid direct sunlight. If learning fails, exit and re-open the Infrared learning popup to try to reinitialize the RMT RX channel. ","description":"Capture IR buttons and remotes with GhostESP","permalink":"/v1.8/infrared/learning/","title":"Learning Signals"},{"content":"\rBefore you start\rHardware: Board with IR RX support (see hardware requirements). SD card: Inserted and mounted so GhostESP can save .ir files under /mnt/ghostesp/infrared/. Easy Learn: Optional assistant that suggests button names. Toggle via settings. Learn a remote or button\rOpen Infrared and choose Learn Remote or Learn Button to append to an existing remote.\nAlign the source remote with the IR receiver window, hold it steady within a few centimeters, then press the button once.\nConfirm the button name. Easy Learn provides a suggested label during learning, otherwise use the on-screen keyboard.\nWatch the preview popup for carrier frequency, protocol name, and decoded address/command details. Cancel and retry if you recieve a raw decode on a known non-raw signal.\nConfirm to save. GhostESP will create a new .ir file for fresh remotes or append the button to the currently open file automatically.\nStorage layout\rNew remotes are written to /mnt/ghostesp/infrared/remotes/\u0026lt;name\u0026gt;.ir. Adding to an existing remote appends another named button block inside the same .ir file. Tips\rKeep the remote within a few centimeters of the receiver and avoid direct sunlight. If learning fails, exit and re-open the Infrared learning popup to try to reinitialize the RMT RX channel. CLI Support\rYou can learn signals via the command line using ir learn.\n# Learn a signal and auto-save to a new file under /mnt/ghostesp/infrared/remotes ir learn # Learn and append to a specific file ir learn /mnt/ghostesp/infrared/remotes/my_remote.ir Without a path, GhostESP generates a new .ir file name based on the decoded protocol/address/command (or a RAW timestamp) in /mnt/ghostesp/infrared/remotes/. With a path, the learned signal is appended to the given .ir file. Manual File Creation\rYou can manually create .ir files if you know the protocol details. Save them as text files with the .ir extension in /mnt/ghostesp/infrared/remotes/.\nExample .ir file content:\nFiletype: IR signals file Version: 1 name: Power type: parsed protocol: NEC address: 00 FF command: 00 FF ","description":"Capture IR buttons and remotes with GhostESP","permalink":"/v1.9/infrared/learning/","title":"Learning Signals"},{"content":"Network fingerprinting discovers and identifies devices on your Ethernet network. GhostESP scans for common protocols to build a device profile.\nOverview\rWhen you run a fingerprint scan, GhostESP listens for network traffic and service announcements to identify devices. It looks for:\nmDNS — Service announcements (printers, speakers, etc.) NBNS (NetBIOS Name Service) — Windows device name broadcasts SSDP — UPnP device announcements The scan collects device names, IP addresses, detected device types (Chromecast, Roku, Apple, Samsung, etc.), and service information.\nPrerequisites\rA Banshee device with Ethernet connected Access to the device via GhostLink display menu or terminal A network with active devices How to Use\rVia Terminal\rRun the fingerprint scan from the terminal:\nethfp The scan will run for approximately 3 seconds and display discovered devices with their details:\nIP Address: 192.168.1.100\rDevice Name: Living-Room-TV\rDevice Type: Samsung\rService: upnp Via GhostLink Display Menu\rConnect to the Banshee device via GhostLink Navigate to Ethernet menu Select Fingerprint Scan Wait for the scan to complete (approximately 3 seconds) View the list of discovered devices Understanding Results\rEach discovered device shows:\nIP Address — The device\u0026rsquo;s IP on the network Device Name — Hostname or friendly name if available Device Type — Detected manufacturer or device category (Samsung, Apple, Google, etc.) Service Type — Protocol used for detection (mDNS, SSDP, NBNS) OS Info — Operating system or device model if detected Troubleshooting\rNo devices found: Ensure devices are powered on and on the same network. Some devices don\u0026rsquo;t broadcast. Incomplete information: Not all devices provide full details. GhostESP shows what it can detect from available network traffic. Timeout: The scan runs for 3 seconds. If you need more time, run the scan again. ","description":"Scan and identify devices on your Ethernet network.","permalink":"/latest/ethernet/fingerprinting/","title":"Network Fingerprinting"},{"content":"Network fingerprinting discovers and identifies devices on your Ethernet network. GhostESP scans for common protocols to build a device profile.\nOverview\rWhen you run a fingerprint scan, GhostESP listens for network traffic and service announcements to identify devices. It looks for:\nmDNS — Service announcements (printers, speakers, etc.) NBNS (NetBIOS Name Service) — Windows device name broadcasts SSDP — UPnP device announcements The scan collects device names, IP addresses, detected device types (Chromecast, Roku, Apple, Samsung, etc.), and service information.\nPrerequisites\rA Banshee device with Ethernet connected Access to the device via GhostLink display menu or terminal A network with active devices How to Use\rVia Terminal\rRun the fingerprint scan from the terminal:\nethfp The scan will run for approximately 3 seconds and display discovered devices with their details:\nIP Address: 192.168.1.100\rDevice Name: Living-Room-TV\rDevice Type: Samsung\rService: upnp Via GhostLink Display Menu\rConnect to the Banshee device via GhostLink Navigate to Ethernet menu Select Fingerprint Scan Wait for the scan to complete (approximately 3 seconds) View the list of discovered devices Understanding Results\rEach discovered device shows:\nIP Address — The device\u0026rsquo;s IP on the network Device Name — Hostname or friendly name if available Device Type — Detected manufacturer or device category (Samsung, Apple, Google, etc.) Service Type — Protocol used for detection (mDNS, SSDP, NBNS) OS Info — Operating system or device model if detected Troubleshooting\rNo devices found: Ensure devices are powered on and on the same network. Some devices don\u0026rsquo;t broadcast. Incomplete information: Not all devices provide full details. GhostESP shows what it can detect from available network traffic. Timeout: The scan runs for 3 seconds. If you need more time, run the scan again. ","description":"Scan and identify devices on your Ethernet network.","permalink":"/v1.9/ethernet/fingerprinting/","title":"Network Fingerprinting"},{"content":"Discover nearby BLE devices and gather information about them.\nWi-Fi impact: Starting any BLE scan temporarily suspends the GhostNet access point. Wi-Fi services resume automatically once you stop scanning (for example by running stop or pressing Back in the UI).\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Scanning for devices\rOn-device UI\rOpen Menu → Bluetooth. Choose a scanning mode from the options below. The device will start scanning. Leave it running until you have enough data. Back out of the terminal view to stop scanning. The device will show a summary of discovered devices. Command line\rOpen the GhostESP terminal. Run blescan [OPTION] where the option is one of the modes below (for example, blescan -f). The device will start scanning. Run blescan -s when you\u0026rsquo;re done. The device will stop scanning and show a summary. Scanning modes\rFind Flippers\rUI: Menu → Bluetooth → Find Flippers CLI: blescan -f Scans for nearby Flipper Zero devices and displays their names and signal strength. After scanning, use Select Flipper to track a specific device\u0026rsquo;s RSSI (signal strength) in real time as you move around. AirTag Scanner\rUI: Menu → Bluetooth → Start AirTag Scanner CLI: blescan -a Scans for Apple AirTags and other Find My devices using active scanning to find more devices. Allows duplicate advertisements to be reported for better tracking. While scanning, RSSI for already discovered AirTags is logged every few seconds to help you see proximity changes over time. Use List AirTags to see discovered devices, or Select AirTag to prepare for spoofing. BLE Skimmer Detection\rUI: Menu → Bluetooth → BLE Skimmer Detect CLI: capture -skimmer Scans for payment terminal skimmers that use BLE to exfiltrate card data. Logs detected skimmers to a PCAP file for analysis. GATT Service Enumeration\rUI: Menu → Bluetooth → GATT Scan → Start GATT Scan CLI: blescan -g Connect to BLE devices and discover what services they offer (e.g., heart rate, battery level, custom services). Track devices by signal strength to physically locate them. See the dedicated GATT Discovery page for a full walkthrough, command reference, and service UUID tables.\nListing and selecting devices\rAfter scanning, you can interact with discovered devices:\nList discovered devices\rFlippers: Menu → Bluetooth → Flipper → List Flippers or CLI: listflippers AirTags: Menu → Bluetooth → AirTag → List AirTags or CLI: listairtags GATT Devices: Menu → Bluetooth → GATT Scan → List GATT Devices or CLI: listgatt Select a device for further action\rFlipper: Menu → Bluetooth → Flipper → Select Flipper Once selected, the device will continuously track and display the Flipper\u0026rsquo;s RSSI (signal strength). Use this to locate the Flipper by moving around and watching the signal strength change. AirTag: Menu → Bluetooth → AirTag → Select AirTag (prepares for spoofing) GATT Device: Menu → Bluetooth → GATT Scan → Select GATT Device Once selected, use Enumerate Services to connect and discover the device\u0026rsquo;s GATT services. Use Track Device to locate it using real-time signal strength updates. Notes\rBLE scanning is not available on ESP32-S2 devices. Scanning modes are mutually exclusive; starting a new scan will stop the previous one. Signal strength (RSSI) is displayed in dBm; higher values (closer to 0) indicate stronger signals. Some devices may not respond to all scanning modes depending on their BLE implementation. Troubleshooting\rNo devices found: Move closer to BLE devices and try scanning again. Scanning stops immediately: Check that your device has Bluetooth enabled. Remember that the AP pauses during scans—wait a moment after stopping for Wi-Fi to return. Device not responding: Some devices may be in sleep mode or have BLE disabled. Try scanning again or move closer. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Discover and analyze nearby Bluetooth Low Energy devices.","permalink":"/latest/ble/scanning/","title":"Scanning"},{"content":"\rPrerequisites\rGhostESP firmware compiled with NFC support and a connected PN532 module or chameleon ultra. (Optional) SD card if you plan to save tag dumps. Steps\rOpen Scan. Pick Scan in the NFC menu; the popup shows “Scanning NFC\u0026hellip;” while the PN532 spins up.\nBring in a tag. Place it flat on the antenna. The UID, ATQA, and SAK appear immediately; Classic cards flip the title to “Bruteforcing keys… 0%”.\nHold steady. Keep the tag still while reads finish. If the tag slips away, the UI pauses and prompts you to return it before resuming.\nCheck output. Review the summary, toggle More for more info, and use Save to write the dump once “NFC Tag” is displayed.\nAuto-Pause Detection\rThe scanner polls for the tag continuously. If it leaves the field mid-scan, the UI enters a paused state, disables brute-force attempts, and resumes automatically once the same UID is back in range. MIFARE Classic Flow\rDictionary attack order: GhostESP tries user keys, then common keys, then the Flipper dictionary.\nCaching behavior. Once a sector unlocks, its blocks and both Key A/Key B values are cached. The title shifts to “Reading sectors\u0026hellip;” during the copy. Successful keys are appended back to the user dictionary on the SD card.\nMagic backdoor tags. If the card supports the classic backdoor sequence, GhostESP logs the detection and can skip sector authentication, pulling data directly.\nSkip option: Tap Skip to bypass dictionaries when you only need public sectors.\nAfter the scan. The more summary lists recovered sectors and keys as well as any detected NDEF data.\nNTAG / Ultralight Flow\rImmediate reads. NTAG21x and Ultralight tags are readable without keys, so the title stays “Scanning NFC\u0026hellip;” until the UID appears, then flips to “NFC Tag”.\nPage sweep. The reader streams all user pages, signature bytes, and counters if present. Progress is shown via the page counter in the popup body.\nNDEF parsing. Detected TLVs are decoded into text, URI, or custom payload summaries. Tap More to see the raw TLV breakdown.\nCaching and saves. All pages remain in RAM for the current session; saving writes the entire image to /mnt/ghostesp/nfc/\u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc for later writes.\nVerification. Re-scan immediately after to confirm the data matches or to check the signature for authenticity.\nChameleon Ultra Scanning\rConnect first. Complete the Chameleon Ultra setup so GhostESP is paired over BLE. Switch to reader. Run chameleon reader in the CLI; the terminal confirms the device is ready to scan. Start HF scans. Use chameleon scanhf while holding the tag near the Chameleon Ultra antenna. The CLI mirrors the familiar popup summaries, including brute-force percentages for MIFARE Classic cards. Start LF scans. Use chameleon scanlf (or scanlfall to sweep profiles) for low-frequency tags; results appear in the CLI and the on-device terminal view. Reuse cached data. Once a scan finishes, you can proceed directly to the save flow without rescanning on the PN532. Verify\rConfirm the tag type and UID shown on-screen match the physical tag you scanned. For Mifare Classic cards, check the listed sectors to see how many keys were recovered. If you saved the capture, verify a new \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc file was created under /mnt/ghostesp/nfc/. Troubleshooting\rNo change from “Scanning NFC\u0026hellip;”. Re-seat the tag and verify PN532 wiring; try another tag to rule out hardware issues.\nStuck on “Bruteforcing keys… 0%”. GhostESP is testing dictionaries. Use the Skip button if you only need publicly readable blocks.\nUID reads but data is empty. The card may be write-protected or needs a key not present in your dictionaries. You can add it to your user dictionary in mnt/ghostesp/nfc/mfc_user_keys.nfc and then try rescanning.\nFAQ\rWhich keys does GhostESP try? Your User Keys list runs first, followed by bundled common keys and then the Flipper Zero Mifare Classic dictionary.\nWhat do the sector labels mean? Mifare Classic memory is split into numbered sectors, each protected by Key A and Key B. A listed sector means at least one key unlocked it during the scan.\nCan I scan other tag families? NTAG21x and Ultralight tags read without needing a brute force; they show their NDEF TLVs immediately after the UID appears.\n","description":"Read GhostESP-compatible NFC tags and understand the on-screen feedback","permalink":"/latest/nfc/scanning/","title":"Scanning"},{"content":"Discover nearby BLE devices and gather information about them.\nWi-Fi impact: Starting any BLE scan temporarily suspends the GhostNet access point. Wi-Fi services resume automatically once you stop scanning (for example by running stop or pressing Back in the UI).\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Scanning for devices\rOn-device UI\rOpen Menu → Bluetooth. Choose a scanning mode from the options below. The device will start scanning. Leave it running until you have enough data. Back out of the terminal view to stop scanning. The device will show a summary of discovered devices. Command line\rOpen the GhostESP terminal. Run blescan [OPTION] where the option is one of the modes below (for example, blescan -f). The device will start scanning. Run blescan -s when you\u0026rsquo;re done. The device will stop scanning and show a summary. Scanning modes\rFind Flippers\rUI: Menu → Bluetooth → Find Flippers CLI: blescan -f Scans for nearby Flipper Zero devices and displays their names and signal strength. After scanning, use Select Flipper to track a specific device\u0026rsquo;s RSSI (signal strength) in real time as you move around. AirTag Scanner\rUI: Menu → Bluetooth → Start AirTag Scanner CLI: blescan -a Scans for Apple AirTags and other Find My devices using active scanning with aggressive parameters to maximize detection. Allows duplicate advertisements to be reported for better tracking. Use List AirTags to see discovered devices, or Select AirTag to prepare for spoofing. BLE Skimmer Detection\rUI: Menu → Bluetooth → BLE Skimmer Detect CLI: capture -skimmer Scans for payment terminal skimmers that use BLE to exfiltrate card data. Logs detected skimmers to a PCAP file for analysis. Listing and selecting devices\rAfter scanning, you can interact with discovered devices:\nList discovered devices\rFlippers: Menu → Bluetooth → List Flippers or CLI: listflippers AirTags: Menu → Bluetooth → List AirTags or CLI: list -airtags Select a device for further action\rFlipper: Menu → Bluetooth → Select Flipper Once selected, the device will continuously track and display the Flipper\u0026rsquo;s RSSI (signal strength). Use this to locate the Flipper by moving around and watching the signal strength change. AirTag: Menu → Bluetooth → Select AirTag (prepares for spoofing) Notes\rBLE scanning is not available on ESP32-S2 devices. Scanning modes are mutually exclusive; starting a new scan will stop the previous one. Signal strength (RSSI) is displayed in dBm; higher values (closer to 0) indicate stronger signals. Some devices may not respond to all scanning modes depending on their BLE implementation. Troubleshooting\rNo devices found: Move closer to BLE devices and try scanning again. Scanning stops immediately: Check that your device has Bluetooth enabled. Remember that the AP pauses during scans—wait a moment after stopping for Wi-Fi to return. Device not responding: Some devices may be in sleep mode or have BLE disabled. Try scanning again or move closer. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Discover and analyze nearby Bluetooth Low Energy devices.","permalink":"/v1.8.1/ble/scanning/","title":"Scanning"},{"content":"\rPrerequisites\rGhostESP firmware compiled with NFC support and a connected PN532 module or chameleon ultra. (Optional) SD card if you plan to save tag dumps. Steps\rOpen Scan. Pick Scan in the NFC menu; the popup shows “Scanning NFC\u0026hellip;” while the PN532 spins up.\nBring in a tag. Place it flat on the antenna. The UID, ATQA, and SAK appear immediately; Classic cards flip the title to “Bruteforcing keys… 0%”.\nHold steady. Keep the tag still while reads finish. If the tag slips away, the UI pauses and prompts you to return it before resuming.\nCheck output. Review the summary, toggle More for more info, and use Save to write the dump once “NFC Tag” is displayed.\nAuto-Pause Detection\rThe scanner polls for the tag continuously. If it leaves the field mid-scan, the UI enters a paused state, disables brute-force attempts, and resumes automatically once the same UID is back in range. MIFARE Classic Flow\rDictionary attack order. GhostESP authenticates each sector using keys from /mnt/ghostesp/nfc/mfc_user_keys.nfc, then bundled common keys, then the compiled Flipper dictionary. The title bar remains on “Bruteforcing keys…” while this progresses.\nCaching behavior. Once a sector unlocks, its blocks and both Key A/Key B values are cached. The title shifts to “Reading sectors\u0026hellip;” during the copy. Successful keys are appended back to the user dictionary on the SD card.\nMagic backdoor tags. If the card supports the classic backdoor sequence, GhostESP logs the detection and can skip sector authentication, pulling data directly.\nSkip option. Tap Skip to bypass the user and dictionary lists when you only need publicly readable sectors (sector 0).\nAfter the scan. The more summary lists recovered sectors and keys as well as any detected NDEF data.\nNTAG / Ultralight Flow\rImmediate reads. NTAG21x and Ultralight tags are readable without keys, so the title stays “Scanning NFC\u0026hellip;” until the UID appears, then flips to “NFC Tag”.\nPage sweep. The reader streams all user pages, signature bytes, and counters if present. Progress is shown via the page counter in the popup body.\nNDEF parsing. Detected TLVs are decoded into text, URI, or custom payload summaries. Tap More to see the raw TLV breakdown.\nCaching and saves. All pages remain in RAM for the current session; saving writes the entire image to /mnt/ghostesp/nfc/\u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc for later writes.\nVerification. Re-scan immediately after to confirm the data matches or to check the signature for authenticity.\nChameleon Ultra Scanning\rConnect first. Complete the Chameleon Ultra setup so GhostESP is paired over BLE. Switch to reader. Run chameleon reader in the CLI; the terminal confirms the device is ready to scan. Start HF scans. Use chameleon scanhf while holding the tag near the Chameleon Ultra antenna. The CLI mirrors the familiar popup summaries, including brute-force percentages for MIFARE Classic cards. Start LF scans. Use chameleon scanlf (or scanlfall to sweep profiles) for low-frequency tags; results appear in the CLI and the on-device terminal view. Reuse cached data. Once a scan finishes, you can proceed directly to the save flow without rescanning on the PN532. Verify\rConfirm the tag type and UID shown on-screen match the physical tag you scanned. For Mifare Classic cards, check the listed sectors to see how many keys were recovered. If you saved the capture, verify a new \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc file was created under /mnt/ghostesp/nfc/. Troubleshooting\rNo change from “Scanning NFC\u0026hellip;”. Re-seat the tag and verify PN532 wiring; try another tag to rule out hardware issues.\nStuck on “Bruteforcing keys… 0%”. GhostESP is testing dictionaries. Use the Skip button if you only need publicly readable blocks.\nUID reads but data is empty. The card may be write-protected or needs a key not present in your dictionaries. You can add it to your user dictionary in mnt/ghostesp/nfc/mfc_user_keys.nfc and then try rescanning.\nFAQ\rWhich keys does GhostESP try? Your User Keys list runs first, followed by bundled common keys and then the Flipper Zero Mifare Classic dictionary.\nWhat do the sector labels mean? Mifare Classic memory is split into numbered sectors, each protected by Key A and Key B. A listed sector means at least one key unlocked it during the scan.\nCan I scan other tag families? NTAG21x and Ultralight tags read without needing a brute force; they show their NDEF TLVs immediately after the UID appears.\n","description":"Read GhostESP-compatible NFC tags and understand the on-screen feedback","permalink":"/v1.8.1/nfc/scanning/","title":"Scanning"},{"content":"Discover nearby BLE devices and gather information about them.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Scanning for devices\rOn-device UI\rOpen Menu → Bluetooth. Choose a scanning mode from the options below. The device will start scanning. Leave it running until you have enough data. Back out of the terminal view to stop scanning. The device will show a summary of discovered devices. Command line\rOpen the GhostESP terminal. Run blescan [OPTION] where the option is one of the modes below (for example, blescan -f). The device will start scanning. Run blescan -s when you\u0026rsquo;re done. The device will stop scanning and show a summary. Scanning modes\rFind Flippers\rUI: Menu → Bluetooth → Find Flippers CLI: blescan -f Scans for nearby Flipper Zero devices and displays their names and signal strength. After scanning, use Select Flipper to track a specific device\u0026rsquo;s RSSI (signal strength) in real time as you move around. AirTag Scanner\rUI: Menu → Bluetooth → Start AirTag Scanner CLI: blescan -a Scans for Apple AirTags and other Find My devices using active scanning with aggressive parameters to maximize detection. Allows duplicate advertisements to be reported for better tracking. Use List AirTags to see discovered devices, or Select AirTag to prepare for spoofing. BLE Skimmer Detection\rUI: Menu → Bluetooth → BLE Skimmer Detect CLI: capture -skimmer Scans for payment terminal skimmers that use BLE to exfiltrate card data. Logs detected skimmers to a PCAP file for analysis. Listing and selecting devices\rAfter scanning, you can interact with discovered devices:\nList discovered devices\rFlippers: Menu → Bluetooth → List Flippers or CLI: listflippers AirTags: Menu → Bluetooth → List AirTags or CLI: list -airtags Select a device for further action\rFlipper: Menu → Bluetooth → Select Flipper Once selected, the device will continuously track and display the Flipper\u0026rsquo;s RSSI (signal strength). Use this to locate the Flipper by moving around and watching the signal strength change. AirTag: Menu → Bluetooth → Select AirTag (prepares for spoofing) Notes\rBLE scanning is not available on ESP32-S2 devices. Scanning modes are mutually exclusive; starting a new scan will stop the previous one. Signal strength (RSSI) is displayed in dBm; higher values (closer to 0) indicate stronger signals. Some devices may not respond to all scanning modes depending on their BLE implementation. Troubleshooting\rNo devices found: Move closer to BLE devices and try scanning again. Scanning stops immediately: Check that your device has Bluetooth enabled, try turning the GhostNet AP off and rebooting to conserve memory. Device not responding: Some devices may be in sleep mode or have BLE disabled. Try scanning again or move closer. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Discover and analyze nearby Bluetooth Low Energy devices.","permalink":"/v1.8/ble/scanning/","title":"Scanning"},{"content":"\rPrerequisites\rGhostESP firmware compiled with NFC support and a connected PN532 module or chameleon ultra. (Optional) SD card if you plan to save tag dumps. Steps\rOpen Scan. Pick Scan in the NFC menu; the popup shows “Scanning NFC\u0026hellip;” while the PN532 spins up.\nBring in a tag. Place it flat on the antenna. The UID, ATQA, and SAK appear immediately; Classic cards flip the title to “Bruteforcing keys… 0%”.\nHold steady. Keep the tag still while reads finish. If the tag slips away, the UI pauses and prompts you to return it before resuming.\nCheck output. Review the summary, toggle More for more info, and use Save to write the dump once “NFC Tag” is displayed.\nAuto-Pause Detection\rThe scanner polls for the tag continuously. If it leaves the field mid-scan, the UI enters a paused state, disables brute-force attempts, and resumes automatically once the same UID is back in range. MIFARE Classic Flow\rDictionary attack order. GhostESP authenticates each sector using keys from /mnt/ghostesp/nfc/mfc_user_keys.nfc, then bundled common keys, then the compiled Flipper dictionary. The title bar remains on “Bruteforcing keys…” while this progresses.\nCaching behavior. Once a sector unlocks, its blocks and both Key A/Key B values are cached. The title shifts to “Reading sectors\u0026hellip;” during the copy. Successful keys are appended back to the user dictionary on the SD card.\nMagic backdoor tags. If the card supports the classic backdoor sequence, GhostESP logs the detection and can skip sector authentication, pulling data directly.\nSkip option. Tap Skip to bypass the user and dictionary lists when you only need publicly readable sectors (sector 0).\nAfter the scan. The more summary lists recovered sectors and keys as well as any detected NDEF data.\nNTAG / Ultralight Flow\rImmediate reads. NTAG21x and Ultralight tags are readable without keys, so the title stays “Scanning NFC\u0026hellip;” until the UID appears, then flips to “NFC Tag”.\nPage sweep. The reader streams all user pages, signature bytes, and counters if present. Progress is shown via the page counter in the popup body.\nNDEF parsing. Detected TLVs are decoded into text, URI, or custom payload summaries. Tap More to see the raw TLV breakdown.\nCaching and saves. All pages remain in RAM for the current session; saving writes the entire image to /mnt/ghostesp/nfc/\u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc for later writes.\nVerification. Re-scan immediately after to confirm the data matches or to check the signature for authenticity.\nChameleon Ultra Scanning\rConnect first. Complete the Chameleon Ultra setup so GhostESP is paired over BLE. Switch to reader. Run chameleon reader in the CLI; the terminal confirms the device is ready to scan. Start HF scans. Use chameleon scanhf while holding the tag near the Chameleon Ultra antenna. The CLI mirrors the familiar popup summaries, including brute-force percentages for MIFARE Classic cards. Start LF scans. Use chameleon scanlf (or scanlfall to sweep profiles) for low-frequency tags; results appear in the CLI and the on-device terminal view. Reuse cached data. Once a scan finishes, you can proceed directly to the save flow without rescanning on the PN532. Verify\rConfirm the tag type and UID shown on-screen match the physical tag you scanned. For Mifare Classic cards, check the listed sectors to see how many keys were recovered. If you saved the capture, verify a new \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc file was created under /mnt/ghostesp/nfc/. Troubleshooting\rNo change from “Scanning NFC\u0026hellip;”. Re-seat the tag and verify PN532 wiring; try another tag to rule out hardware issues.\nStuck on “Bruteforcing keys… 0%”. GhostESP is testing dictionaries. Use the Skip button if you only need publicly readable blocks.\nUID reads but data is empty. The card may be write-protected or needs a key not present in your dictionaries. You can add it to your user dictionary in mnt/ghostesp/nfc/mfc_user_keys.nfc and then try rescanning.\nFAQ\rWhich keys does GhostESP try? Your User Keys list runs first, followed by bundled common keys and then the Flipper Zero Mifare Classic dictionary.\nWhat do the sector labels mean? Mifare Classic memory is split into numbered sectors, each protected by Key A and Key B. A listed sector means at least one key unlocked it during the scan.\nCan I scan other tag families? NTAG21x and Ultralight tags read without needing a brute force; they show their NDEF TLVs immediately after the UID appears.\n","description":"Read GhostESP-compatible NFC tags and understand the on-screen feedback","permalink":"/v1.8/nfc/scanning/","title":"Scanning"},{"content":"Discover nearby BLE devices and gather information about them.\nWi-Fi impact: Starting any BLE scan temporarily suspends the GhostNet access point. Wi-Fi services resume automatically once you stop scanning (for example by running stop or pressing Back in the UI).\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Scanning for devices\rOn-device UI\rOpen Menu → Bluetooth. Choose a scanning mode from the options below. The device will start scanning. Leave it running until you have enough data. Back out of the terminal view to stop scanning. The device will show a summary of discovered devices. Command line\rOpen the GhostESP terminal. Run blescan [OPTION] where the option is one of the modes below (for example, blescan -f). The device will start scanning. Run blescan -s when you\u0026rsquo;re done. The device will stop scanning and show a summary. Scanning modes\rFind Flippers\rUI: Menu → Bluetooth → Find Flippers CLI: blescan -f Scans for nearby Flipper Zero devices and displays their names and signal strength. After scanning, use Select Flipper to track a specific device\u0026rsquo;s RSSI (signal strength) in real time as you move around. AirTag Scanner\rUI: Menu → Bluetooth → Start AirTag Scanner CLI: blescan -a Scans for Apple AirTags and other Find My devices using active scanning to find more devices. Allows duplicate advertisements to be reported for better tracking. While scanning, RSSI for already discovered AirTags is logged every few seconds to help you see proximity changes over time. Use List AirTags to see discovered devices, or Select AirTag to prepare for spoofing. BLE Skimmer Detection\rUI: Menu → Bluetooth → BLE Skimmer Detect CLI: capture -skimmer Scans for payment terminal skimmers that use BLE to exfiltrate card data. Logs detected skimmers to a PCAP file for analysis. GATT Service Enumeration\rUI: Menu → Bluetooth → GATT Scan → Start GATT Scan CLI: blescan -g Connect to BLE devices and discover what services they offer (e.g., heart rate, battery level, custom services). Track devices by signal strength to physically locate them. See the dedicated GATT Discovery page for a full walkthrough, command reference, and service UUID tables.\nListing and selecting devices\rAfter scanning, you can interact with discovered devices:\nList discovered devices\rFlippers: Menu → Bluetooth → Flipper → List Flippers or CLI: listflippers AirTags: Menu → Bluetooth → AirTag → List AirTags or CLI: listairtags GATT Devices: Menu → Bluetooth → GATT Scan → List GATT Devices or CLI: listgatt Select a device for further action\rFlipper: Menu → Bluetooth → Flipper → Select Flipper Once selected, the device will continuously track and display the Flipper\u0026rsquo;s RSSI (signal strength). Use this to locate the Flipper by moving around and watching the signal strength change. AirTag: Menu → Bluetooth → AirTag → Select AirTag (prepares for spoofing) GATT Device: Menu → Bluetooth → GATT Scan → Select GATT Device Once selected, use Enumerate Services to connect and discover the device\u0026rsquo;s GATT services. Use Track Device to locate it using real-time signal strength updates. Notes\rBLE scanning is not available on ESP32-S2 devices. Scanning modes are mutually exclusive; starting a new scan will stop the previous one. Signal strength (RSSI) is displayed in dBm; higher values (closer to 0) indicate stronger signals. Some devices may not respond to all scanning modes depending on their BLE implementation. Troubleshooting\rNo devices found: Move closer to BLE devices and try scanning again. Scanning stops immediately: Check that your device has Bluetooth enabled. Remember that the AP pauses during scans—wait a moment after stopping for Wi-Fi to return. Device not responding: Some devices may be in sleep mode or have BLE disabled. Try scanning again or move closer. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Discover and analyze nearby Bluetooth Low Energy devices.","permalink":"/v1.9/ble/scanning/","title":"Scanning"},{"content":"\rPrerequisites\rGhostESP firmware compiled with NFC support and a connected PN532 module or chameleon ultra. (Optional) SD card if you plan to save tag dumps. Steps\rOpen Scan. Pick Scan in the NFC menu; the popup shows “Scanning NFC\u0026hellip;” while the PN532 spins up.\nBring in a tag. Place it flat on the antenna. The UID, ATQA, and SAK appear immediately; Classic cards flip the title to “Bruteforcing keys… 0%”.\nHold steady. Keep the tag still while reads finish. If the tag slips away, the UI pauses and prompts you to return it before resuming.\nCheck output. Review the summary, toggle More for more info, and use Save to write the dump once “NFC Tag” is displayed.\nAuto-Pause Detection\rThe scanner polls for the tag continuously. If it leaves the field mid-scan, the UI enters a paused state, disables brute-force attempts, and resumes automatically once the same UID is back in range. MIFARE Classic Flow\rDictionary attack order: GhostESP tries user keys, then common keys, then the Flipper dictionary.\nCaching behavior. Once a sector unlocks, its blocks and both Key A/Key B values are cached. The title shifts to “Reading sectors\u0026hellip;” during the copy. Successful keys are appended back to the user dictionary on the SD card.\nMagic backdoor tags. If the card supports the classic backdoor sequence, GhostESP logs the detection and can skip sector authentication, pulling data directly.\nSkip option: Tap Skip to bypass dictionaries when you only need public sectors.\nAfter the scan. The more summary lists recovered sectors and keys as well as any detected NDEF data.\nNTAG / Ultralight Flow\rImmediate reads. NTAG21x and Ultralight tags are readable without keys, so the title stays “Scanning NFC\u0026hellip;” until the UID appears, then flips to “NFC Tag”.\nPage sweep. The reader streams all user pages, signature bytes, and counters if present. Progress is shown via the page counter in the popup body.\nNDEF parsing. Detected TLVs are decoded into text, URI, or custom payload summaries. Tap More to see the raw TLV breakdown.\nCaching and saves. All pages remain in RAM for the current session; saving writes the entire image to /mnt/ghostesp/nfc/\u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc for later writes.\nVerification. Re-scan immediately after to confirm the data matches or to check the signature for authenticity.\nChameleon Ultra Scanning\rConnect first. Complete the Chameleon Ultra setup so GhostESP is paired over BLE. Switch to reader. Run chameleon reader in the CLI; the terminal confirms the device is ready to scan. Start HF scans. Use chameleon scanhf while holding the tag near the Chameleon Ultra antenna. The CLI mirrors the familiar popup summaries, including brute-force percentages for MIFARE Classic cards. Start LF scans. Use chameleon scanlf (or scanlfall to sweep profiles) for low-frequency tags; results appear in the CLI and the on-device terminal view. Reuse cached data. Once a scan finishes, you can proceed directly to the save flow without rescanning on the PN532. Verify\rConfirm the tag type and UID shown on-screen match the physical tag you scanned. For Mifare Classic cards, check the listed sectors to see how many keys were recovered. If you saved the capture, verify a new \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc file was created under /mnt/ghostesp/nfc/. Troubleshooting\rNo change from “Scanning NFC\u0026hellip;”. Re-seat the tag and verify PN532 wiring; try another tag to rule out hardware issues.\nStuck on “Bruteforcing keys… 0%”. GhostESP is testing dictionaries. Use the Skip button if you only need publicly readable blocks.\nUID reads but data is empty. The card may be write-protected or needs a key not present in your dictionaries. You can add it to your user dictionary in mnt/ghostesp/nfc/mfc_user_keys.nfc and then try rescanning.\nFAQ\rWhich keys does GhostESP try? Your User Keys list runs first, followed by bundled common keys and then the Flipper Zero Mifare Classic dictionary.\nWhat do the sector labels mean? Mifare Classic memory is split into numbered sectors, each protected by Key A and Key B. A listed sector means at least one key unlocked it during the scan.\nCan I scan other tag families? NTAG21x and Ultralight tags read without needing a brute force; they show their NDEF TLVs immediately after the UID appears.\n","description":"Read GhostESP-compatible NFC tags and understand the on-screen feedback","permalink":"/v1.9/nfc/scanning/","title":"Scanning"},{"content":"Discover nearby Wi-Fi networks and gather information about them. You can scan passively without connecting, or connect to a network and explore devices on it.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Finding nearby networks\rOn-device UI\rOpen Menu → WiFi → Scanning. You should see a menu with scan options. Choose Scan Access Points. The device will search for networks. Wait for the scan to finish and see a summary. Select List Access Points. You should see each network listed with its name, channel, signal strength, and device manufacturer. On-device UI — Optional features\rScan APs Live: Watch new networks appear in real time as they\u0026rsquo;re discovered. Channel Congestion: See how busy the wireless channels are in your area. Command line\rOpen the GhostESP terminal (serial connection or on-device terminal). Run scanap to start a scan. Wait for it to finish and show results. Run list -a to see the cached list of networks. Command line — Optional features\rRun scanap -live to watch networks appear as they\u0026rsquo;re discovered. Exploring a network\rOnce you connect to a network, you can discover devices and services on it.\nConnect to a network\rOpen Menu → WiFi → Connection → Connect to WiFi. Enter the network name and password when prompted. Wait for the connection to complete. The terminal will show status updates. To disconnect later, go to Menu → WiFi → Connection → Disconnect. Connect via command line\rRun connect \u0026quot;SSID\u0026quot; \u0026quot;password\u0026quot; (use quotes if the name or password has spaces). The terminal will show connection progress and confirm when connected. Run connect with no arguments to reconnect to the last network you used. Run disconnect to leave the network. Find devices on the network\rOpen Menu → WiFi → Scanning while connected. Choose Scan LAN Devices. You should see a list of devices and services on the network. Find devices via command line\rRun scanlocal to discover devices and services. You should see hostnames, service types, and ports. Run scanarp to find all active devices on the network. You should see IP addresses and device information. Check for open ports\rFrom the UI, select a device with Select LAN, then choose Scan Open Ports. You should see which ports are responding on that device. From the command line, run scanports \u0026lt;ip\u0026gt; to check a specific device. You should see open ports listed. Add all to check all ports, or start-end (like 20-1024) for a range. Run scanssh \u0026lt;ip\u0026gt; to specifically check if a device has SSH enabled. Full environment sweep\rScan all wireless activity at once and save results to your SD card.\nWhat it captures\rWiFi Access Points: Name, MAC, channel, frequency, signal strength, security type, cipher, 802.11 mode, WPS status WiFi Clients: MAC address and associated AP BLE Devices: Flippers, GATT devices, and raw BLE packets 802.15.4 Packets: Zigbee/Thread traffic (ESP32-C5 and C6 only) GPS Coordinates: Location data for each entry (if GPS module connected) Run a sweep from the UI\rOpen Menu → WiFi → Scanning → Sweep. The device will run through each scan phase automatically. Wait for all phases to complete. Progress is shown on screen. Find results in /ghostesp/sweeps/sweep_N.csv on your SD card. Run a sweep from command line\rRun sweep to start with default timing (10 seconds per phase). Customize timing with flags: sweep -w 15 for 15-second WiFi scans sweep -b 20 for 20-second BLE scans sweep -w 15 -b 20 to set both Run sweep -h to see all options. CSV output format\rResults are saved in a format similar to Kismet/Wigle exports:\nType,Name,MAC,Associated MAC,Channel,Frequency,RSSI,Auth,Cipher,802.11,WPS,Latitude,Longitude,Altitude,First Seen\rWiFi AP,MyNetwork,AA:BB:CC:DD:EE:FF,,6,2437,-45,WPA2,CCMP,ax/n/g/b,No,37.774929,-122.419416,10.5,2025-12-09 17:30:00\rWiFi Client,,11:22:33:44:55:66,AA:BB:CC:DD:EE:FF,,,,,,,37.774929,-122.419416,10.5,2025-12-09 17:30:00 Troubleshooting\rNo networks found: Move closer to wireless routers and try scanning again. \u0026ldquo;You Need to Scan APs First\u0026rdquo; message: Run a scan before trying to select a network. Live scan stops right away: Stop any active Wi-Fi attacks or portals from the menu and try again. FAQ\rCan I scan while connected to a network? Yes. The device will pause the connection briefly to scan, then resume. Where do the device vendor names come from? GhostESP looks up the device\u0026rsquo;s hardware address in a built-in database to identify the manufacturer. ","description":"Find and review Wi-Fi networks in your area.","permalink":"/latest/wifi/survey/","title":"Scanning networks"},{"content":"Discover nearby Wi-Fi networks and gather information about them. You can scan passively without connecting, or connect to a network and explore devices on it.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Finding nearby networks\rOn-device UI\rOpen Menu → WiFi → Scanning. You should see a menu with scan options. Choose Scan Access Points. The device will search for networks. Wait for the scan to finish and see a summary. Select List Access Points. You should see each network listed with its name, channel, signal strength, and device manufacturer. On-device UI — Optional features\rScan APs Live: Watch new networks appear in real time as they\u0026rsquo;re discovered. Channel Congestion: See how busy the wireless channels are in your area. Command line\rOpen the GhostESP terminal (serial connection or on-device terminal). Run scanap to start a scan. Wait for it to finish and show results. Run list -a to see the cached list of networks. Command line — Optional features\rRun scanap -live to watch networks appear as they\u0026rsquo;re discovered. Exploring a network\rOnce you connect to a network, you can discover devices and services on it.\nConnect to a network\rOpen Menu → WiFi → Connection → Connect to WiFi. Enter the network name and password when prompted. Wait for the connection to complete. The terminal will show status updates. To disconnect later, go to Menu → WiFi → Connection → Disconnect. Connect via command line\rRun connect \u0026quot;SSID\u0026quot; \u0026quot;password\u0026quot; (use quotes if the name or password has spaces). The terminal will show connection progress and confirm when connected. Run connect with no arguments to reconnect to the last network you used. Run disconnect to leave the network. Find devices on the network\rOpen Menu → WiFi → Scanning while connected. Choose Scan LAN Devices. You should see a list of devices and services on the network. Find devices via command line\rRun scanlocal to discover devices and services. You should see hostnames, service types, and ports. Run scanarp to find all active devices on the network. You should see IP addresses and device information. Check for open ports\rFrom the UI, select a device with Select LAN, then choose Scan Open Ports. You should see which ports are responding on that device. From the command line, run scanports \u0026lt;ip\u0026gt; to check a specific device. You should see open ports listed. Add all to check all ports, or start-end (like 20-1024) for a range. Run scanssh \u0026lt;ip\u0026gt; to specifically check if a device has SSH enabled. Troubleshooting\rNo networks found: Move closer to wireless routers and try scanning again. \u0026ldquo;You Need to Scan APs First\u0026rdquo; message: Run a scan before trying to select a network. Live scan stops right away: Stop any active Wi-Fi attacks or portals from the menu and try again. FAQ\rCan I scan while connected to a network? Yes. The device will pause the connection briefly to scan, then resume. Where do the device vendor names come from? GhostESP looks up the device\u0026rsquo;s hardware address in a small built-in database to potentially identify the manufacturer. ","description":"Find and review Wi-Fi networks in your area.","permalink":"/v1.8.1/wifi/survey/","title":"Scanning networks"},{"content":"Discover nearby Wi-Fi networks and gather information about them. You can scan passively without connecting, or connect to a network and explore devices on it.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Finding nearby networks\rOn-device UI\rOpen Menu → WiFi → Scanning. You should see a menu with scan options. Choose Scan Access Points. The device will search for networks. Wait for the scan to finish and see a summary. Select List Access Points. You should see each network listed with its name, channel, signal strength, and device manufacturer. On-device UI — Optional features\rScan APs Live: Watch new networks appear in real time as they\u0026rsquo;re discovered. Channel Congestion: See how busy the wireless channels are in your area. Command line\rOpen the GhostESP terminal (serial connection or on-device terminal). Run scanap to start a scan. Wait for it to finish and show results. Run list -a to see the cached list of networks. Command line — Optional features\rRun scanap -live to watch networks appear as they\u0026rsquo;re discovered. Exploring a network\rOnce you connect to a network, you can discover devices and services on it.\nConnect to a network\rOpen Menu → WiFi → Connection → Connect to WiFi. Enter the network name and password when prompted. Wait for the connection to complete. The terminal will show status updates. To disconnect later, go to Menu → WiFi → Connection → Disconnect. Connect via command line\rRun connect \u0026quot;SSID\u0026quot; \u0026quot;password\u0026quot; (use quotes if the name or password has spaces). The terminal will show connection progress and confirm when connected. Run connect with no arguments to reconnect to the last network you used. Run disconnect to leave the network. Find devices on the network\rOpen Menu → WiFi → Scanning while connected. Choose Scan LAN Devices. You should see a list of devices and services on the network. Find devices via command line\rRun scanlocal to discover devices and services. You should see hostnames, service types, and ports. Run scanarp to find all active devices on the network. You should see IP addresses and device information. Check for open ports\rFrom the UI, select a device with Select LAN, then choose Scan Open Ports. You should see which ports are responding on that device. From the command line, run scanports \u0026lt;ip\u0026gt; to check a specific device. You should see open ports listed. Add all to check all ports, or start-end (like 20-1024) for a range. Run scanssh \u0026lt;ip\u0026gt; to specifically check if a device has SSH enabled. Troubleshooting\rNo networks found: Move closer to wireless routers and try scanning again. \u0026ldquo;You Need to Scan APs First\u0026rdquo; message: Run a scan before trying to select a network. Live scan stops right away: Stop any active Wi-Fi attacks or portals from the menu and try again. FAQ\rCan I scan while connected to a network? Yes. The device will pause the connection briefly to scan, then resume. Where do the device vendor names come from? GhostESP looks up the device\u0026rsquo;s hardware address in a small built-in database to potentially identify the manufacturer. ","description":"Find and review Wi-Fi networks in your area.","permalink":"/v1.8/wifi/survey/","title":"Scanning networks"},{"content":"Discover nearby Wi-Fi networks and gather information about them. You can scan passively without connecting, or connect to a network and explore devices on it.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Finding nearby networks\rOn-device UI\rOpen Menu → WiFi → Scanning. You should see a menu with scan options. Choose Scan Access Points. The device will search for networks. Wait for the scan to finish and see a summary. Select List Access Points. You should see each network listed with its name, channel, signal strength, and device manufacturer. On-device UI — Optional features\rScan APs Live: Watch new networks appear in real time as they\u0026rsquo;re discovered. Channel Congestion: See how busy the wireless channels are in your area. Command line\rOpen the GhostESP terminal (serial connection or on-device terminal). Run scanap to start a scan. Wait for it to finish and show results. Run list -a to see the cached list of networks. Command line — Optional features\rRun scanap -live to watch networks appear as they\u0026rsquo;re discovered. Exploring a network\rOnce you connect to a network, you can discover devices and services on it.\nConnect to a network\rOpen Menu → WiFi → Connection → Connect to WiFi. Enter the network name and password when prompted. Wait for the connection to complete. The terminal will show status updates. To disconnect later, go to Menu → WiFi → Connection → Disconnect. Connect via command line\rRun connect \u0026quot;SSID\u0026quot; \u0026quot;password\u0026quot; (use quotes if the name or password has spaces). The terminal will show connection progress and confirm when connected. Run connect with no arguments to reconnect to the last network you used. Run disconnect to leave the network. Find devices on the network\rOpen Menu → WiFi → Scanning while connected. Choose Scan LAN Devices. You should see a list of devices and services on the network. Find devices via command line\rRun scanlocal to discover devices and services. You should see hostnames, service types, and ports. Run scanarp to find all active devices on the network. You should see IP addresses and device information. Check for open ports\rFrom the UI, select a device with Select LAN, then choose Scan Open Ports. You should see which ports are responding on that device. From the command line, run scanports \u0026lt;ip\u0026gt; to check a specific device. You should see open ports listed. Add all to check all ports, or start-end (like 20-1024) for a range. Run scanssh \u0026lt;ip\u0026gt; to specifically check if a device has SSH enabled. Full environment sweep\rScan all wireless activity at once and save results to your SD card.\nWhat it captures\rWiFi Access Points: Name, MAC, channel, frequency, signal strength, security type, cipher, 802.11 mode, WPS status WiFi Clients: MAC address and associated AP BLE Devices: Flippers, GATT devices, and raw BLE packets 802.15.4 Packets: Zigbee/Thread traffic (ESP32-C5 and C6 only) GPS Coordinates: Location data for each entry (if GPS module connected) Run a sweep from the UI\rOpen Menu → WiFi → Scanning → Sweep. The device will run through each scan phase automatically. Wait for all phases to complete. Progress is shown on screen. Find results in /ghostesp/sweeps/sweep_N.csv on your SD card. Run a sweep from command line\rRun sweep to start with default timing (10 seconds per phase). Customize timing with flags: sweep -w 15 for 15-second WiFi scans sweep -b 20 for 20-second BLE scans sweep -w 15 -b 20 to set both Run sweep -h to see all options. CSV output format\rResults are saved in a format similar to Kismet/Wigle exports:\nType,Name,MAC,Associated MAC,Channel,Frequency,RSSI,Auth,Cipher,802.11,WPS,Latitude,Longitude,Altitude,First Seen\rWiFi AP,MyNetwork,AA:BB:CC:DD:EE:FF,,6,2437,-45,WPA2,CCMP,ax/n/g/b,No,37.774929,-122.419416,10.5,2025-12-09 17:30:00\rWiFi Client,,11:22:33:44:55:66,AA:BB:CC:DD:EE:FF,,,,,,,37.774929,-122.419416,10.5,2025-12-09 17:30:00 Troubleshooting\rNo networks found: Move closer to wireless routers and try scanning again. \u0026ldquo;You Need to Scan APs First\u0026rdquo; message: Run a scan before trying to select a network. Live scan stops right away: Stop any active Wi-Fi attacks or portals from the menu and try again. FAQ\rCan I scan while connected to a network? Yes. The device will pause the connection briefly to scan, then resume. Where do the device vendor names come from? GhostESP looks up the device\u0026rsquo;s hardware address in a built-in database to identify the manufacturer. ","description":"Find and review Wi-Fi networks in your area.","permalink":"/v1.9/wifi/survey/","title":"Scanning networks"},{"content":"GATT defines how BLE devices expose data. This guide shows how to discover services on a device.\nWhat is GATT?\rWhen a BLE device advertises, it broadcasts basic info. To learn what it actually does, you must connect and read its GATT profile. A GATT profile contains:\nServices — Logical groupings of related functionality (e.g., \u0026ldquo;Heart Rate Service\u0026rdquo;) Characteristics — Individual data points within a service (e.g., \u0026ldquo;Heart Rate Measurement\u0026rdquo;) UUIDs — Unique identifiers for each service and characteristic For example, a fitness tracker might expose:\nBattery Service (UUID 0x180F) with a Battery Level characteristic Heart Rate Service (UUID 0x180D) with Heart Rate Measurement characteristic Device Information Service (UUID 0x180A) with Manufacturer Name, Model Number, etc. Prerequisites\rGhostESP device with Bluetooth support (not ESP32-S2) Target BLE device powered on and in range Quick Start\rOn-Device UI\rMenu → Bluetooth → GATT Scan → Start GATT Scan to discover devices List GATT Devices to see what was found Select GATT Device to pick one by index Enumerate Services to connect and read its GATT profile Track Device to locate it by signal strength Command Line\rblescan -g # Start GATT scan\rlistgatt # List discovered devices\rselectgatt 0 # Select device at index 0\renumgatt # Connect and enumerate services\rtrackgatt # Track by signal strength\rblescan -s # Stop scanning Step-by-Step Walkthrough\rStep 1: Scan for Connectable Devices\rStart a GATT scan to find BLE devices that accept connections:\nUI: Menu → Bluetooth → GATT Scan → Start GATT Scan\nCLI: blescan -g\nThe scan runs continuously, discovering devices as they advertise. Leave it running for 10-30 seconds to find nearby devices.\nStep 2: List Discovered Devices\rView the devices found during the scan:\nUI: Menu → Bluetooth → GATT Scan → List GATT Devices\nCLI: listgatt\nExample output:\n[0] [AirTag] 5C:94:F2:xx:xx:xx (-67 dB)\r[1] [SmartTag] DC:71:96:xx:xx:xx (-72 dB) [2] [Tile] F1:23:xx:xx:xx:xx (-81 dB)\r[3] Unknown 4A:B2:xx:xx:xx:xx (-85 dB) The index number (e.g., [0]) is used to select a device. Tracker types are auto-detected and shown in brackets.\nStep 3: Select a Device\rChoose a device for enumeration:\nUI: Menu → Bluetooth → GATT Scan → Select GATT Device → Enter the index number\nCLI: selectgatt \u0026lt;index\u0026gt; (e.g., selectgatt 0)\nStep 4: Enumerate Services\rConnect to the selected device and read its GATT profile:\nUI: Menu → Bluetooth → GATT Scan → Enumerate Services\nCLI: enumgatt\nGhostESP will:\nEstablish a BLE connection Query all services Display each service with its UUID and handle range Identify known services by name Example output:\nConnecting to 5C:94:F2:xx:xx:xx...\rConnected!\rService: Generic Access (0x1800) [handles 1-7]\rService: Generic Attribute (0x1801) [handles 8-11]\rService: Battery Service (0x180F) [handles 12-15]\rService: Device Information (0x180A) [handles 16-28]\rService: Unknown (0xFD44) [handles 29-35] Step 5: Track by Signal Strength (Optional)\rUse RSSI tracking to physically locate a device:\nUI: Menu → Bluetooth → GATT Scan → Track Device\nCLI: trackgatt\nThe display shows:\nTracking: 5C:94:F2:xx:xx:xx\r█████░░░░░ -67 dB ↑ CLOSER\rMin: -89 dB | Max: -61 dB Signal bars — Visual strength indicator dB value — Current signal strength (closer to 0 = stronger) Direction — ↑ CLOSER or ↓ FARTHER based on recent trend Min/Max — Range seen during tracking Walk around while watching the signal strength to locate the device.\nAutomatic Tracker Detection\rDuring scanning, GhostESP identifies common tracker types by their manufacturer data:\nTracker Type Description AirTag Apple AirTags Apple FindMy Other Apple Find My devices SmartTag Samsung SmartTag trackers Tile Tile Bluetooth trackers Chipolo Chipolo trackers FindMy Clone Third-party Find My compatible devices Detected types appear in brackets when listing devices, e.g., [AirTag].\nService UUID Recognition\rGhostESP automatically identifies hundreds of known GATT services:\nStandard BLE Services (0x18xx)\rUUID Service Name 0x1800 Generic Access 0x1801 Generic Attribute 0x180A Device Information 0x180D Heart Rate 0x180F Battery Service 0x1812 Human Interface Device (HID) 0x1826 Fitness Machine Vendor Services\rGhostESP recognizes services from:\nApple — AirDrop, HomeKit, Siri, AirPlay, AirPods, Nearby Google — Fast Pair, Chromecast, Eddystone, Nearby Samsung — SmartThings, Gear Tile — Core, Ring, Identity, Firmware Nordic — UART Service (serial over BLE) Flipper Zero — Custom serial service Fitbit — Fitness tracker services Xiaomi — MiHome, Amazfit Others — Sonos, Meta/Oculus, Spotify, Tesla, Amazon Alexa Unknown services display their raw UUID for manual lookup.\nCLI Command Reference\rCommand Description blescan -g Start GATT device scan blescan -s Stop any active BLE scan listgatt List discovered GATT devices selectgatt \u0026lt;index\u0026gt; Select a device by index enumgatt Connect and enumerate services trackgatt Track selected device by RSSI Tips\rConnection timeouts: Some devices sleep aggressively. Try moving closer or interacting with the device to wake it. Privacy-focused devices: Some trackers rotate their MAC addresses. The device you see may have a different address on the next scan. Multiple scans: Run several short scans rather than one long scan to catch devices that advertise infrequently. Signal strength: RSSI values are approximate. Walls, interference, and antenna orientation all affect readings. Troubleshooting\r\u0026ldquo;No devices found\u0026rdquo; — Move closer to BLE devices, or wait longer for devices to advertise. \u0026ldquo;Connection failed\u0026rdquo; — The device may be paired to another host, sleeping, or out of range. Try again. \u0026ldquo;Service enumeration empty\u0026rdquo; — Some devices require bonding/pairing before exposing services. GhostESP does passive enumeration. Bluetooth not available — ESP32-S2 devices do not have Bluetooth hardware. ","description":"Connect to BLE devices and enumerate their services and characteristics.","permalink":"/latest/ble/gatt/","title":"GATT Discovery"},{"content":"GATT defines how BLE devices expose data. This guide shows how to discover services on a device.\nWhat is GATT?\rWhen a BLE device advertises, it broadcasts basic info. To learn what it actually does, you must connect and read its GATT profile. A GATT profile contains:\nServices — Logical groupings of related functionality (e.g., \u0026ldquo;Heart Rate Service\u0026rdquo;) Characteristics — Individual data points within a service (e.g., \u0026ldquo;Heart Rate Measurement\u0026rdquo;) UUIDs — Unique identifiers for each service and characteristic For example, a fitness tracker might expose:\nBattery Service (UUID 0x180F) with a Battery Level characteristic Heart Rate Service (UUID 0x180D) with Heart Rate Measurement characteristic Device Information Service (UUID 0x180A) with Manufacturer Name, Model Number, etc. Prerequisites\rGhostESP device with Bluetooth support (not ESP32-S2) Target BLE device powered on and in range Quick Start\rOn-Device UI\rMenu → Bluetooth → GATT Scan → Start GATT Scan to discover devices List GATT Devices to see what was found Select GATT Device to pick one by index Enumerate Services to connect and read its GATT profile Track Device to locate it by signal strength Command Line\rblescan -g # Start GATT scan\rlistgatt # List discovered devices\rselectgatt 0 # Select device at index 0\renumgatt # Connect and enumerate services\rtrackgatt # Track by signal strength\rblescan -s # Stop scanning Step-by-Step Walkthrough\rStep 1: Scan for Connectable Devices\rStart a GATT scan to find BLE devices that accept connections:\nUI: Menu → Bluetooth → GATT Scan → Start GATT Scan\nCLI: blescan -g\nThe scan runs continuously, discovering devices as they advertise. Leave it running for 10-30 seconds to find nearby devices.\nStep 2: List Discovered Devices\rView the devices found during the scan:\nUI: Menu → Bluetooth → GATT Scan → List GATT Devices\nCLI: listgatt\nExample output:\n[0] [AirTag] 5C:94:F2:xx:xx:xx (-67 dB)\r[1] [SmartTag] DC:71:96:xx:xx:xx (-72 dB) [2] [Tile] F1:23:xx:xx:xx:xx (-81 dB)\r[3] Unknown 4A:B2:xx:xx:xx:xx (-85 dB) The index number (e.g., [0]) is used to select a device. Tracker types are auto-detected and shown in brackets.\nStep 3: Select a Device\rChoose a device for enumeration:\nUI: Menu → Bluetooth → GATT Scan → Select GATT Device → Enter the index number\nCLI: selectgatt \u0026lt;index\u0026gt; (e.g., selectgatt 0)\nStep 4: Enumerate Services\rConnect to the selected device and read its GATT profile:\nUI: Menu → Bluetooth → GATT Scan → Enumerate Services\nCLI: enumgatt\nGhostESP will:\nEstablish a BLE connection Query all services Display each service with its UUID and handle range Identify known services by name Example output:\nConnecting to 5C:94:F2:xx:xx:xx...\rConnected!\rService: Generic Access (0x1800) [handles 1-7]\rService: Generic Attribute (0x1801) [handles 8-11]\rService: Battery Service (0x180F) [handles 12-15]\rService: Device Information (0x180A) [handles 16-28]\rService: Unknown (0xFD44) [handles 29-35] Step 5: Track by Signal Strength (Optional)\rUse RSSI tracking to physically locate a device:\nUI: Menu → Bluetooth → GATT Scan → Track Device\nCLI: trackgatt\nThe display shows:\nTracking: 5C:94:F2:xx:xx:xx\r█████░░░░░ -67 dB ↑ CLOSER\rMin: -89 dB | Max: -61 dB Signal bars — Visual strength indicator dB value — Current signal strength (closer to 0 = stronger) Direction — ↑ CLOSER or ↓ FARTHER based on recent trend Min/Max — Range seen during tracking Walk around while watching the signal strength to locate the device.\nAutomatic Tracker Detection\rDuring scanning, GhostESP identifies common tracker types by their manufacturer data:\nTracker Type Description AirTag Apple AirTags Apple FindMy Other Apple Find My devices SmartTag Samsung SmartTag trackers Tile Tile Bluetooth trackers Chipolo Chipolo trackers FindMy Clone Third-party Find My compatible devices Detected types appear in brackets when listing devices, e.g., [AirTag].\nService UUID Recognition\rGhostESP automatically identifies hundreds of known GATT services:\nStandard BLE Services (0x18xx)\rUUID Service Name 0x1800 Generic Access 0x1801 Generic Attribute 0x180A Device Information 0x180D Heart Rate 0x180F Battery Service 0x1812 Human Interface Device (HID) 0x1826 Fitness Machine Vendor Services\rGhostESP recognizes services from:\nApple — AirDrop, HomeKit, Siri, AirPlay, AirPods, Nearby Google — Fast Pair, Chromecast, Eddystone, Nearby Samsung — SmartThings, Gear Tile — Core, Ring, Identity, Firmware Nordic — UART Service (serial over BLE) Flipper Zero — Custom serial service Fitbit — Fitness tracker services Xiaomi — MiHome, Amazfit Others — Sonos, Meta/Oculus, Spotify, Tesla, Amazon Alexa Unknown services display their raw UUID for manual lookup.\nCLI Command Reference\rCommand Description blescan -g Start GATT device scan blescan -s Stop any active BLE scan listgatt List discovered GATT devices selectgatt \u0026lt;index\u0026gt; Select a device by index enumgatt Connect and enumerate services trackgatt Track selected device by RSSI Tips\rConnection timeouts: Some devices sleep aggressively. Try moving closer or interacting with the device to wake it. Privacy-focused devices: Some trackers rotate their MAC addresses. The device you see may have a different address on the next scan. Multiple scans: Run several short scans rather than one long scan to catch devices that advertise infrequently. Signal strength: RSSI values are approximate. Walls, interference, and antenna orientation all affect readings. Troubleshooting\r\u0026ldquo;No devices found\u0026rdquo; — Move closer to BLE devices, or wait longer for devices to advertise. \u0026ldquo;Connection failed\u0026rdquo; — The device may be paired to another host, sleeping, or out of range. Try again. \u0026ldquo;Service enumeration empty\u0026rdquo; — Some devices require bonding/pairing before exposing services. GhostESP does passive enumeration. Bluetooth not available — ESP32-S2 devices do not have Bluetooth hardware. ","description":"Connect to BLE devices and enumerate their services and characteristics.","permalink":"/v1.9/ble/gatt/","title":"GATT Discovery"},{"content":"Use Ethernet scanning tools to discover devices, services, and open ports on your network.\nDevice Discovery\rNetwork Fingerprinting\rIdentify devices using service announcements (mDNS, SSDP, NBNS):\nethfp See Network Fingerprinting for detailed information.\nARP Scanning\rDiscover active hosts on the network using ARP:\netharp Returns a list of IP addresses and MAC addresses of devices responding to ARP requests.\nPing Scanning\rScan for active hosts using ICMP ping:\nethping Sends ping requests to discover which hosts are online.\nService Discovery\rBanner Grabbing and Service Detection\rProbe a host for running services and grab banners:\nethserv \u0026lt;ip\u0026gt; Example:\nethserv 192.168.1.1 Attempts to connect to common ports and retrieve service information (HTTP, SSH, FTP, etc.).\nPort Scanning\rTCP Port Scanning\rScan specific ports on a target:\nethports \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; Examples:\nethports 192.168.1.100 80\rethports 192.168.1.100 22,80,443 Scan Gateway\rScan the gateway (DHCP server):\nethports local 80 Scan All Ports\rScan all common ports on a target:\nethports 192.168.1.100 all Traceroute\rTrace the network path to a host:\nethtrace \u0026lt;ip\u0026gt; Example:\nethtrace 8.8.8.8 Shows each hop (router) between your device and the target.\nDNS Resolution\rDNS Lookup\rResolve a domain name to an IP address:\nethdns \u0026lt;domain\u0026gt; Example:\nethdns google.com Statistics\rNetwork Statistics\rDisplay Ethernet interface statistics:\nethstats Shows packet counts, errors, and other interface metrics.\n","description":"Discover and scan devices on your Ethernet network.","permalink":"/latest/ethernet/scanning/","title":"Network Scanning"},{"content":"Use Ethernet scanning tools to discover devices, services, and open ports on your network.\nDevice Discovery\rNetwork Fingerprinting\rIdentify devices using service announcements (mDNS, SSDP, NBNS):\nethfp See Network Fingerprinting for detailed information.\nARP Scanning\rDiscover active hosts on the network using ARP:\netharp Returns a list of IP addresses and MAC addresses of devices responding to ARP requests.\nPing Scanning\rScan for active hosts using ICMP ping:\nethping Sends ping requests to discover which hosts are online.\nService Discovery\rBanner Grabbing and Service Detection\rProbe a host for running services and grab banners:\nethserv \u0026lt;ip\u0026gt; Example:\nethserv 192.168.1.1 Attempts to connect to common ports and retrieve service information (HTTP, SSH, FTP, etc.).\nPort Scanning\rTCP Port Scanning\rScan specific ports on a target:\nethports \u0026lt;ip\u0026gt; \u0026lt;port\u0026gt; Examples:\nethports 192.168.1.100 80\rethports 192.168.1.100 22,80,443 Scan Gateway\rScan the gateway (DHCP server):\nethports local 80 Scan All Ports\rScan all common ports on a target:\nethports 192.168.1.100 all Traceroute\rTrace the network path to a host:\nethtrace \u0026lt;ip\u0026gt; Example:\nethtrace 8.8.8.8 Shows each hop (router) between your device and the target.\nDNS Resolution\rDNS Lookup\rResolve a domain name to an IP address:\nethdns \u0026lt;domain\u0026gt; Example:\nethdns google.com Statistics\rNetwork Statistics\rDisplay Ethernet interface statistics:\nethstats Shows packet counts, errors, and other interface metrics.\n","description":"Discover and scan devices on your Ethernet network.","permalink":"/v1.9/ethernet/scanning/","title":"Network Scanning"},{"content":"\rOverview\rGhostESP runs on a variety of ESP32 boards with varying feature support. This compatibility matrix helps you identify which features are available on your device.\nCompatibility Matrix\rBoard\rBluetooth\rNFC (PN532)\rNFC (Chameleon)\rIR TX\rIR RX\rGPS\rKeyboard\rDisplay\rSD Card\rCYD2USB✓✗✓✗✗✓✗✓✓\rCYDMicroUSB✓✗✓✗✗✓✗✓✓\rCYDDualUSB✓✗✓✗✗✓✗✓✓\rCYD2432S028R✓✗✓✗✗✓✗✓✓\rCYD 2.4″ variants✓✗✓✗✗✓✗✓✓\rWaveshare 7″✓✗✓✗✗✓✗✓✓\rCrowtech 7″✓✗✓✗✗✓✗✓✗\rSunton 7″✓✗✓✗✗✓✗✓✗\rCardputer✓✗✓✓✗✓✓✓✓\rCardputer ADV✓✗✓✓✗✓✓✓✓\rMarauderV4✓✗✓✗✗✓✗✓✗\rMarauderV6✓✗✓✗✗✓✗✓✗\rAwokMini✗✗✗✗✗✓✗✓✗\rAwok V5✓✗✓✗✗✓✗✓✗\rT-Display S3 Touch✓✗✓✗✗✓✗✓✓\rS3TWatch✓✗✓✓✗✗✗✓has 4MB vfs partition\rTEmbed C1101✓✓✓✓✓✗✗✓✓\rGhostBoard✓✗✓✗✗✓✗✗✓\rT-Deck✓✗✓✗✗✓✓✓✓\rJCMK DevBoardPro✓✗✓✗✗✓✗✓✓\rRabbitLabs Minion✓✗✓✗✗✓✗✗✗\rLolin S3 Pro✓✗✓✗✗✓✗✗✓\rFlipper JCMK GPS✗✗✓✗✗✓✗✗✓\rESP32 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S2 (generic)✗✗✗✗✗✓✗✗✓\rESP32-C3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C5 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C6 (generic)✓✗✓✗✗✓✗✗✓\rHeltec V3✓✗✓✗✗✓✗Status Display✓\rVendor Boards\rThe following table lists the vendor-specific boards supported by GhostESP with their corresponding build names:\nBoard Name\rBuild Name\rImage\rCYD2USBCYD2USB.zip\rCYDMicroUSBCYDMicroUSB.zip\rCYDDualUSBCYDDualUSB.zip\rCYD2432S028RCYD2432S028R.zip\rCYD 2.4″ variantsCYD2USB2.4Inch.zip or CYD2USB2.4Inch_C.zip\rWaveshare 7″Waveshare_LCD.zip\rCrowtech 7″Crowtech_LCD.zip\rSunton 7″Sunton_LCD.zip\rCardputerESP32-S3-Cardputer.zip\rCardputer ADVCardputerADV.zip\rMarauderV4MarauderV4_FlipperHub.zip\rMarauderV6 \u0026 AwokDualMarauderV6_AwokDual.zip\rAwokMiniAwokMini.zip\rAwok V5esp32v5_awok.zip\rT-Display S3 TouchLilyGo-TDisplayS3-Touch.zip\rS3TWatchLilyGo-S3TWatch-2020.zip\rTEmbed CC1101LilyGo-TEmbedC1101.zip\rGhostBoardghostboard.zip\rT-DeckLilyGo-T-Deck.zip\rJCMK DevBoardProJCMK_DevBoardPro.zip\rRabbitLabs MinionRabbitLabs_Minion.zip\rRabbitLabs PhantomCYD2USB2.4Inch.zip\rLolin S3 ProLolin_S3_Pro.zip\rFlipper JCMK GPSFlipper_JCMK_GPS.zip\rJC3248W535ENJC3248W535EN_LCD.zip\rWired Hatters ESPRocketesp32-generic.zip\rWired Hatters Ultimate MarauderRed Port: esp32-generic.zip and Blue Port: MarauderV4_FlipperHub.zip\rHeltec V3heltecv3.zip\rNote: Images are being added as they become available.\n","description":"Device compatibility matrix for GhostESP features","permalink":"/latest/getting-started/supported-hardware/","title":"Supported Hardware"},{"content":"\rOverview\rGhostESP runs on a variety of ESP32 boards with varying feature support. This compatibility matrix helps you identify which features are available on your device.\nCompatibility Matrix\rBoard\rBluetooth\rNFC (PN532)\rNFC (Chameleon)\rIR TX\rIR RX\rGPS\rKeyboard\rDisplay\rSD Card\rCYD2USB✓✗✓✗✗✓✗✓✓\rCYDMicroUSB✓✗✓✗✗✓✗✓✓\rCYDDualUSB✓✗✓✗✗✓✗✓✓\rCYD2432S028R✓✗✓✗✗✓✗✓✓\rCYD 2.4″ variants✓✗✓✗✗✓✗✓✓\rWaveshare 7″✓✗✓✗✗✓✗✓✓\rCrowtech 7″✓✗✓✗✗✓✗✓✗\rSunton 7″✓✗✓✗✗✓✗✓✗\rCardputer✓✗✓✓✗✓✓✓✓\rCardputer ADV✓✗✓✓✗✓✓✓✓\rMarauderV4✓✗✓✗✗✓✗✓✗\rMarauderV6✓✗✓✗✗✓✗✓✗\rAwokMini✗✗✗✗✗✓✗✓✗\rAwok V5✓✗✓✗✗✓✗✓✗\rT-Display S3 Touch✓✗✓✗✗✓✗✓✓\rS3TWatch✓✗✓✓✗✗✗✓has 4MB vfs partition\rTEmbed C1101✓✓✓✓✓✗✗✓✓\rGhostBoard✓✗✓✗✗✓✗✗✓\rT-Deck✓✗✓✗✗✓✓✓✓\rJCMK DevBoardPro✓✗✓✗✗✓✗✓✓\rRabbitLabs Minion✓✗✓✗✗✓✗✗✗\rLolin S3 Pro✓✗✓✗✗✓✗✗✓\rFlipper JCMK GPS✗✗✓✗✗✓✗✗✓\rESP32 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S2 (generic)✗✗✗✗✗✓✗✗✓\rESP32-C3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C5 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C6 (generic)✓✗✓✗✗✓✗✗✓\rVendor Boards\rThe following table lists the vendor-specific boards supported by GhostESP with their corresponding build names:\nBoard Name\rBuild Name\rImage\rCYD2USBCYD2USB.zip\rCYDMicroUSBCYDMicroUSB.zip\rCYDDualUSBCYDDualUSB.zip\rCYD2432S028RCYD2432S028R.zip\rCYD 2.4″ variantsCYD2USB2.4Inch.zip or CYD2USB2.4Inch_C.zip\rWaveshare 7″Waveshare_LCD.zip\rCrowtech 7″Crowtech_LCD.zip\rSunton 7″Sunton_LCD.zip\rCardputerESP32-S3-Cardputer.zip\rCardputer ADVCardputerADV.zip\rMarauderV4MarauderV4_FlipperHub.zip\rMarauderV6 \u0026 AwokDualMarauderV6_AwokDual.zip\rAwokMiniAwokMini.zip\rAwok V5esp32v5_awok.zip\rT-Display S3 TouchLilyGo-TDisplayS3-Touch.zip\rS3TWatchLilyGo-S3TWatch-2020.zip\rTEmbed CC1101LilyGo-TEmbedC1101.zip\rGhostBoardghostboard.zip\rT-DeckLilyGo-T-Deck.zip\rJCMK DevBoardProJCMK_DevBoardPro.zip\rRabbitLabs MinionRabbitLabs_Minion.zip\rRabbitLabs PhantomCYD2USB2.4Inch.zip\rLolin S3 ProLolin_S3_Pro.zip\rFlipper JCMK GPSFlipper_JCMK_GPS.zip\rJC3248W535ENJC3248W535EN_LCD.zip\rWired Hatters ESPRocketesp32-generic.zip\rWired Hatters Ultimate MarauderRed Port: esp32-generic.zip and Blue Port: MarauderV4_FlipperHub.zip\rNote: Images are being added as they become available.\n","description":"Device compatibility matrix for GhostESP features","permalink":"/v1.8.1/getting-started/supported-hardware/","title":"Supported Hardware"},{"content":"\rOverview\rGhostESP runs on a variety of ESP32 boards with varying feature support. This compatibility matrix helps you identify which features are available on your device.\nCompatibility Matrix\rBoard\rBluetooth\rNFC (PN532)\rNFC (Chameleon)\rIR TX\rIR RX\rGPS\rKeyboard\rDisplay\rSD Card\rCYD2USB✓✗✓✗✗✓✗✓✓\rCYDMicroUSB✓✗✓✗✗✓✗✓✓\rCYDDualUSB✓✗✓✗✗✓✗✓✓\rCYD2432S028R✓✗✓✗✗✓✗✓✓\rCYD 2.4″ variants✓✗✓✗✗✓✗✓✓\rWaveshare 7″✓✗✓✗✗✓✗✓✓\rCrowtech 7″✓✗✓✗✗✓✗✓✗\rSunton 7″✓✗✓✗✗✓✗✓✗\rCardputer✓✗✓✓✗✓✓✓✓\rCardputer ADV✓✗✓✓✗✓✓✓✓\rMarauderV4✓✗✓✗✗✓✗✓✗\rMarauderV6✓✗✓✗✗✓✗✓✗\rAwokMini✗✗✗✗✗✓✗✓✗\rAwok V5✓✗✓✗✗✓✗✓✗\rT-Display S3 Touch✓✗✓✗✗✓✗✓✓\rS3TWatch✓✗✓✓✗✗✗✓has 4MB vfs partition\rTEmbed C1101✓✓✓✓✓✗✗✓✓\rGhostBoard✓✗✓✗✗✓✗✗✓\rT-Deck✓✗✓✗✗✓✓✓✓\rJCMK DevBoardPro✓✗✓✗✗✓✗✓✓\rRabbitLabs Minion✓✗✓✗✗✓✗✗✗\rLolin S3 Pro✓✗✓✗✗✓✗✗✓\rFlipper JCMK GPS✗✗✓✗✗✓✗✗✓\rESP32 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S2 (generic)✗✗✗✗✗✓✗✗✓\rESP32-C3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C5 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C6 (generic)✓✗✓✗✗✓✗✗✓\rVendor Boards\rThe following table lists the vendor-specific boards supported by GhostESP with their corresponding build names:\nBoard Name\rBuild Name\rImage\rCYD2USBCYD2USB.zip\rCYDMicroUSBCYDMicroUSB.zip\rCYDDualUSBCYDDualUSB.zip\rCYD2432S028RCYD2432S028R.zip\rCYD 2.4″ variantsCYD2USB2.4Inch.zip or CYD2USB2.4Inch_C.zip\rWaveshare 7″Waveshare_LCD.zip\rCrowtech 7″Crowtech_LCD.zip\rSunton 7″Sunton_LCD.zip\rCardputerESP32-S3-Cardputer.zip\rCardputer ADVCardputerADV.zip\rMarauderV4MarauderV4_FlipperHub.zip\rMarauderV6 \u0026 AwokDualMarauderV6_AwokDual.zip\rAwokMiniAwokMini.zip\rAwok V5esp32v5_awok.zip\rT-Display S3 TouchLilyGo-TDisplayS3-Touch.zip\rS3TWatchLilyGo-S3TWatch-2020.zip\rTEmbed CC1101LilyGo-TEmbedC1101.zip\rGhostBoardghostboard.zip\rT-DeckLilyGo-T-Deck.zip\rJCMK DevBoardProJCMK_DevBoardPro.zip\rRabbitLabs MinionRabbitLabs_Minion.zip\rRabbitLabs PhantomCYD2USB2.4Inch.zip\rLolin S3 ProLolin_S3_Pro.zip\rFlipper JCMK GPSFlipper_JCMK_GPS.zip\rJC3248W535ENJC3248W535EN_LCD.zip\rWired Hatters ESPRocketesp32-generic.zip\rWired Hatters Ultimate MarauderRed Port: esp32-generic.zip and Blue Port: MarauderV4_FlipperHub.zip\rNote: Images are being added as they become available.\n","description":"Device compatibility matrix for GhostESP features","permalink":"/v1.8/getting-started/supported-hardware/","title":"Supported Hardware"},{"content":"\rOverview\rGhostESP runs on a variety of ESP32 boards with varying feature support. This compatibility matrix helps you identify which features are available on your device.\nCompatibility Matrix\rBoard\rBluetooth\rNFC (PN532)\rNFC (Chameleon)\rIR TX\rIR RX\rGPS\rKeyboard\rDisplay\rSD Card\rCYD2USB✓✗✓✗✗✓✗✓✓\rCYDMicroUSB✓✗✓✗✗✓✗✓✓\rCYDDualUSB✓✗✓✗✗✓✗✓✓\rCYD2432S028R✓✗✓✗✗✓✗✓✓\rCYD 2.4″ variants✓✗✓✗✗✓✗✓✓\rWaveshare 7″✓✗✓✗✗✓✗✓✓\rCrowtech 7″✓✗✓✗✗✓✗✓✗\rSunton 7″✓✗✓✗✗✓✗✓✗\rCardputer✓✗✓✓✗✓✓✓✓\rCardputer ADV✓✗✓✓✗✓✓✓✓\rMarauderV4✓✗✓✗✗✓✗✓✗\rMarauderV6✓✗✓✗✗✓✗✓✗\rAwokMini✗✗✗✗✗✓✗✓✗\rAwok V5✓✗✓✗✗✓✗✓✗\rT-Display S3 Touch✓✗✓✗✗✓✗✓✓\rS3TWatch✓✗✓✓✗✗✗✓has 4MB vfs partition\rTEmbed C1101✓✓✓✓✓✗✗✓✓\rGhostBoard✓✗✓✗✗✓✗✗✓\rT-Deck✓✗✓✗✗✓✓✓✓\rJCMK DevBoardPro✓✗✓✗✗✓✗✓✓\rRabbitLabs Minion✓✗✓✗✗✓✗✗✗\rLolin S3 Pro✓✗✓✗✗✓✗✗✓\rFlipper JCMK GPS✗✗✓✗✗✓✗✗✓\rESP32 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S2 (generic)✗✗✗✗✗✓✗✗✓\rESP32-C3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-S3 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C5 (generic)✓✗✓✗✗✓✗✗✓\rESP32-C6 (generic)✓✗✓✗✗✓✗✗✓\rHeltec V3✓✗✓✗✗✓✗Status Display✓\rVendor Boards\rThe following table lists the vendor-specific boards supported by GhostESP with their corresponding build names:\nBoard Name\rBuild Name\rImage\rCYD2USBCYD2USB.zip\rCYDMicroUSBCYDMicroUSB.zip\rCYDDualUSBCYDDualUSB.zip\rCYD2432S028RCYD2432S028R.zip\rCYD 2.4″ variantsCYD2USB2.4Inch.zip or CYD2USB2.4Inch_C.zip\rWaveshare 7″Waveshare_LCD.zip\rCrowtech 7″Crowtech_LCD.zip\rSunton 7″Sunton_LCD.zip\rCardputerESP32-S3-Cardputer.zip\rCardputer ADVCardputerADV.zip\rMarauderV4MarauderV4_FlipperHub.zip\rMarauderV6 \u0026 AwokDualMarauderV6_AwokDual.zip\rAwokMiniAwokMini.zip\rAwok V5esp32v5_awok.zip\rT-Display S3 TouchLilyGo-TDisplayS3-Touch.zip\rS3TWatchLilyGo-S3TWatch-2020.zip\rTEmbed CC1101LilyGo-TEmbedC1101.zip\rGhostBoardghostboard.zip\rT-DeckLilyGo-T-Deck.zip\rJCMK DevBoardProJCMK_DevBoardPro.zip\rRabbitLabs MinionRabbitLabs_Minion.zip\rRabbitLabs PhantomCYD2USB2.4Inch.zip\rLolin S3 ProLolin_S3_Pro.zip\rFlipper JCMK GPSFlipper_JCMK_GPS.zip\rJC3248W535ENJC3248W535EN_LCD.zip\rWired Hatters ESPRocketesp32-generic.zip\rWired Hatters Ultimate MarauderRed Port: esp32-generic.zip and Blue Port: MarauderV4_FlipperHub.zip\rHeltec V3heltecv3.zip\rNote: Images are being added as they become available.\n","description":"Device compatibility matrix for GhostESP features","permalink":"/v1.9/getting-started/supported-hardware/","title":"Supported Hardware"},{"content":"Broadcast fake BLE advertisements to simulate nearby devices or spoof Apple AirTags and other Find My devices.\nWi-Fi impact: Starting a BLE spam or spoofing session pauses the GhostNet AP until you run stop (or the task ends). Wi-Fi resumes automatically when BLE deinitializes.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Legal and ethical\rPatches and Mitigations\rMost modern devices (iOS 17+, Android 14+, Windows) block these attacks. They mostly affect older devices.\nSafety Warnings\rDo not use BLE attacks in public. They can crash devices and disrupt essential services.\nOnly use these features on devices you own or have permission to test.\nBLE Advertisement Spam\rBroadcast fake BLE advertisements to simulate nearby devices.\nOn-device UI\rOpen Menu → Bluetooth → Spam. You should see the spam options. Choose a spam type from the options below (for example, BLE Spam - Apple). The device will start broadcasting advertisements. Leave it running as long as you want. Select Stop BLE Spam to stop broadcasting. The device will show a summary of packets sent. Command line\rOpen the GhostESP terminal. Run blespam [TYPE] where the type is one of the modes below (for example, blespam -apple). The device will start broadcasting. Run stop when you\u0026rsquo;re done. The device will stop and show a summary. Spam modes\rApple Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Apple CLI: blespam -apple Broadcasts fake Apple device advertisements (AirPods, Apple TV, HomePod, AirTags, etc.). Uses Apple\u0026rsquo;s Continuity Protocol with randomized device types and colors. Nearby Apple devices may show pairing prompts or connection notifications. Microsoft Swift Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Microsoft CLI: blespam -ms or blespam -microsoft Broadcasts fake Microsoft device advertisements with random device names. Targets Windows devices with Swift Pair notifications. Samsung Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Samsung CLI: blespam -samsung Broadcasts fake Samsung Galaxy Watch and other Samsung device advertisements. Targets Android devices with Samsung pairing prompts. Google Fast Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Google CLI: blespam -google Broadcasts fake Google device advertisements using Google\u0026rsquo;s Fast Pair protocol. Targets Android devices with Google pairing notifications. Random Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Random CLI: blespam -random Cycles through all spam types (Apple, Microsoft, Samsung, Google) randomly. Broadcasts a mix of different device types to maximize disruption. AirTag Spoofing\rSpoof Apple AirTags and other Find My devices to broadcast their location. This makes your device appear as a legitimate AirTag to nearby Apple devices.\nWorkflow\rScan for AirTags\nOpen Menu → Bluetooth → AirTag → Start AirTag Scanner or run blescan -a. While the scanner is running, RSSI for already discovered AirTags is logged every few seconds in the terminal to show proximity changes. Wait for the scan to complete. List discovered AirTags\nOpen Menu → Bluetooth → AirTag → List AirTags or run list -airtags. You should see a list of discovered AirTags with their index numbers. Select an AirTag to spoof\nOpen Menu → Bluetooth → AirTag → Select AirTag. Enter the index number of the AirTag you want to spoof. Start spoofing\nOpen Menu → Bluetooth → AirTag → Spoof Selected AirTag or run spoofairtag. The device will broadcast as the selected AirTag. Nearby Apple devices will see your device as that AirTag. Stop spoofing\nOpen Menu → Bluetooth → AirTag → Stop Spoofing or run stopspoof. The device will stop broadcasting the AirTag advertisement. Notes\rBLE attacks are not available on ESP32-S2 devices. Spam attacks and spoofing are mutually exclusive; starting one will stop the other. The device broadcasts continuously until you explicitly stop it. Spam packet counts are logged every 5 seconds to the terminal. Apple spam uses different advertising intervals (~100ms) than other spam types for better compatibility. Spoofing captures the full AirTag advertisement payload during scanning for accurate reproduction. Troubleshooting\rAttacks not working: Check that your device has Bluetooth enabled and sufficient free memory. The AP pauses during attacks—if you need the web UI during testing, stop BLE first or use GhostLink. No AirTags found: Move closer to Apple devices with Find My enabled or try scanning again. Spoofing doesn\u0026rsquo;t appear on Apple devices: Ensure you\u0026rsquo;ve selected a valid AirTag before starting spoofing. Try stopping and restarting the spoof. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Send BLE advertisement spam and spoof AirTags.","permalink":"/latest/ble/attacks/","title":"Attacks"},{"content":"Broadcast fake BLE advertisements to simulate nearby devices or spoof Apple AirTags and other Find My devices.\nWi-Fi impact: Starting a BLE spam or spoofing session pauses the GhostNet AP until you run stop (or the task ends). Wi-Fi resumes automatically when BLE deinitializes.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Legal and ethical\rPatches and Mitigations\rBLE spam attacks have been largely patched in recent device updates:\niOS: Apple addressed the issue in iOS 17.2 and later with stability improvements and crash fixes. Android: Google patched BLE spam vulnerabilities in Android 14 and later. Windows: Microsoft has implemented protections in recent Windows versions. However, older devices and firmware versions remain vulnerable. These attacks are primarily useful for security research and testing on controlled devices.\nSafety Warnings\rDo not use BLE attacks in public or near other people. BLE spam can:\nCause nearby devices to crash or become unresponsive. Interfere with medical devices (pacemakers, insulin pumps, hearing aids, etc.) that rely on Bluetooth connectivity. Disrupt emergency communication systems. Cause unexpected behavior in connected vehicles and smart home systems. Violate local regulations regarding electromagnetic interference. Only use these features:\nIn isolated test environments with devices you own or have explicit permission to test. For authorized security research and penetration testing. With full understanding of the legal implications in your jurisdiction. BLE Advertisement Spam\rBroadcast fake BLE advertisements to simulate nearby devices.\nOn-device UI\rOpen Menu → Bluetooth → Spam. You should see the spam options. Choose a spam type from the options below (for example, BLE Spam - Apple). The device will start broadcasting advertisements. Leave it running as long as you want. Select Stop BLE Spam to stop broadcasting. The device will show a summary of packets sent. Command line\rOpen the GhostESP terminal. Run blespam [TYPE] where the type is one of the modes below (for example, blespam -apple). The device will start broadcasting. Run stop when you\u0026rsquo;re done. The device will stop and show a summary. Spam modes\rApple Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Apple CLI: blespam -apple Broadcasts fake Apple device advertisements (AirPods, Apple TV, HomePod, AirTags, etc.). Uses Apple\u0026rsquo;s Continuity Protocol with randomized device types and colors. Nearby Apple devices may show pairing prompts or connection notifications. Microsoft Swift Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Microsoft CLI: blespam -ms or blespam -microsoft Broadcasts fake Microsoft device advertisements with random device names. Targets Windows devices with Swift Pair notifications. Samsung Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Samsung CLI: blespam -samsung Broadcasts fake Samsung Galaxy Watch and other Samsung device advertisements. Targets Android devices with Samsung pairing prompts. Google Fast Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Google CLI: blespam -google Broadcasts fake Google device advertisements using Google\u0026rsquo;s Fast Pair protocol. Targets Android devices with Google pairing notifications. Random Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Random CLI: blespam -random Cycles through all spam types (Apple, Microsoft, Samsung, Google) randomly. Broadcasts a mix of different device types to maximize disruption. AirTag Spoofing\rSpoof Apple AirTags and other Find My devices to broadcast their location. This makes your device appear as a legitimate AirTag to nearby Apple devices.\nWorkflow\rScan for AirTags\nOpen Menu → Bluetooth → AirTag → Start AirTag Scanner or run blescan -a. Wait for the scan to complete. List discovered AirTags\nOpen Menu → Bluetooth → AirTag → List AirTags or run list -airtags. You should see a list of discovered AirTags with their index numbers. Select an AirTag to spoof\nOpen Menu → Bluetooth → AirTag → Select AirTag. Enter the index number of the AirTag you want to spoof. Start spoofing\nOpen Menu → Bluetooth → AirTag → Spoof Selected AirTag or run spoofairtag. The device will broadcast as the selected AirTag. Nearby Apple devices will see your device as that AirTag. Stop spoofing\nOpen Menu → Bluetooth → AirTag → Stop Spoofing or run stopspoof. The device will stop broadcasting the AirTag advertisement. Notes\rBLE attacks are not available on ESP32-S2 devices. Spam attacks and spoofing are mutually exclusive; starting one will stop the other. The device broadcasts continuously until you explicitly stop it. Spam packet counts are logged every 5 seconds to the terminal. Apple spam uses different advertising intervals (~100ms) than other spam types for better compatibility. Spoofing captures the full AirTag advertisement payload during scanning for accurate reproduction. Troubleshooting\rAttacks not working: Check that your device has Bluetooth enabled and sufficient free memory. The AP pauses during attacks—if you need the web UI during testing, stop BLE first or use Dual Communication. No AirTags found: Move closer to Apple devices with Find My enabled or try scanning again. Spoofing doesn\u0026rsquo;t appear on Apple devices: Ensure you\u0026rsquo;ve selected a valid AirTag before starting spoofing. Try stopping and restarting the spoof. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Send BLE advertisement spam and spoof AirTags.","permalink":"/v1.8.1/ble/attacks/","title":"Attacks"},{"content":"Broadcast fake BLE advertisements to simulate nearby devices or spoof Apple AirTags and other Find My devices.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Legal and ethical\rPatches and Mitigations\rBLE spam attacks have been largely patched in recent device updates:\niOS: Apple addressed the issue in iOS 17.2 and later with stability improvements and crash fixes. Android: Google patched BLE spam vulnerabilities in Android 14 and later. Windows: Microsoft has implemented protections in recent Windows versions. However, older devices and firmware versions remain vulnerable. These attacks are primarily useful for security research and testing on controlled devices.\nSafety Warnings\rDo not use BLE attacks in public or near other people. BLE spam can:\nCause nearby devices to crash or become unresponsive. Interfere with medical devices (pacemakers, insulin pumps, hearing aids, etc.) that rely on Bluetooth connectivity. Disrupt emergency communication systems. Cause unexpected behavior in connected vehicles and smart home systems. Violate local regulations regarding electromagnetic interference. Only use these features:\nIn isolated test environments with devices you own or have explicit permission to test. For authorized security research and penetration testing. With full understanding of the legal implications in your jurisdiction. BLE Advertisement Spam\rBroadcast fake BLE advertisements to simulate nearby devices.\nOn-device UI\rOpen Menu → Bluetooth → Spam. You should see the spam options. Choose a spam type from the options below (for example, BLE Spam - Apple). The device will start broadcasting advertisements. Leave it running as long as you want. Select Stop BLE Spam to stop broadcasting. The device will show a summary of packets sent. Command line\rOpen the GhostESP terminal. Run blespam [TYPE] where the type is one of the modes below (for example, blespam -apple). The device will start broadcasting. Run stop when you\u0026rsquo;re done. The device will stop and show a summary. Spam modes\rApple Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Apple CLI: blespam -apple Broadcasts fake Apple device advertisements (AirPods, Apple TV, HomePod, AirTags, etc.). Uses Apple\u0026rsquo;s Continuity Protocol with randomized device types and colors. Nearby Apple devices may show pairing prompts or connection notifications. Microsoft Swift Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Microsoft CLI: blespam -ms or blespam -microsoft Broadcasts fake Microsoft device advertisements with random device names. Targets Windows devices with Swift Pair notifications. Samsung Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Samsung CLI: blespam -samsung Broadcasts fake Samsung Galaxy Watch and other Samsung device advertisements. Targets Android devices with Samsung pairing prompts. Google Fast Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Google CLI: blespam -google Broadcasts fake Google device advertisements using Google\u0026rsquo;s Fast Pair protocol. Targets Android devices with Google pairing notifications. Random Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Random CLI: blespam -random Cycles through all spam types (Apple, Microsoft, Samsung, Google) randomly. Broadcasts a mix of different device types to maximize disruption. AirTag Spoofing\rSpoof Apple AirTags and other Find My devices to broadcast their location. This makes your device appear as a legitimate AirTag to nearby Apple devices.\nWorkflow\rScan for AirTags\nOpen Menu → Bluetooth → AirTag → Start AirTag Scanner or run blescan -a. Wait for the scan to complete. List discovered AirTags\nOpen Menu → Bluetooth → AirTag → List AirTags or run list -airtags. You should see a list of discovered AirTags with their index numbers. Select an AirTag to spoof\nOpen Menu → Bluetooth → AirTag → Select AirTag. Enter the index number of the AirTag you want to spoof. Start spoofing\nOpen Menu → Bluetooth → AirTag → Spoof Selected AirTag or run spoofairtag. The device will broadcast as the selected AirTag. Nearby Apple devices will see your device as that AirTag. Stop spoofing\nOpen Menu → Bluetooth → AirTag → Stop Spoofing or run stopspoof. The device will stop broadcasting the AirTag advertisement. Notes\rBLE attacks are not available on ESP32-S2 devices. Spam attacks and spoofing are mutually exclusive; starting one will stop the other. The device broadcasts continuously until you explicitly stop it. Spam packet counts are logged every 5 seconds to the terminal. Apple spam uses different advertising intervals (~100ms) than other spam types for better compatibility. Spoofing captures the full AirTag advertisement payload during scanning for accurate reproduction. Troubleshooting\rAttacks not working: Check that your device has Bluetooth enabled and sufficient free memory. Try turning off the GhostNet AP and rebooting to conserve memory. No AirTags found: Move closer to Apple devices with Find My enabled or try scanning again. Spoofing doesn\u0026rsquo;t appear on Apple devices: Ensure you\u0026rsquo;ve selected a valid AirTag before starting spoofing. Try stopping and restarting the spoof. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Send BLE advertisement spam and spoof AirTags.","permalink":"/v1.8/ble/attacks/","title":"Attacks"},{"content":"Broadcast fake BLE advertisements to simulate nearby devices or spoof Apple AirTags and other Find My devices.\nWi-Fi impact: Starting a BLE spam or spoofing session pauses the GhostNet AP until you run stop (or the task ends). Wi-Fi resumes automatically when BLE deinitializes.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Device must support Bluetooth (not available on ESP32-S2). Legal and ethical\rPatches and Mitigations\rMost modern devices (iOS 17+, Android 14+, Windows) block these attacks. They mostly affect older devices.\nSafety Warnings\rDo not use BLE attacks in public. They can crash devices and disrupt essential services.\nOnly use these features on devices you own or have permission to test.\nBLE Advertisement Spam\rBroadcast fake BLE advertisements to simulate nearby devices.\nOn-device UI\rOpen Menu → Bluetooth → Spam. You should see the spam options. Choose a spam type from the options below (for example, BLE Spam - Apple). The device will start broadcasting advertisements. Leave it running as long as you want. Select Stop BLE Spam to stop broadcasting. The device will show a summary of packets sent. Command line\rOpen the GhostESP terminal. Run blespam [TYPE] where the type is one of the modes below (for example, blespam -apple). The device will start broadcasting. Run stop when you\u0026rsquo;re done. The device will stop and show a summary. Spam modes\rApple Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Apple CLI: blespam -apple Broadcasts fake Apple device advertisements (AirPods, Apple TV, HomePod, AirTags, etc.). Uses Apple\u0026rsquo;s Continuity Protocol with randomized device types and colors. Nearby Apple devices may show pairing prompts or connection notifications. Microsoft Swift Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Microsoft CLI: blespam -ms or blespam -microsoft Broadcasts fake Microsoft device advertisements with random device names. Targets Windows devices with Swift Pair notifications. Samsung Device Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Samsung CLI: blespam -samsung Broadcasts fake Samsung Galaxy Watch and other Samsung device advertisements. Targets Android devices with Samsung pairing prompts. Google Fast Pair Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Google CLI: blespam -google Broadcasts fake Google device advertisements using Google\u0026rsquo;s Fast Pair protocol. Targets Android devices with Google pairing notifications. Random Spam\rUI: Menu → Bluetooth → Spam → BLE Spam - Random CLI: blespam -random Cycles through all spam types (Apple, Microsoft, Samsung, Google) randomly. Broadcasts a mix of different device types to maximize disruption. AirTag Spoofing\rSpoof Apple AirTags and other Find My devices to broadcast their location. This makes your device appear as a legitimate AirTag to nearby Apple devices.\nWorkflow\rScan for AirTags\nOpen Menu → Bluetooth → AirTag → Start AirTag Scanner or run blescan -a. While the scanner is running, RSSI for already discovered AirTags is logged every few seconds in the terminal to show proximity changes. Wait for the scan to complete. List discovered AirTags\nOpen Menu → Bluetooth → AirTag → List AirTags or run list -airtags. You should see a list of discovered AirTags with their index numbers. Select an AirTag to spoof\nOpen Menu → Bluetooth → AirTag → Select AirTag. Enter the index number of the AirTag you want to spoof. Start spoofing\nOpen Menu → Bluetooth → AirTag → Spoof Selected AirTag or run spoofairtag. The device will broadcast as the selected AirTag. Nearby Apple devices will see your device as that AirTag. Stop spoofing\nOpen Menu → Bluetooth → AirTag → Stop Spoofing or run stopspoof. The device will stop broadcasting the AirTag advertisement. Notes\rBLE attacks are not available on ESP32-S2 devices. Spam attacks and spoofing are mutually exclusive; starting one will stop the other. The device broadcasts continuously until you explicitly stop it. Spam packet counts are logged every 5 seconds to the terminal. Apple spam uses different advertising intervals (~100ms) than other spam types for better compatibility. Spoofing captures the full AirTag advertisement payload during scanning for accurate reproduction. Troubleshooting\rAttacks not working: Check that your device has Bluetooth enabled and sufficient free memory. The AP pauses during attacks—if you need the web UI during testing, stop BLE first or use GhostLink. No AirTags found: Move closer to Apple devices with Find My enabled or try scanning again. Spoofing doesn\u0026rsquo;t appear on Apple devices: Ensure you\u0026rsquo;ve selected a valid AirTag before starting spoofing. Try stopping and restarting the spoof. Bluetooth not supported: Ensure you\u0026rsquo;re using a device other than ESP32-S2, which does not have Bluetooth support. ","description":"Send BLE advertisement spam and spoof AirTags.","permalink":"/v1.9/ble/attacks/","title":"Attacks"},{"content":"Record Wi-Fi network traffic and save it to the SD card. You can then review the captured data on your computer or Flipper Zero.\nPrerequisites\rGhostESP flashed device with an SD card mounted. Optional: Flipper Zero with a microSD card if you want to save captures to the flipper. Capturing traffic\rOn-device UI\rOpen Menu → WiFi → Capture. You should see a list of capture types to choose from. Select the type of traffic you want to record (see capture types below). The device will start recording. Leave it running until you have enough data. Back out of the terminal view to stop recording. The device will save the file to the SD card and show the file path. Retrieve the file from the SD card using the GhostNet WebUI file browser or by removing the card. Files are saved under /mnt/ghostesp/pcaps/ with names like probescan_3.pcap. Command line\rOpen the GhostESP terminal. Run capture -\u0026lt;type\u0026gt; where type is one of the capture types below (for example, capture -probe). The device will start recording. Let it run while traffic is collected. Run capture -stop when you\u0026rsquo;re done. The device will save the file and show where it was saved. Capture modes\r-probe: Records probe requests so you can see devices searching for known SSIDs. -deauth: Records deauthentication frames to diagnose disconnect storms or targeted kicks. -beacon: Records beacons to review advertised SSIDs and channel metadata. -raw: Dumps every Wi-Fi frame seen on the tuned channel for full analysis. -eapol: Captures WPA/WPA2 4-way handshakes, PMKID messages, and rekeys so you can validate client authentications or export the flow for offline key cracking. -pwn: Records frames from Pwnagotchi devices. -wps: Captures Wi-Fi Protected Setup traffic to confirm whether a router exposes WPS enrolment. -802154 (ESP32-C5/C6 only): Records IEEE 802.15.4 frames when you supply capture -802154. Verify\rConfirm the SD card contains a .pcap file. Open the file in Wireshark app to make sure packets are listed. Notes\rCaptures save to /mnt/ghostesp/pcaps/ only when an SD card is mounted. If the folder is missing the device streams packets over UART to the Flipper Zero when writing a file. The firmware logs PCAP: saving to SD as ... when file storage is active, or PCAP: streaming over UART when it falls back to the terminal. Flipper Zero GhostESP app expects captures under /ext/apps_data/ghost_esp/pcaps/ on its microSD. Copy the .pcap using QFlipper or directly from the Flipper\u0026rsquo;s SD card to review in Wireshark. Large captures can take time to copy. Use a card reader instead of QFlipper or the WebUI for faster transfers. Troubleshooting\rCapture file not saved: Make sure the SD card is mounted and has free space. Always use stop or back out through the menu to properly save the file. SD card not recognized: Reboot the device with the SD card already inserted. Check that the card is properly seated and not corrupted. File transfer is slow: Use a card reader connected to your computer instead of the WebUI or other methods for faster transfers. ","description":"Record Wi-Fi traffic to a PCAP for later analysis.","permalink":"/latest/wifi/capture/","title":"Capturing packets"},{"content":"Record Wi-Fi network traffic and save it to the SD card. You can then review the captured data on your computer or Flipper Zero.\nPrerequisites\rGhostESP flashed device with an SD card mounted. Optional: Flipper Zero with a microSD card if you want to save captures to the flipper. Capturing traffic\rOn-device UI\rOpen Menu → WiFi → Capture. You should see a list of capture types to choose from. Select the type of traffic you want to record (see capture types below). The device will start recording. Leave it running until you have enough data. Back out of the terminal view to stop recording. The device will save the file to the SD card and show the file path. Retrieve the file from the SD card using the GhostNet WebUI file browser or by removing the card. Files are saved under /mnt/ghostesp/pcaps/ with names like probescan_3.pcap. Command line\rOpen the GhostESP terminal. Run capture -\u0026lt;type\u0026gt; where type is one of the capture types below (for example, capture -probe). The device will start recording. Let it run while traffic is collected. Run capture -stop when you\u0026rsquo;re done. The device will save the file and show where it was saved. Capture modes\r-probe: Records probe requests so you can see devices searching for known SSIDs. -deauth: Records deauthentication frames to diagnose disconnect storms or targeted kicks. -beacon: Records beacons to review advertised SSIDs and channel metadata. -raw: Dumps every Wi-Fi frame seen on the tuned channel for full analysis. -eapol: Captures WPA/WPA2 4-way handshakes, PMKID messages, and rekeys so you can validate client authentications or export the flow for offline key cracking. -pwn: Records frames from Pwnagotchi devices. -wps: Captures Wi-Fi Protected Setup traffic to confirm whether a router exposes WPS enrolment. -802154 (ESP32-C5/C6 only): Records IEEE 802.15.4 frames when you supply capture -802154. Verify\rConfirm the SD card contains a .pcap file. Open the file in Wireshark app to make sure packets are listed. Notes\rCaptures save to /mnt/ghostesp/pcaps/ only when an SD card is mounted. If the folder is missing the device streams packets over UART to the Flipper Zero when writing a file. The firmware logs PCAP: saving to SD as ... when file storage is active, or PCAP: streaming over UART when it falls back to the terminal. Flipper Zero GhostESP app expects captures under /ext/apps_data/ghost_esp/pcaps/ on its microSD. Copy the .pcap using QFlipper or Straight from the Flipper\u0026rsquo;s SD Card to review it in Wireshark or et cetera. Large captures can take time to copy. Use a card reader instead of QFlipper or the WebUI for faster transfers. Troubleshooting\rCapture file not saved: Make sure the SD card is mounted and has free space. Always use stop or back out through the menu to properly save the file. SD card not recognized: Reboot the device with the SD card already inserted. Check that the card is properly seated and not corrupted. File transfer is slow: Use a card reader connected to your computer instead of the WebUI or other methods for faster transfers. ","description":"Record Wi-Fi traffic to a PCAP for later analysis.","permalink":"/v1.8.1/wifi/capture/","title":"Capturing packets"},{"content":"Record Wi-Fi network traffic and save it to the SD card. You can then review the captured data on your computer or Flipper Zero.\nPrerequisites\rGhostESP flashed device with an SD card mounted. Optional: Flipper Zero with a microSD card if you want to save captures to the flipper. Capturing traffic\rOn-device UI\rOpen Menu → WiFi → Capture. You should see a list of capture types to choose from. Select the type of traffic you want to record (see capture types below). The device will start recording. Leave it running until you have enough data. Back out of the terminal view to stop recording. The device will save the file to the SD card and show the file path. Retrieve the file from the SD card using the GhostNet WebUI file browser or by removing the card. Files are saved under /mnt/ghostesp/pcaps/ with names like probescan_3.pcap. Command line\rOpen the GhostESP terminal. Run capture -\u0026lt;type\u0026gt; where type is one of the capture types below (for example, capture -probe). The device will start recording. Let it run while traffic is collected. Run capture -stop when you\u0026rsquo;re done. The device will save the file and show where it was saved. Capture modes\r-probe: Records probe requests so you can see devices searching for known SSIDs. -deauth: Records deauthentication frames to diagnose disconnect storms or targeted kicks. -beacon: Records beacons to review advertised SSIDs and channel metadata. -raw: Dumps every Wi-Fi frame seen on the tuned channel for full analysis. -eapol: Captures WPA/WPA2 4-way handshakes, PMKID messages, and rekeys so you can validate client authentications or export the flow for offline key cracking. -pwn: Records frames from Pwnagotchi devices. -wps: Captures Wi-Fi Protected Setup traffic to confirm whether a router exposes WPS enrolment. -802154 (ESP32-C5/C6 only): Records IEEE 802.15.4 frames when you supply capture -802154. Verify\rConfirm the SD card contains a .pcap file. Open the file in Wireshark app to make sure packets are listed. Notes\rCaptures save to /mnt/ghostesp/pcaps/ only when an SD card is mounted. If the folder is missing the device streams packets over UART to the Flipper Zero when writing a file. The firmware logs PCAP: saving to SD as ... when file storage is active, or PCAP: streaming over UART when it falls back to the terminal. Flipper Zero GhostESP app expects captures under /ext/apps_data/ghost_esp/pcaps/ on its microSD. Copy the .pcap using QFlipper or Straight from the Flipper\u0026rsquo;s SD Card to review it in Wireshark or et cetera. Large captures can take time to copy. Use a card reader instead of QFlipper or the WebUI for faster transfers. Troubleshooting\rCapture file not saved: Make sure the SD card is mounted and has free space. Always use stop or back out through the menu to properly save the file. SD card not recognized: Reboot the device with the SD card already inserted. Check that the card is properly seated and not corrupted. File transfer is slow: Use a card reader connected to your computer instead of the WebUI or other methods for faster transfers. ","description":"Record Wi-Fi traffic to a PCAP for later analysis.","permalink":"/v1.8/wifi/capture/","title":"Capturing packets"},{"content":"Record Wi-Fi network traffic and save it to the SD card. You can then review the captured data on your computer or Flipper Zero.\nPrerequisites\rGhostESP flashed device with an SD card mounted. Optional: Flipper Zero with a microSD card if you want to save captures to the flipper. Capturing traffic\rOn-device UI\rOpen Menu → WiFi → Capture. You should see a list of capture types to choose from. Select the type of traffic you want to record (see capture types below). The device will start recording. Leave it running until you have enough data. Back out of the terminal view to stop recording. The device will save the file to the SD card and show the file path. Retrieve the file from the SD card using the GhostNet WebUI file browser or by removing the card. Files are saved under /mnt/ghostesp/pcaps/ with names like probescan_3.pcap. Command line\rOpen the GhostESP terminal. Run capture -\u0026lt;type\u0026gt; where type is one of the capture types below (for example, capture -probe). The device will start recording. Let it run while traffic is collected. Run capture -stop when you\u0026rsquo;re done. The device will save the file and show where it was saved. Capture modes\r-probe: Records probe requests so you can see devices searching for known SSIDs. -deauth: Records deauthentication frames to diagnose disconnect storms or targeted kicks. -beacon: Records beacons to review advertised SSIDs and channel metadata. -raw: Dumps every Wi-Fi frame seen on the tuned channel for full analysis. -eapol: Captures WPA/WPA2 4-way handshakes, PMKID messages, and rekeys so you can validate client authentications or export the flow for offline key cracking. -pwn: Records frames from Pwnagotchi devices. -wps: Captures Wi-Fi Protected Setup traffic to confirm whether a router exposes WPS enrolment. -802154 (ESP32-C5/C6 only): Records IEEE 802.15.4 frames when you supply capture -802154. Verify\rConfirm the SD card contains a .pcap file. Open the file in Wireshark app to make sure packets are listed. Notes\rCaptures save to /mnt/ghostesp/pcaps/ only when an SD card is mounted. If the folder is missing the device streams packets over UART to the Flipper Zero when writing a file. The firmware logs PCAP: saving to SD as ... when file storage is active, or PCAP: streaming over UART when it falls back to the terminal. Flipper Zero GhostESP app expects captures under /ext/apps_data/ghost_esp/pcaps/ on its microSD. Copy the .pcap using QFlipper or directly from the Flipper\u0026rsquo;s SD card to review in Wireshark. Large captures can take time to copy. Use a card reader instead of QFlipper or the WebUI for faster transfers. Troubleshooting\rCapture file not saved: Make sure the SD card is mounted and has free space. Always use stop or back out through the menu to properly save the file. SD card not recognized: Reboot the device with the SD card already inserted. Check that the card is properly seated and not corrupted. File transfer is slow: Use a card reader connected to your computer instead of the WebUI or other methods for faster transfers. ","description":"Record Wi-Fi traffic to a PCAP for later analysis.","permalink":"/v1.9/wifi/capture/","title":"Capturing packets"},{"content":"\rConnecting to the CLI interface\rUse a serial console (115200 baud is recommended) with a USB data cable or the built-in Terminal app on touch-enabled boards. From the web UI, open the Terminal panel for remote access. When you launch a Wi-Fi or BLE command, the device suspends the GhostNet AP until the radio work finishes; once you run stop (or the command completes), BLE deinitializes and Wi-Fi returns automatically. Send help to confirm connectivity; output appears prefixed with \u0026gt; in the console. Core\rhelp [category|all] — List commands by category (wifi, ble, portal, comm, sd, led, gps, misc, printer, cast, capture, beacon, attack, ethernet). chipinfo — Print SoC model, cores, features, and IDF version. (for developers) mem [dump|trace \u0026lt;start|stop|dump\u0026gt;] — Print heap stats, dump allocation state, or control heap tracing. reboot — Soft restart the device. timezone \u0026lt;TZ\u0026gt; — Set timezone, e.g., timezone EST5EDT,M3.2.0,M11.1.0. stop — Stops all active attacks, scans, and background tasks. Also restarts Wi-Fi if it was suspended by BLE. WiFi\rScanning\rscanap [seconds|-live|-stop] — Run an AP scan, optionally for a set duration, live channel hop, or stop (-stop). scansta — Hop channels and log associated stations. scanall [seconds] — Combined AP and STA scan with summary. sweep [-w wifi_sec] [-b ble_sec] — Full environment sweep: scans WiFi APs, stations, and BLE devices, then saves a CSV report to SD (/mnt/ghostesp/sweeps/sweep_N.csv). list [-a|-s|-airtags] — Show AP scan results, associated stations, or AirTags. listenprobes [channel|stop] — Monitor probe requests and log to PCAP if SD is present. Targeting\rselect [-a|-s|-airtag] \u0026lt;idx[,idx]\u0026gt; — Queue APs, a station, or an AirTag by index for later actions. connect \u0026lt;ssid\u0026gt; [pass] — Join an infrastructure network (saves credentials); wrap SSID/password in quotes when they contain spaces, e.g., connect \u0026quot;My SSID\u0026quot; \u0026quot;My Password\u0026quot;. disconnect — Leave the current STA connection. apcred \u0026lt;ssid\u0026gt; \u0026lt;pass\u0026gt; or apcred -r — Change or reset GhostNet AP credentials. apenable on|off — Toggle AP persistence across reboots. trackap — Track selected AP signal strength (RSSI) in real-time. tracksta — Track selected station signal strength (RSSI) in real-time. Offense\rattack -d|-e|-s \u0026lt;password\u0026gt; — Trigger deauth, EAPOL logoff, or SAE flood (-s needs ESP32-C5/C6 and the target PSK). stopdeauth / stopspam — Halt active attacks or beacon floods. beaconspam [mode] — Broadcast spoof SSIDs (-r, -rr, -l, or custom text). karma start [ssid...] / karma stop — Respond to client probes with saved or provided SSIDs. pineap [-s] — Monitor Pineapple-style beacons; -s stops detection. saeflood \u0026lt;password\u0026gt; / stopsaeflood / saefloodhelp — Start, stop, or show help for SAE flood attacks. Network\rscanports \u0026lt;local|ip\u0026gt; [all|start-end], scanarp, scanlocal, scanssh \u0026lt;ip\u0026gt; — Scan the subnet, a target host, or run mDNS/SSH discovery utilities. dhcpstarve \u0026lt;start [threads]|stop|display\u0026gt; — Flood a DHCP server or show collected leases. capture \u0026lt;-probe|-deauth|-beacon\u0026gt; — Start packet captures for the specified frame type to SD. Output\rpowerprinter [ip text font alignment] — Send formatted PCL text jobs to LAN printers; pull saved defaults when arguments are omitted. dialconnect — Pair with a DIAL-capable device (e.g., Chromecast/YouTube). BLE\r(ESP32-S2 excluded)\nDiscovery\rblescan [-f|-ds|-a|-r|-s] — Scan for BLE devices, Flippers, spam detectors, or raw advertising; -s stops. blewardriving [-s] — Log BLE beacons with GPS metadata. Spoofing\rblespam [mode|-s] — Emit spoofed BLE advertisements (Apple, Microsoft, Samsung, Google, random). spoofairtag / stopspoof — Launch or stop AirTag spoofing. Devices\rlistflippers — Scan for nearby Flipper Zero devices. selectflipper \u0026lt;idx\u0026gt; — Choose a Flipper from the discovered list for interactions. listairtags — Discover nearby AirTags. selectairtag \u0026lt;idx\u0026gt; — Choose an AirTag for follow-up actions. GATT\rblescan -g — Scan for connectable BLE devices for GATT enumeration. listgatt — List discovered GATT devices with tracker type detection. selectgatt \u0026lt;idx\u0026gt; — Select a device by index for enumeration or tracking. enumgatt — Connect to the selected device and enumerate its GATT services. trackgatt — Track the selected device using real-time RSSI signal strength. Aerial Detection\raerialscan [seconds] — Scan for aerial devices (drones, UAVs, RC controllers) using WiFi and BLE in sequential phases. Default: 30 seconds. Phase 1: WiFi scan (OpenDroneID WiFi, DJI WiFi, drone networks). Phase 2: BLE scan (OpenDroneID BLE, DJI BLE) — WiFi automatically suspended during BLE phase and restored after. aeriallist — Display all detected aerial devices with full details including device ID, type, MAC address, vendor, signal strength (RSSI), GPS coordinates, altitude, speed, direction, operator location, and flight status. aerialtrack \u0026lt;idx|mac\u0026gt; — Track a specific aerial device by index or MAC address (e.g., aerialtrack 0 or aerialtrack 12:34:56:78:9a:bc). aerialstop — Stop aerial device scanning and tracking. aerialspoof [device_id lat lon alt] — Broadcast fake drone RemoteID for testing via BLE. Without arguments, uses default test drone (GHOST-TEST at San Francisco, 100m altitude). With arguments: device ID, latitude, longitude, altitude in meters. Example: aerialspoof DRONE-1234 40.7128 -74.0060 100. Complies with ASTM F3411 OpenDroneID standard. Note: WiFi automatically suspended during broadcast, restored on stop. aerialspoofstop — Stop broadcasting fake drone RemoteID and restore WiFi. Portal\rstartportal \u0026lt;path|default\u0026gt; \u0026lt;AP_SSID\u0026gt; [PSK] — Serve an Evil Portal bundle from SD or flash (default uses the built-in portal). stopportal — Shut down the active portal. listportals — List bundles on SD card or flash. evilportal -c \u0026lt;sethtmlstr|clear\u0026gt; — Manage the Evil Portal HTML buffer (-c sethtmlstr to capture inbound HTML, -c clear to revert to defaults). webauth on|off — Require or disable web UI login. GhostLink (Dual Communication)\rcommdiscovery — Start discovery mode to find other GhostESP devices. commconnect \u0026lt;peer_name\u0026gt; — Connect to a discovered peer (after commdiscovery). commsetpins \u0026lt;tx\u0026gt; \u0026lt;rx\u0026gt; — Save preferred pins. commsend \u0026lt;command\u0026gt; [data...] — Issue commands to the connected peer. commstatus — Inspect current link state. commdisconnect — Close the peer link. Storage\rFile Operations\rsd status — Show SD card mount status, type (physical/virtual), capacity, and usage percentage. sd list [path] — List files and directories with indices for quick reference. Default path: /mnt/ghostesp. sd info \u0026lt;index|path\u0026gt; — Display file or directory details (type, size, path). sd size \u0026lt;index|path\u0026gt; — Get file size in bytes (for pre-download checks). sd read \u0026lt;index|path\u0026gt; [offset] [length] — Read file with optional offset and length for chunked downloads. No size limit. sd write \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; — Create/overwrite file with base64-decoded data. sd append \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; — Append base64-decoded data to file. sd mkdir \u0026lt;path\u0026gt; — Create a new directory. sd rm \u0026lt;index|path\u0026gt; — Delete a file or empty directory. sd tree [path] [depth] — Recursive directory listing (default depth: 2, max: 10). All sd commands return machine-parsable output with prefixes like SD:OK:, SD:ERR:, SD:FILE:[n], SD:DIR:[n]}, SD:READ:, SD:WRITE:.\nPin Configuration\rsd_config — Display SD mode, pins, and status. sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; — Configure SPI wiring. sd_pins_mmc \u0026lt;clk\u0026gt; \u0026lt;cmd\u0026gt; \u0026lt;d0\u0026gt; \u0026lt;d1\u0026gt; \u0026lt;d2\u0026gt; \u0026lt;d3\u0026gt; — Configure SDIO wiring. sd_save_config — Persist SD settings to storage. RGB\rrgbmode \u0026lt;rainbow|police|strobe|off|color\u0026gt; — Run an LED effect immediately. setrgbmode \u0026lt;normal|rainbow|stealth\u0026gt; — Persist the LED mode across reboots. setrgbpins \u0026lt;r\u0026gt; \u0026lt;g\u0026gt; \u0026lt;b\u0026gt; — Override discrete RGB GPIOs; pass the same pin for all three values to switch into single-wire NeoPixel mode on that data pin. setrgbcount \u0026lt;1-512\u0026gt; — Persist the number of RGB LEDs connected so effects span the correct length. Reinitializes immediately if pins are already configured. setneopixelbrightness \u0026lt;0-100\u0026gt; / getneopixelbrightness — Control NeoPixel intensity. Status display (if present)\rAvailable on boards with an onboard OLED status display or when an external status display is configured.\nstatusidle [list|set \u0026lt;life|ghost|0|1\u0026gt;] — View or change the status OLED idle animation when CONFIG_WITH_STATUS_DISPLAY and a status display are enabled. statusidle — Show the current idle animation and timeout. statusidle list — List available idle animations. statusidle set \u0026lt;life|ghost|0|1\u0026gt; — Select the idle animation mode. Infrared\rir list [path] — List .ir files (default: /mnt/ghostesp/infrared/remotes). ir show \u0026lt;path|remote_index\u0026gt; — Parse and display signals from an IR file. After ir list, you can pass a numeric remote index. ir send \u0026lt;path|remote_index\u0026gt; [button_index] — Transmit a signal from a file. Use remote_index from ir list and optional button_index from ir show. ir universals list [-all] — List universal IR files and, with -all, all built‑in universal signals. ir universals send \u0026lt;index\u0026gt; — Transmit a built‑in universal signal by index (see ir universals list -all). ir universals sendall \u0026lt;file|TURNHISTVOFF\u0026gt; \u0026lt;button_name\u0026gt; [delay_ms] — Transmit all signals for a named button from a universal file or the built‑in TURNHISTVOFF set; can be stopped with stop. ir rx [timeout] — Wait up to timeout seconds (default 60) for a single IR signal, print it (decoded or RAW), then stop. ir learn [path] — Wait for a signal (10s). Without path, auto-create a new .ir file under /mnt/ghostesp/infrared/remotes; with path, append the learned signal to that file. ir dazzler [stop] — Start/stop continuous IR dazzler flood. Responses are machine-parsable: IR_DAZZLER:STARTED, IR_DAZZLER:FAILED, IR_DAZZLER:ALREADY_RUNNING, IR_DAZZLER:STOPPING, IR_DAZZLER:NOT_RUNNING. [IR/BEGIN] / [IR/CLOSE] (UART IR envelope) Usage: Send [IR/BEGIN], then a single IR message body, then [IR/CLOSE] on the same UART stream to trigger a one‑off transmit.\nBody format (.ir text block): Same fields as a standard .ir file entry (for example: name, type, protocol, address, command).\nBody format (JSON): Single JSON object carrying the same information as a .ir entry (parsed signal fields or raw timing data).\nExamples:\n[IR/BEGIN] name=Power type=parsed protocol=NEC addr=0x0000FFFF cmd=0x0000E718 [IR/CLOSE] [IR/BEGIN] {\u0026#34;name\u0026#34;:\u0026#34;Power\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;parsed\u0026#34;,\u0026#34;protocol\u0026#34;:\u0026#34;NEC\u0026#34;,\u0026#34;addr\u0026#34;:\u0026#34;0x0000FFFF\u0026#34;,\u0026#34;cmd\u0026#34;:\u0026#34;0x0000E718\u0026#34;} [IR/CLOSE] CLI response on success: IR: send OK, followed by a compact summary:\nParsed: IR: signal [Name] protocol=NEC addr=0x0000FFFF cmd=0x0000E718 Raw: IR: signal raw len=N freq=38000Hz duty=0.33 GPS\rgpspin [pin] — View or set the GPS RX pin for external GPS modules. Without arguments, shows current pin. Setting persists to NVS; restart GPS commands to apply. gpsinfo [-s] — Stream current fix, satellites, and speed; pass -s to stop the display task. startwd [-s] — Start wardriving (logs Wi-Fi/GPS to CSV). Use -s to stop. Ethernet\r(Requires CONFIG_WITH_ETHERNET)\nConnection Management\rethup — Initialize and bring up Ethernet interface; waits for link establishment and DHCP assignment. ethdown — Deinitialize and bring down Ethernet interface. ethinfo — Display Ethernet connection information (status, IP address, netmask, gateway, DNS servers, DHCP server). webuiap [on|off|toggle|status] — Restrict the web UI to clients connected to the onboard AP subnet (AP-only mode). Network Scanning\rethfp — Fingerprint network hosts using mDNS, NetBIOS, and SSDP (discovers Apple devices, Chromecasts, printers, Windows PCs, routers, smart TVs). etharp — Perform ARP scan on local Ethernet network subnet (1-254) to discover active hosts. ethping — Perform ICMP ping scan on local Ethernet network subnet (1-254) to find alive hosts. ethports [ip] [all|start-end] — Scan TCP ports on a target IP address. Without arguments: scans common ports on gateway. all: scan all ports (1-65535). start-end: custom port range (e.g., 80-443). Examples: ethports, ethports 192.168.1.1, ethports 192.168.1.1 all, ethports 192.168.1.1 80-443. Network Tools\rethdns \u0026lt;hostname\u0026gt; — Perform forward DNS lookup. ethdns reverse \u0026lt;ip_address\u0026gt; — Perform reverse DNS lookup. ethtrace \u0026lt;hostname_or_ip\u0026gt; [max_hops] — Perform traceroute to a target host (default: 30 hops, max: 64). ethserv [ip_address] — Service discovery and banner grabbing on a target IP (default: gateway). Scans common services (FTP, SSH, Telnet, SMTP, HTTP, HTTPS, etc.). ethhttp \u0026lt;url\u0026gt; [lines|all] — Send HTTP/HTTPS GET request to a server and display response. Default: shows first 25 lines [lines]: show first N lines (e.g., ethhttp http://example.com 50) all: show full response (e.g., ethhttp http://example.com all) Supports both HTTP and HTTPS (TLS 1.2) Examples: ethhttp http://example.com, ethhttp https://www.google.com 100, ethhttp http://192.168.1.1/index.html all ethntp [ntp_server] — Query NTP server and synchronize system time. Default server: pool.ntp.org. Examples: ethntp, ethntp pool.ntp.org, ethntp time.google.com. Configuration\rethconfig dhcp — Use DHCP for automatic IP assignment. ethconfig static \u0026lt;ip\u0026gt; \u0026lt;netmask\u0026gt; \u0026lt;gateway\u0026gt; — Set static IP configuration. Example: ethconfig static 192.168.1.100 255.255.255.0 192.168.1.1 ethconfig show — Show current IP configuration. ethmac — Display current MAC address. ethmac set \u0026lt;xx:xx:xx:xx:xx:xx\u0026gt; — Set Ethernet MAC address (may require reinitialization). Example: ethmac set 02:00:00:00:00:01 Statistics\rethstats — Display Ethernet network statistics (link status, IP info, MAC address, packet statistics, ARP statistics). Settings\rsettings list — Dump available configuration keys. settings help — Show supported subcommands. settings get \u0026lt;key\u0026gt; / settings set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; — Inspect or change individual options. settings reset [key] — Restore all settings or a specific key to defaults. ","description":"Common GhostESP CLI commands grouped by category.","permalink":"/latest/getting-started/command-line-reference/","title":"CLI Reference"},{"content":"\rConnecting to the CLI interface\rUse a serial console (115200 baud is recommended) with a USB data cable or the built-in Terminal app on touch-enabled boards. From the web UI, open the Terminal panel for remote access. When you launch a Wi-Fi or BLE command, the device suspends the GhostNet AP until the radio work finishes; once you run stop (or the command completes), BLE deinitializes and Wi-Fi returns automatically. Send help to confirm connectivity; output appears prefixed with \u0026gt; in the console. Core\rhelp [category|all] — List commands by category (wifi, ble, portal, comm, sd, led, gps, misc, printer, cast, capture, beacon, attack). chipinfo — Print SoC model, cores, features, and IDF version. (for developers) mem [dump|trace \u0026lt;start|stop|dump\u0026gt;] — Print heap stats, dump allocation state, or control heap tracing. reboot — Soft restart the device. timezone \u0026lt;TZ\u0026gt; — Set timezone, e.g., timezone EST5EDT,M3.2.0,M11.1.0. stop — Global kill switch: halt Wi-Fi attacks, BLE/BLE spam, GPS logging, wardriving, PCAP/CSV captures, RGB effects, and other background timers. It also tears down the BLE stack so suspended Wi-Fi/AP services come back online. WiFi\rScanning\rscanap [seconds|-live|-stop] — Run an AP scan, optionally for a set duration, live channel hop, or stop (-stop). scansta — Hop channels and log associated stations. scanall [seconds] — Combined AP and STA scan with summary. list [-a|-s|-airtags] — Show AP scan results, associated stations, or AirTags. listenprobes [channel|stop] — Monitor probe requests and log to PCAP if SD is present. Targeting\rselect [-a|-s|-airtag] \u0026lt;idx[,idx]\u0026gt; — Queue APs, a station, or an AirTag by index for later actions. connect \u0026lt;ssid\u0026gt; [pass] — Join an infrastructure network (saves credentials); wrap SSID/password in quotes when they contain spaces, e.g., connect \u0026quot;My SSID\u0026quot; \u0026quot;My Password\u0026quot;. disconnect — Leave the current STA connection. apcred \u0026lt;ssid\u0026gt; \u0026lt;pass\u0026gt; or apcred -r — Change or reset GhostNet AP credentials. apenable on|off — Toggle AP persistence across reboots. Offense\rattack -d|-e|-s \u0026lt;password\u0026gt; — Trigger deauth, EAPOL logoff, or SAE flood (-s needs ESP32-C5/C6 and the target PSK). stopdeauth / stopspam — Halt active attacks or beacon floods. beaconspam [mode] — Broadcast spoof SSIDs (-r, -rr, -l, or custom text). karma start [ssid...] / karma stop — Respond to client probes with saved or provided SSIDs. pineap [-s] — Monitor Pineapple-style beacons; -s stops detection. saeflood \u0026lt;password\u0026gt; / stopsaeflood / saefloodhelp — Launch, stop, or review SAE flood attack guidance. Network\rscanports \u0026lt;local|ip\u0026gt; [all|start-end], scanarp, scanlocal, scanssh \u0026lt;ip\u0026gt; — Scan the subnet, a target host, or run mDNS/SSH discovery utilities. dhcpstarve \u0026lt;start [threads]|stop|display\u0026gt; — Flood a DHCP server or show collected leases. capture \u0026lt;-probe|-deauth|-beacon\u0026gt; — Start packet captures for the specified frame type to SD. Output\rpowerprinter [ip text font alignment] — Send formatted PCL text jobs to LAN printers; pull saved defaults when arguments are omitted. dialconnect — Pair with a DIAL-capable device (e.g., Chromecast/YouTube). BLE\r(ESP32-S2 excluded)\nDiscovery\rblescan [-f|-ds|-a|-r|-s] — Scan for BLE devices, Flippers, spam detectors, or raw advertising; -s stops. blewardriving [-s] — Log BLE beacons with GPS metadata. Spoofing\rblespam [mode|-s] — Emit spoofed BLE advertisements (Apple, Microsoft, Samsung, Google, random). spoofairtag / stopspoof — Launch or stop AirTag spoofing. Devices\rlistflippers — Scan for nearby Flipper Zero devices. selectflipper \u0026lt;idx\u0026gt; — Choose a Flipper from the discovered list for interactions. listairtags — Discover nearby AirTags. selectairtag \u0026lt;idx\u0026gt; — Choose an AirTag for follow-up actions. Portal\rstartportal \u0026lt;path|default\u0026gt; \u0026lt;AP_SSID\u0026gt; [PSK] — Serve an Evil Portal bundle from SD or flash (default uses the built-in portal). stopportal — Shut down the active portal. listportals — List bundles on SD card or flash. evilportal -c \u0026lt;sethtmlstr|clear\u0026gt; — Manage the Evil Portal HTML buffer (-c sethtmlstr to capture inbound HTML, -c clear to revert to defaults). webauth on|off — Require or disable web UI login. Dual Communication\rcommdiscovery — Enter UART discovery mode, broadcasting handshake frames until peers reply (run before commconnect). commconnect \u0026lt;peer_name\u0026gt; — Connect to a discovered peer (after commdiscovery). commsetpins \u0026lt;tx\u0026gt; \u0026lt;rx\u0026gt; — Save preferred pins. commsend \u0026lt;command\u0026gt; [data...] — Issue commands to the connected peer. commstatus — Inspect current link state. commdisconnect — Close the peer link. Storage\rsd_config — Display SD mode, pins, and status. sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; — Configure SPI wiring. sd_pins_mmc \u0026lt;clk\u0026gt; \u0026lt;cmd\u0026gt; \u0026lt;d0\u0026gt; \u0026lt;d1\u0026gt; \u0026lt;d2\u0026gt; \u0026lt;d3\u0026gt; — Configure SDIO wiring. sd_save_config — Persist SD settings to storage. RGB\rrgbmode \u0026lt;rainbow|police|strobe|off|color\u0026gt; — Run an LED effect immediately. setrgbmode \u0026lt;normal|rainbow|stealth\u0026gt; — Persist the LED mode across reboots. setrgbpins \u0026lt;r\u0026gt; \u0026lt;g\u0026gt; \u0026lt;b\u0026gt; — Override discrete RGB GPIOs; pass the same pin for all three values to switch into single-wire NeoPixel mode on that data pin. setneopixelbrightness \u0026lt;0-100\u0026gt; / getneopixelbrightness — Control NeoPixel intensity. GPS\rgpsinfo [-s] — Stream current fix, satellites, and speed; pass -s to stop the display task. startwd [-s] — Begin Wi-Fi wardriving with GPS logging, CSV output, and monitor mode; pass -s to stop and flush logs. Settings\rsettings list — Dump available configuration keys. settings help — Show supported subcommands. settings get \u0026lt;key\u0026gt; / settings set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; — Inspect or change individual options. settings reset [key] — Restore all settings or a specific key to defaults. ","description":"Common GhostESP CLI commands grouped by category.","permalink":"/v1.8.1/getting-started/command-line-reference/","title":"CLI Reference"},{"content":"\rConnecting to the CLI interface\rUse a serial console (115200 baud is recommended) with a USB data cable or the built-in Terminal app on touch-enabled boards. From the web UI, open the Terminal panel for remote access (running Wi-Fi/BLE operations will drop the GhostNet AP while the single radio switches modes). Send help to confirm connectivity; output appears prefixed with \u0026gt; in the console. Core\rhelp [category|all] — List commands by category (wifi, ble, portal, comm, sd, led, gps, misc, printer, cast, capture, beacon, attack). chipinfo — Print SoC model, cores, features, and IDF version. (for developers) mem [dump|trace \u0026lt;start|stop|dump\u0026gt;] — Print heap stats, dump allocation state, or control heap tracing. reboot — Soft restart the device. timezone \u0026lt;TZ\u0026gt; — Set timezone, e.g., timezone EST5EDT,M3.2.0,M11.1.0. stop — Global kill switch: halt Wi-Fi attacks, BLE/BLE spam, GPS logging, wardriving, PCAP/CSV captures, RGB effects, and other background timers, returning the device to idle. WiFi\rScanning\rscanap [seconds|-live|-stop] — Run an AP scan, optionally for a set duration, live channel hop, or stop (-stop). scansta — Hop channels and log associated stations. scanall [seconds] — Combined AP and STA scan with summary. list [-a|-s|-airtags] — Show AP scan results, associated stations, or AirTags. listenprobes [channel|stop] — Monitor probe requests and log to PCAP if SD is present. Targeting\rselect [-a|-s|-airtag] \u0026lt;idx[,idx]\u0026gt; — Queue APs, a station, or an AirTag by index for later actions. connect \u0026lt;ssid\u0026gt; [pass] — Join an infrastructure network (saves credentials); wrap SSID/password in quotes when they contain spaces, e.g., connect \u0026quot;My SSID\u0026quot; \u0026quot;My Password\u0026quot;. disconnect — Leave the current STA connection. apcred \u0026lt;ssid\u0026gt; \u0026lt;pass\u0026gt; or apcred -r — Change or reset GhostNet AP credentials. apenable on|off — Toggle AP persistence across reboots. Offense\rattack -d|-e|-s \u0026lt;password\u0026gt; — Trigger deauth, EAPOL logoff, or SAE flood (-s needs ESP32-C5/C6 and the target PSK). stopdeauth / stopspam — Halt active attacks or beacon floods. beaconspam [mode] — Broadcast spoof SSIDs (-r, -rr, -l, or custom text). karma start [ssid...] / karma stop — Respond to client probes with saved or provided SSIDs. pineap [-s] — Monitor Pineapple-style beacons; -s stops detection. saeflood \u0026lt;password\u0026gt; / stopsaeflood / saefloodhelp — Launch, stop, or review SAE flood attack guidance. Network\rscanports \u0026lt;local|ip\u0026gt; [all|start-end], scanarp, scanlocal, scanssh \u0026lt;ip\u0026gt; — Scan the subnet, a target host, or run mDNS/SSH discovery utilities. dhcpstarve \u0026lt;start [threads]|stop|display\u0026gt; — Flood a DHCP server or show collected leases. capture \u0026lt;-probe|-deauth|-beacon\u0026gt; — Start packet captures for the specified frame type to SD. Output\rpowerprinter [ip text font alignment] — Send formatted PCL text jobs to LAN printers; pull saved defaults when arguments are omitted. dialconnect — Pair with a DIAL-capable device (e.g., Chromecast/YouTube). BLE\r(ESP32-S2 excluded)\nDiscovery\rblescan [-f|-ds|-a|-r|-s] — Scan for BLE devices, Flippers, spam detectors, or raw advertising; -s stops. blewardriving [-s] — Log BLE beacons with GPS metadata. Spoofing\rblespam [mode|-s] — Emit spoofed BLE advertisements (Apple, Microsoft, Samsung, Google, random). spoofairtag / stopspoof — Launch or stop AirTag spoofing. Devices\rlistflippers — Scan for nearby Flipper Zero devices. selectflipper \u0026lt;idx\u0026gt; — Choose a Flipper from the discovered list for interactions. listairtags — Discover nearby AirTags. selectairtag \u0026lt;idx\u0026gt; — Choose an AirTag for follow-up actions. Portal\rstartportal \u0026lt;path|default\u0026gt; \u0026lt;AP_SSID\u0026gt; [PSK] — Serve an Evil Portal bundle from SD or flash (default uses the built-in portal). stopportal — Shut down the active portal. listportals — List bundles on SD card or flash. evilportal -c \u0026lt;sethtmlstr|clear\u0026gt; — Manage the Evil Portal HTML buffer (-c sethtmlstr to capture inbound HTML, -c clear to revert to defaults). webauth on|off — Require or disable web UI login. Dual Communication\rcommdiscovery — Enter UART discovery mode, broadcasting handshake frames until peers reply (run before commconnect). commconnect \u0026lt;peer_name\u0026gt; — Connect to a discovered peer (after commdiscovery). commsetpins \u0026lt;tx\u0026gt; \u0026lt;rx\u0026gt; — Save preferred pins. commsend \u0026lt;command\u0026gt; [data...] — Issue commands to the connected peer. commstatus — Inspect current link state. commdisconnect — Close the peer link. Storage\rsd_config — Display SD mode, pins, and status. sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; — Configure SPI wiring. sd_pins_mmc \u0026lt;clk\u0026gt; \u0026lt;cmd\u0026gt; \u0026lt;d0\u0026gt; \u0026lt;d1\u0026gt; \u0026lt;d2\u0026gt; \u0026lt;d3\u0026gt; — Configure SDIO wiring. sd_save_config — Persist SD settings to storage. RGB\rrgbmode \u0026lt;rainbow|police|strobe|off|color\u0026gt; — Run an LED effect immediately. setrgbmode \u0026lt;normal|rainbow|stealth\u0026gt; — Persist the LED mode across reboots. setrgbpins \u0026lt;r\u0026gt; \u0026lt;g\u0026gt; \u0026lt;b\u0026gt; — Override discrete RGB GPIOs; pass the same pin for all three values to switch into single-wire NeoPixel mode on that data pin. setneopixelbrightness \u0026lt;0-100\u0026gt; / getneopixelbrightness — Control NeoPixel intensity. GPS\rgpsinfo [-s] — Stream current fix, satellites, and speed; pass -s to stop the display task. startwd [-s] — Begin Wi-Fi wardriving with GPS logging, CSV output, and monitor mode; pass -s to stop and flush logs. Settings\rsettings list — Dump available configuration keys. settings help — Show supported subcommands. settings get \u0026lt;key\u0026gt; / settings set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; — Inspect or change individual options. settings reset [key] — Restore all settings or a specific key to defaults. ","description":"Common GhostESP CLI commands grouped by category.","permalink":"/v1.8/getting-started/command-line-reference/","title":"CLI Reference"},{"content":"\rConnecting to the CLI interface\rUse a serial console (115200 baud is recommended) with a USB data cable or the built-in Terminal app on touch-enabled boards. From the web UI, open the Terminal panel for remote access. When you launch a Wi-Fi or BLE command, the device suspends the GhostNet AP until the radio work finishes; once you run stop (or the command completes), BLE deinitializes and Wi-Fi returns automatically. Send help to confirm connectivity; output appears prefixed with \u0026gt; in the console. Core\rhelp [category|all] — List commands by category (wifi, ble, portal, comm, sd, led, gps, misc, printer, cast, capture, beacon, attack, ethernet). chipinfo — Print SoC model, cores, features, and IDF version. (for developers) mem [dump|trace \u0026lt;start|stop|dump\u0026gt;] — Print heap stats, dump allocation state, or control heap tracing. reboot — Soft restart the device. timezone \u0026lt;TZ\u0026gt; — Set timezone, e.g., timezone EST5EDT,M3.2.0,M11.1.0. stop — Stops all active attacks, scans, and background tasks. Also restarts Wi-Fi if it was suspended by BLE. WiFi\rScanning\rscanap [seconds|-live|-stop] — Run an AP scan, optionally for a set duration, live channel hop, or stop (-stop). scansta — Hop channels and log associated stations. scanall [seconds] — Combined AP and STA scan with summary. sweep [-w wifi_sec] [-b ble_sec] — Full environment sweep: scans WiFi APs, stations, and BLE devices, then saves a CSV report to SD (/mnt/ghostesp/sweeps/sweep_N.csv). list [-a|-s|-airtags] — Show AP scan results, associated stations, or AirTags. listenprobes [channel|stop] — Monitor probe requests and log to PCAP if SD is present. Targeting\rselect [-a|-s|-airtag] \u0026lt;idx[,idx]\u0026gt; — Queue APs, a station, or an AirTag by index for later actions. connect \u0026lt;ssid\u0026gt; [pass] — Join an infrastructure network (saves credentials); wrap SSID/password in quotes when they contain spaces, e.g., connect \u0026quot;My SSID\u0026quot; \u0026quot;My Password\u0026quot;. disconnect — Leave the current STA connection. apcred \u0026lt;ssid\u0026gt; \u0026lt;pass\u0026gt; or apcred -r — Change or reset GhostNet AP credentials. apenable on|off — Toggle AP persistence across reboots. trackap — Track selected AP signal strength (RSSI) in real-time. tracksta — Track selected station signal strength (RSSI) in real-time. Offense\rattack -d|-e|-s \u0026lt;password\u0026gt; — Trigger deauth, EAPOL logoff, or SAE flood (-s needs ESP32-C5/C6 and the target PSK). stopdeauth / stopspam — Halt active attacks or beacon floods. beaconspam [mode] — Broadcast spoof SSIDs (-r, -rr, -l, or custom text). karma start [ssid...] / karma stop — Respond to client probes with saved or provided SSIDs. pineap [-s] — Monitor Pineapple-style beacons; -s stops detection. saeflood \u0026lt;password\u0026gt; / stopsaeflood / saefloodhelp — Start, stop, or show help for SAE flood attacks. Network\rscanports \u0026lt;local|ip\u0026gt; [all|start-end], scanarp, scanlocal, scanssh \u0026lt;ip\u0026gt; — Scan the subnet, a target host, or run mDNS/SSH discovery utilities. dhcpstarve \u0026lt;start [threads]|stop|display\u0026gt; — Flood a DHCP server or show collected leases. capture \u0026lt;-probe|-deauth|-beacon\u0026gt; — Start packet captures for the specified frame type to SD. Output\rpowerprinter [ip text font alignment] — Send formatted PCL text jobs to LAN printers; pull saved defaults when arguments are omitted. dialconnect — Pair with a DIAL-capable device (e.g., Chromecast/YouTube). BLE\r(ESP32-S2 excluded)\nDiscovery\rblescan [-f|-ds|-a|-r|-s] — Scan for BLE devices, Flippers, spam detectors, or raw advertising; -s stops. blewardriving [-s] — Log BLE beacons with GPS metadata. Spoofing\rblespam [mode|-s] — Emit spoofed BLE advertisements (Apple, Microsoft, Samsung, Google, random). spoofairtag / stopspoof — Launch or stop AirTag spoofing. Devices\rlistflippers — Scan for nearby Flipper Zero devices. selectflipper \u0026lt;idx\u0026gt; — Choose a Flipper from the discovered list for interactions. listairtags — Discover nearby AirTags. selectairtag \u0026lt;idx\u0026gt; — Choose an AirTag for follow-up actions. GATT\rblescan -g — Scan for connectable BLE devices for GATT enumeration. listgatt — List discovered GATT devices with tracker type detection. selectgatt \u0026lt;idx\u0026gt; — Select a device by index for enumeration or tracking. enumgatt — Connect to the selected device and enumerate its GATT services. trackgatt — Track the selected device using real-time RSSI signal strength. Aerial Detection\raerialscan [seconds] — Scan for aerial devices (drones, UAVs, RC controllers) using WiFi and BLE in sequential phases. Default: 30 seconds. Phase 1: WiFi scan (OpenDroneID WiFi, DJI WiFi, drone networks). Phase 2: BLE scan (OpenDroneID BLE, DJI BLE) — WiFi automatically suspended during BLE phase and restored after. aeriallist — Display all detected aerial devices with full details including device ID, type, MAC address, vendor, signal strength (RSSI), GPS coordinates, altitude, speed, direction, operator location, and flight status. aerialtrack \u0026lt;idx|mac\u0026gt; — Track a specific aerial device by index or MAC address (e.g., aerialtrack 0 or aerialtrack 12:34:56:78:9a:bc). aerialstop — Stop aerial device scanning and tracking. aerialspoof [device_id lat lon alt] — Broadcast fake drone RemoteID for testing via BLE. Without arguments, uses default test drone (GHOST-TEST at San Francisco, 100m altitude). With arguments: device ID, latitude, longitude, altitude in meters. Example: aerialspoof DRONE-1234 40.7128 -74.0060 100. Complies with ASTM F3411 OpenDroneID standard. Note: WiFi automatically suspended during broadcast, restored on stop. aerialspoofstop — Stop broadcasting fake drone RemoteID and restore WiFi. Portal\rstartportal \u0026lt;path|default\u0026gt; \u0026lt;AP_SSID\u0026gt; [PSK] — Serve an Evil Portal bundle from SD or flash (default uses the built-in portal). stopportal — Shut down the active portal. listportals — List bundles on SD card or flash. evilportal -c \u0026lt;sethtmlstr|clear\u0026gt; — Manage the Evil Portal HTML buffer (-c sethtmlstr to capture inbound HTML, -c clear to revert to defaults). webauth on|off — Require or disable web UI login. GhostLink (Dual Communication)\rcommdiscovery — Start discovery mode to find other GhostESP devices. commconnect \u0026lt;peer_name\u0026gt; — Connect to a discovered peer (after commdiscovery). commsetpins \u0026lt;tx\u0026gt; \u0026lt;rx\u0026gt; — Save preferred pins. commsend \u0026lt;command\u0026gt; [data...] — Issue commands to the connected peer. commstatus — Inspect current link state. commdisconnect — Close the peer link. Storage\rFile Operations\rsd status — Show SD card mount status, type (physical/virtual), capacity, and usage percentage. sd list [path] — List files and directories with indices for quick reference. Default path: /mnt/ghostesp. sd info \u0026lt;index|path\u0026gt; — Display file or directory details (type, size, path). sd size \u0026lt;index|path\u0026gt; — Get file size in bytes (for pre-download checks). sd read \u0026lt;index|path\u0026gt; [offset] [length] — Read file with optional offset and length for chunked downloads. No size limit. sd write \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; — Create/overwrite file with base64-decoded data. sd append \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; — Append base64-decoded data to file. sd mkdir \u0026lt;path\u0026gt; — Create a new directory. sd rm \u0026lt;index|path\u0026gt; — Delete a file or empty directory. sd tree [path] [depth] — Recursive directory listing (default depth: 2, max: 10). All sd commands return machine-parsable output with prefixes like SD:OK:, SD:ERR:, SD:FILE:[n], SD:DIR:[n]}, SD:READ:, SD:WRITE:.\nPin Configuration\rsd_config — Display SD mode, pins, and status. sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; — Configure SPI wiring. sd_pins_mmc \u0026lt;clk\u0026gt; \u0026lt;cmd\u0026gt; \u0026lt;d0\u0026gt; \u0026lt;d1\u0026gt; \u0026lt;d2\u0026gt; \u0026lt;d3\u0026gt; — Configure SDIO wiring. sd_save_config — Persist SD settings to storage. RGB\rrgbmode \u0026lt;rainbow|police|strobe|off|color\u0026gt; — Run an LED effect immediately. setrgbmode \u0026lt;normal|rainbow|stealth\u0026gt; — Persist the LED mode across reboots. setrgbpins \u0026lt;r\u0026gt; \u0026lt;g\u0026gt; \u0026lt;b\u0026gt; — Override discrete RGB GPIOs; pass the same pin for all three values to switch into single-wire NeoPixel mode on that data pin. setrgbcount \u0026lt;1-512\u0026gt; — Persist the number of RGB LEDs connected so effects span the correct length. Reinitializes immediately if pins are already configured. setneopixelbrightness \u0026lt;0-100\u0026gt; / getneopixelbrightness — Control NeoPixel intensity. Status display (if present)\rAvailable on boards with an onboard OLED status display or when an external status display is configured.\nstatusidle [list|set \u0026lt;life|ghost|0|1\u0026gt;] — View or change the status OLED idle animation when CONFIG_WITH_STATUS_DISPLAY and a status display are enabled. statusidle — Show the current idle animation and timeout. statusidle list — List available idle animations. statusidle set \u0026lt;life|ghost|0|1\u0026gt; — Select the idle animation mode. Infrared\rir list [path] — List .ir files (default: /mnt/ghostesp/infrared/remotes). ir show \u0026lt;path|remote_index\u0026gt; — Parse and display signals from an IR file. After ir list, you can pass a numeric remote index. ir send \u0026lt;path|remote_index\u0026gt; [button_index] — Transmit a signal from a file. Use remote_index from ir list and optional button_index from ir show. ir universals list [-all] — List universal IR files and, with -all, all built‑in universal signals. ir universals send \u0026lt;index\u0026gt; — Transmit a built‑in universal signal by index (see ir universals list -all). ir universals sendall \u0026lt;file|TURNHISTVOFF\u0026gt; \u0026lt;button_name\u0026gt; [delay_ms] — Transmit all signals for a named button from a universal file or the built‑in TURNHISTVOFF set; can be stopped with stop. ir rx [timeout] — Wait up to timeout seconds (default 60) for a single IR signal, print it (decoded or RAW), then stop. ir learn [path] — Wait for a signal (10s). Without path, auto-create a new .ir file under /mnt/ghostesp/infrared/remotes; with path, append the learned signal to that file. ir dazzler [stop] — Start/stop continuous IR dazzler flood. Responses are machine-parsable: IR_DAZZLER:STARTED, IR_DAZZLER:FAILED, IR_DAZZLER:ALREADY_RUNNING, IR_DAZZLER:STOPPING, IR_DAZZLER:NOT_RUNNING. [IR/BEGIN] / [IR/CLOSE] (UART IR envelope) Usage: Send [IR/BEGIN], then a single IR message body, then [IR/CLOSE] on the same UART stream to trigger a one‑off transmit.\nBody format (.ir text block): Same fields as a standard .ir file entry (for example: name, type, protocol, address, command).\nBody format (JSON): Single JSON object carrying the same information as a .ir entry (parsed signal fields or raw timing data).\nExamples:\n[IR/BEGIN] name=Power type=parsed protocol=NEC addr=0x0000FFFF cmd=0x0000E718 [IR/CLOSE] [IR/BEGIN] {\u0026#34;name\u0026#34;:\u0026#34;Power\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;parsed\u0026#34;,\u0026#34;protocol\u0026#34;:\u0026#34;NEC\u0026#34;,\u0026#34;addr\u0026#34;:\u0026#34;0x0000FFFF\u0026#34;,\u0026#34;cmd\u0026#34;:\u0026#34;0x0000E718\u0026#34;} [IR/CLOSE] CLI response on success: IR: send OK, followed by a compact summary:\nParsed: IR: signal [Name] protocol=NEC addr=0x0000FFFF cmd=0x0000E718 Raw: IR: signal raw len=N freq=38000Hz duty=0.33 GPS\rgpspin [pin] — View or set the GPS RX pin for external GPS modules. Without arguments, shows current pin. Setting persists to NVS; restart GPS commands to apply. gpsinfo [-s] — Stream current fix, satellites, and speed; pass -s to stop the display task. startwd [-s] — Start wardriving (logs Wi-Fi/GPS to CSV). Use -s to stop. Ethernet\r(Requires CONFIG_WITH_ETHERNET)\nConnection Management\rethup — Initialize and bring up Ethernet interface; waits for link establishment and DHCP assignment. ethdown — Deinitialize and bring down Ethernet interface. ethinfo — Display Ethernet connection information (status, IP address, netmask, gateway, DNS servers, DHCP server). webuiap [on|off|toggle|status] — Restrict the web UI to clients connected to the onboard AP subnet (AP-only mode). Network Scanning\rethfp — Fingerprint network hosts using mDNS, NetBIOS, and SSDP (discovers Apple devices, Chromecasts, printers, Windows PCs, routers, smart TVs). etharp — Perform ARP scan on local Ethernet network subnet (1-254) to discover active hosts. ethping — Perform ICMP ping scan on local Ethernet network subnet (1-254) to find alive hosts. ethports [ip] [all|start-end] — Scan TCP ports on a target IP address. Without arguments: scans common ports on gateway. all: scan all ports (1-65535). start-end: custom port range (e.g., 80-443). Examples: ethports, ethports 192.168.1.1, ethports 192.168.1.1 all, ethports 192.168.1.1 80-443. Network Tools\rethdns \u0026lt;hostname\u0026gt; — Perform forward DNS lookup. ethdns reverse \u0026lt;ip_address\u0026gt; — Perform reverse DNS lookup. ethtrace \u0026lt;hostname_or_ip\u0026gt; [max_hops] — Perform traceroute to a target host (default: 30 hops, max: 64). ethserv [ip_address] — Service discovery and banner grabbing on a target IP (default: gateway). Scans common services (FTP, SSH, Telnet, SMTP, HTTP, HTTPS, etc.). ethhttp \u0026lt;url\u0026gt; [lines|all] — Send HTTP/HTTPS GET request to a server and display response. Default: shows first 25 lines [lines]: show first N lines (e.g., ethhttp http://example.com 50) all: show full response (e.g., ethhttp http://example.com all) Supports both HTTP and HTTPS (TLS 1.2) Examples: ethhttp http://example.com, ethhttp https://www.google.com 100, ethhttp http://192.168.1.1/index.html all ethntp [ntp_server] — Query NTP server and synchronize system time. Default server: pool.ntp.org. Examples: ethntp, ethntp pool.ntp.org, ethntp time.google.com. Configuration\rethconfig dhcp — Use DHCP for automatic IP assignment. ethconfig static \u0026lt;ip\u0026gt; \u0026lt;netmask\u0026gt; \u0026lt;gateway\u0026gt; — Set static IP configuration. Example: ethconfig static 192.168.1.100 255.255.255.0 192.168.1.1 ethconfig show — Show current IP configuration. ethmac — Display current MAC address. ethmac set \u0026lt;xx:xx:xx:xx:xx:xx\u0026gt; — Set Ethernet MAC address (may require reinitialization). Example: ethmac set 02:00:00:00:00:01 Statistics\rethstats — Display Ethernet network statistics (link status, IP info, MAC address, packet statistics, ARP statistics). Settings\rsettings list — Dump available configuration keys. settings help — Show supported subcommands. settings get \u0026lt;key\u0026gt; / settings set \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; — Inspect or change individual options. settings reset [key] — Restore all settings or a specific key to defaults. ","description":"Common GhostESP CLI commands grouped by category.","permalink":"/v1.9/getting-started/command-line-reference/","title":"CLI Reference"},{"content":"Make HTTP requests to web servers and APIs.\nBasic HTTP GET\rFetch content from a URL:\nethhttp https://\u0026lt;url\u0026gt; \u0026lt;lines_to_show|all\u0026gt; Parameters:\n\u0026lt;url\u0026gt; — The full URL (supports http:// and https://) \u0026lt;lines_to_show\u0026gt; — Number of response lines to display, or all for complete response Examples:\nFetch the first 10 lines of a webpage:\nethhttp https://example.com 10 Fetch the entire response:\nethhttp https://example.com all Fetch from a specific path:\nethhttp https://api.example.com/status 5 Use Cases:\nAPI Testing — Query REST APIs Web Scraping — Retrieve website content Service Verification — Check if a service is responding Configuration — Fetch remote config files Troubleshooting\rConnection refused — Ensure the server is running and accessible from your network Timeout — The server may be unreachable or slow to respond SSL/TLS errors — Some servers may require specific certificates; try http:// instead of https:// ","description":"Perform HTTP GET requests from the command line.","permalink":"/latest/ethernet/http/","title":"HTTP Requests"},{"content":"Make HTTP requests to web servers and APIs.\nBasic HTTP GET\rFetch content from a URL:\nethhttp https://\u0026lt;url\u0026gt; \u0026lt;lines_to_show|all\u0026gt; Parameters:\n\u0026lt;url\u0026gt; — The full URL (supports http:// and https://) \u0026lt;lines_to_show\u0026gt; — Number of response lines to display, or all for complete response Examples:\nFetch the first 10 lines of a webpage:\nethhttp https://example.com 10 Fetch the entire response:\nethhttp https://example.com all Fetch from a specific path:\nethhttp https://api.example.com/status 5 Use Cases:\nAPI Testing — Query REST APIs Web Scraping — Retrieve website content Service Verification — Check if a service is responding Configuration — Fetch remote config files Troubleshooting\rConnection refused — Ensure the server is running and accessible from your network Timeout — The server may be unreachable or slow to respond SSL/TLS errors — Some servers may require specific certificates; try http:// instead of https:// ","description":"Perform HTTP GET requests from the command line.","permalink":"/v1.9/ethernet/http/","title":"HTTP Requests"},{"content":"\rPrerequisites\rA PN532 or Chameleon Ultra enabled build. SD card mounted with free space. Steps\rScan a tag. Complete the scan process so the popup shows results. You should see the Save button enabled once data is cached.\nTap Save. Select Save in the scan popup. You should see the title change to “Saving\u0026hellip;” and the button disable while GhostESP writes the file.\nWait for confirmation. Leave the device alone until it reads \u0026ldquo;Saved!\u0026rdquo;. You should see the title change if the save fails (for example, “Save Failed!”).\nRepeat as needed. Saved files remain accessible even after you leave the scan popup. You should see the filename follow the pattern \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc in /mnt/ghostesp/nfc/.\nChameleon Ultra Saves\rUse the CLI. After finishing chameleon scanhf, stay in the terminal and run chameleon savehf \u0026lt;name\u0026gt;. Files land in /mnt/ghostesp/chameleon/. Name files clearly. Pick short descriptive filenames without spaces, for example office_door. Verify later. Saved Chameleon dumps can be copied to a PC from your SD Card exactly like PN532 captures. Verify\rBrowse the SD card and confirm the new file exists with the expected timestamp. Re-open the scan popup and use More to ensure details still match the saved dump. Optional: load the .nfc file in a Flipper Zero to confirm compatibility. Troubleshooting\rSave button disabled. Re-scan the tag and wait for the title to show “NFC Tag”. “No SD card” error. Check card seating and filesystem. The path /mnt/ghostesp/ must be writeable. File overwriting: GhostESP auto-generates names and will overwrite if the same model/UID is scanned repeatedly. FAQ\rCan I save after removing the tag? Yes. Once the scan completes, the device keeps data in RAM, allowing offline saves. What if the tag is MIFARE Classic? GhostESP saves all recovered sectors and keys, so you can reopen the file later without re-running the dictionary attack. Where are the files stored? Under /mnt/ghostesp/nfc/. ","description":"Store scanned NFC tags as Flipper-compatible files","permalink":"/latest/nfc/saving/","title":"Saving Tags"},{"content":"\rPrerequisites\rA PN532 or Chameleon Ultra enabled build. SD card mounted with free space. Steps\rScan a tag. Complete the process in the Scan NFC Tags guide so the popup shows detailed results. You should see the Save button enabled once data is cached.\nTap Save. Select Save in the scan popup. You should see the title change to “Saving\u0026hellip;” and the button disable while GhostESP writes the file.\nWait for confirmation. Leave the device alone until the tit reads \u0026ldquo;Saved!”. You should see the title change if the save fails (for example, “Save Failed!”).\nRepeat as needed. Saved files remain accessible even after you leave the scan popup. You should see the filename follow the pattern \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc in /mnt/ghostesp/nfc/.\nChameleon Ultra Saves\rUse the CLI. After finishing chameleon scanhf, stay in the terminal and run chameleon savehf \u0026lt;name\u0026gt;. Files land in /mnt/ghostesp/chameleon/. Name files clearly. Pick short descriptive filenames without spaces, for example office_door. Verify later. Saved Chameleon dumps can be copied to a PC from your SD Card exactly like PN532 captures. Verify\rBrowse the SD card and confirm the new file exists with the expected timestamp. Re-open the scan popup and use More to ensure details still match the saved dump. Optional: load the .nfc file in a Flipper Zero to confirm compatibility. Troubleshooting\rSave button disabled. Re-scan the tag and wait for the title to show “NFC Tag”. “No SD card” error. Check card seating and filesystem. The path /mnt/ghostesp/ must be writeable. File overwriting unexpectedly. GhostESP auto-generates names and will overwrite if the same model/UID combination is scanned repeatedly. FAQ\rCan I save after removing the tag? Yes. Once the scan completes, the device keeps data in RAM, allowing offline saves. What if the tag is MIFARE Classic? GhostESP saves all recovered sectors and keys, so you can reopen the file later without re-running the dictionary attack. Where are the files stored? Under /mnt/ghostesp/nfc/. ","description":"Store scanned NFC tags as Flipper-compatible files","permalink":"/v1.8.1/nfc/saving/","title":"Saving Tags"},{"content":"\rPrerequisites\rA PN532 or Chameleon Ultra enabled build. SD card mounted with free space. Steps\rScan a tag. Complete the process in the Scan NFC Tags guide so the popup shows detailed results. You should see the Save button enabled once data is cached.\nTap Save. Select Save in the scan popup. You should see the title change to “Saving\u0026hellip;” and the button disable while GhostESP writes the file.\nWait for confirmation. Leave the device alone until the tit reads \u0026ldquo;Saved!”. You should see the title change if the save fails (for example, “Save Failed!”).\nRepeat as needed. Saved files remain accessible even after you leave the scan popup. You should see the filename follow the pattern \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc in /mnt/ghostesp/nfc/.\nChameleon Ultra Saves\rUse the CLI. After finishing chameleon scanhf, stay in the terminal and run chameleon savehf \u0026lt;name\u0026gt;. Files land in /mnt/ghostesp/chameleon/. Name files clearly. Pick short descriptive filenames without spaces, for example office_door. Verify later. Saved Chameleon dumps can be copied to a PC from your SD Card exactly like PN532 captures. Verify\rBrowse the SD card and confirm the new file exists with the expected timestamp. Re-open the scan popup and use More to ensure details still match the saved dump. Optional: load the .nfc file in a Flipper Zero to confirm compatibility. Troubleshooting\rSave button disabled. Re-scan the tag and wait for the title to show “NFC Tag”. “No SD card” error. Check card seating and filesystem. The path /mnt/ghostesp/ must be writeable. File overwriting unexpectedly. GhostESP auto-generates names and will overwrite if the same model/UID combination is scanned repeatedly. FAQ\rCan I save after removing the tag? Yes. Once the scan completes, the device keeps data in RAM, allowing offline saves. What if the tag is MIFARE Classic? GhostESP saves all recovered sectors and keys, so you can reopen the file later without re-running the dictionary attack. Where are the files stored? Under /mnt/ghostesp/nfc/. ","description":"Store scanned NFC tags as Flipper-compatible files","permalink":"/v1.8/nfc/saving/","title":"Saving Tags"},{"content":"\rPrerequisites\rA PN532 or Chameleon Ultra enabled build. SD card mounted with free space. Steps\rScan a tag. Complete the scan process so the popup shows results. You should see the Save button enabled once data is cached.\nTap Save. Select Save in the scan popup. You should see the title change to “Saving\u0026hellip;” and the button disable while GhostESP writes the file.\nWait for confirmation. Leave the device alone until it reads \u0026ldquo;Saved!\u0026rdquo;. You should see the title change if the save fails (for example, “Save Failed!”).\nRepeat as needed. Saved files remain accessible even after you leave the scan popup. You should see the filename follow the pattern \u0026lt;Model\u0026gt;_\u0026lt;UID\u0026gt;.nfc in /mnt/ghostesp/nfc/.\nChameleon Ultra Saves\rUse the CLI. After finishing chameleon scanhf, stay in the terminal and run chameleon savehf \u0026lt;name\u0026gt;. Files land in /mnt/ghostesp/chameleon/. Name files clearly. Pick short descriptive filenames without spaces, for example office_door. Verify later. Saved Chameleon dumps can be copied to a PC from your SD Card exactly like PN532 captures. Verify\rBrowse the SD card and confirm the new file exists with the expected timestamp. Re-open the scan popup and use More to ensure details still match the saved dump. Optional: load the .nfc file in a Flipper Zero to confirm compatibility. Troubleshooting\rSave button disabled. Re-scan the tag and wait for the title to show “NFC Tag”. “No SD card” error. Check card seating and filesystem. The path /mnt/ghostesp/ must be writeable. File overwriting: GhostESP auto-generates names and will overwrite if the same model/UID is scanned repeatedly. FAQ\rCan I save after removing the tag? Yes. Once the scan completes, the device keeps data in RAM, allowing offline saves. What if the tag is MIFARE Classic? GhostESP saves all recovered sectors and keys, so you can reopen the file later without re-running the dictionary attack. Where are the files stored? Under /mnt/ghostesp/nfc/. ","description":"Store scanned NFC tags as Flipper-compatible files","permalink":"/v1.9/nfc/saving/","title":"Saving Tags"},{"content":"\rSend a saved command\rOpen Infrared and browse Remotes to see saved .ir files. Pick a Flipper-compatible .ir file. GhostESP parses the sections inside the file and lists every named button. Tap a button entry to transmit. The configured LED should flash pink if not in stealth mode. Tip: If you see “No .ir files” in the Remotes or Universals lists, try reinserting your SD card and rebooting the device. Ensure the /ghostesp/infrared/remotes and /ghostesp/infrared/universals folders exist on the card.\nUniversal libraries\rUniversal .ir packs live under /ghostesp/infrared/universals and contain large collections of commands grouped by device. When you open a universal file, GhostESP scans the command list and prompts you to pick a specific button to send. Parsing very large libraries (for example, community dumps) can take several seconds; wait for the list to finish populating before selecting. You can find supported universals at Momentum Flipper Firmware. Download and place the files under infrared/universals. GhostESP also includes a built-in Universal IR file with popular TV POWER signals. Use the TURNHISTVOFF universal to turn on or off many different TVs.\nTips\rAim the LED directly at the target\u0026rsquo;s receiver window. If nothing happens, close the popup, verify you chose the right protocol (raw vs decoded), and relearn the button or test another signal. Ensure no bright sunlight hits the receiver; ambient infrared noise can reduce range. CLI Support\rYou can transmit signals using the command line interface, which is useful for scripting or automation.\nSending from file\rUse ir send to transmit a signal from an existing .ir file:\n# Send the first signal in the file\rir send /ghostesp/infrared/remotes/TV.ir\r# Send the 3rd signal (index 2)\rir send /ghostesp/infrared/remotes/TV.ir 2 Inline Sending\rYou can send raw or parsed signals directly without a file using the inline mode markers. This is useful for sending commands from a script or external tool.\nText Format:\n[IR/BEGIN] name: Power type: parsed protocol: NEC address: FF 00 command: E7 18 [IR/CLOSE] JSON Format:\n[IR/BEGIN] {\u0026#34;type\u0026#34;:\u0026#34;parsed\u0026#34;,\u0026#34;protocol\u0026#34;:\u0026#34;NEC\u0026#34;,\u0026#34;address\u0026#34;:65280,\u0026#34;command\u0026#34;:59160} [IR/CLOSE] See the CLI Reference for full command details.\n","description":"Send captured or universal IR commands","permalink":"/latest/infrared/transmitting/","title":"Transmitting Signals"},{"content":"\rSend a saved command\rOpen the Infrared view and browse the Remotes list to see .ir files stored on the SD card. Pick a Flipper-compatible .ir file. GhostESP parses the sections inside the file and lists every named button. Tap a button entry to transmit. The configured LED should flash pink if not in stealth mode. Tip: If you see “No .ir files” in the Remotes or Universals lists, try reinserting your SD card and rebooting the device. Ensure the /ghostesp/infrared/remotes and /ghostesp/infrared/universals folders exist on the card.\nUniversal libraries\rUniversal .ir packs live under /ghostesp/infrared/universals and contain large collections of commands grouped by device. When you open a universal file, GhostESP scans the command list and prompts you to pick a specific button to send. Parsing very large libraries (for example, community dumps) can take several seconds; wait for the list to finish populating before selecting. You can find supported universals at Momentum Flipper Firmware. Download and place the files under infrared/universals. Universal IR Database\rGhostESP also includes a built-in Universal IR file with popular TV POWER signals. Use the TURNHISTVOFF universal to turn on or off many different TVs.\nTips\rAim the device’s IR LED directly at the target device’s receiver window and stay within a few meters. If nothing happens, close the popup, verify you chose the right protocol (raw vs decoded), and relearn the button or test another signal. Ensure no bright sunlight hits the receiver; ambient infrared noise can reduce range. ","description":"Send captured or universal IR commands","permalink":"/v1.8.1/infrared/transmitting/","title":"Transmitting Signals"},{"content":"\rSend a saved command\rOpen the Infrared view and browse the Remotes list to see .ir files stored on the SD card. Pick a Flipper-compatible .ir file. GhostESP parses the sections inside the file and lists every named button. Tap a button entry to transmit. The configured LED should flash pink if not in stealth mode. Universal libraries\rUniversal .ir packs live under /ghostesp/infrared/universals and contain large collections of commands grouped by device. When you open a universal file, GhostESP scans the command list and prompts you to pick a specific button to send. Parsing very large libraries (for example, community dumps) can take several seconds; wait for the list to finish populating before selecting. You can find supported universals at Momentum Flipper Firmware. Download and place the files under infrared/universals. Tips\rAim the device’s IR LED directly at the target device’s receiver window and stay within a few meters. If nothing happens, close the popup, verify you chose the right protocol (raw vs decoded), and relearn the button or test another signal. Ensure no bright sunlight hits the receiver; ambient infrared noise can reduce range. ","description":"Send captured or universal IR commands","permalink":"/v1.8/infrared/transmitting/","title":"Transmitting Signals"},{"content":"\rSend a saved command\rOpen Infrared and browse Remotes to see saved .ir files. Pick a Flipper-compatible .ir file. GhostESP parses the sections inside the file and lists every named button. Tap a button entry to transmit. The configured LED should flash pink if not in stealth mode. Tip: If you see “No .ir files” in the Remotes or Universals lists, try reinserting your SD card and rebooting the device. Ensure the /ghostesp/infrared/remotes and /ghostesp/infrared/universals folders exist on the card.\nUniversal libraries\rUniversal .ir packs live under /ghostesp/infrared/universals and contain large collections of commands grouped by device. When you open a universal file, GhostESP scans the command list and prompts you to pick a specific button to send. Parsing very large libraries (for example, community dumps) can take several seconds; wait for the list to finish populating before selecting. You can find supported universals at Momentum Flipper Firmware. Download and place the files under infrared/universals. GhostESP also includes a built-in Universal IR file with popular TV POWER signals. Use the TURNHISTVOFF universal to turn on or off many different TVs.\nTips\rAim the LED directly at the target\u0026rsquo;s receiver window. If nothing happens, close the popup, verify you chose the right protocol (raw vs decoded), and relearn the button or test another signal. Ensure no bright sunlight hits the receiver; ambient infrared noise can reduce range. CLI Support\rYou can transmit signals using the command line interface, which is useful for scripting or automation.\nSending from file\rUse ir send to transmit a signal from an existing .ir file:\n# Send the first signal in the file\rir send /ghostesp/infrared/remotes/TV.ir\r# Send the 3rd signal (index 2)\rir send /ghostesp/infrared/remotes/TV.ir 2 Inline Sending\rYou can send raw or parsed signals directly without a file using the inline mode markers. This is useful for sending commands from a script or external tool.\nText Format:\n[IR/BEGIN] name: Power type: parsed protocol: NEC address: FF 00 command: E7 18 [IR/CLOSE] JSON Format:\n[IR/BEGIN] {\u0026#34;type\u0026#34;:\u0026#34;parsed\u0026#34;,\u0026#34;protocol\u0026#34;:\u0026#34;NEC\u0026#34;,\u0026#34;address\u0026#34;:65280,\u0026#34;command\u0026#34;:59160} [IR/CLOSE] See the CLI Reference for full command details.\n","description":"Send captured or universal IR commands","permalink":"/v1.9/infrared/transmitting/","title":"Transmitting Signals"},{"content":"Deauthentication (deauth) attacks force devices to disconnect from a Wi-Fi network. This is useful for testing network resilience or capturing authentication handshakes when devices reconnect.\nNote: Only perform deauth attacks on networks you own or have explicit permission to test. Disrupting networks without authorization is illegal.\nHow it works\rWi-Fi networks use management frames to coordinate connections. Two of these frames can terminate a connection:\nDeauthentication frame: Ends the authentication relationship Disassociation frame: Ends the association relationship GhostESP sends both frame types. Since these frames are part of the original Wi-Fi standard (802.11), most devices have no way to verify if the message is legitimate.\nBroadcast and targeted attacks\rThe attack sends frames in two ways:\nBroadcast (FF:FF:FF:FF:FF:FF): Hits all devices on the network without needing to know who\u0026rsquo;s connected Targeted: If you\u0026rsquo;ve scanned for stations (scansta), GhostESP automatically includes any discovered clients associated with the selected AP Bidirectional frames\rFor targeted stations, GhostESP sends frames in both directions:\nAP → Station: Appears to come from the access point, telling the device to disconnect Station → AP: Appears to come from the device, telling the AP the device is leaving This makes the attack more reliable since both sides think the connection ended.\nFrequency band limitations\r2.4 GHz only (most boards)\rMost ESP32 boards (ESP32, ESP32-S2, ESP32-S3, ESP32-C3, ESP32-C6) only support 2.4 GHz Wi-Fi. This means:\nYou can only deauth networks on channels 1–14 5 GHz networks are invisible and unaffected Many modern routers use both bands—devices on the 5 GHz band will stay connected 5 GHz support (ESP32-C5)\rThe ESP32-C5 supports both 2.4 GHz and 5 GHz bands, allowing you to:\nScan and attack networks on all Wi-Fi channels Target devices on 5 GHz networks If your target network uses 5 GHz, you need an ESP32-C5 based device.\nProtected Management Frames (PMF)\rPMF (also called MFP or 802.11w) is a security feature that cryptographically signs management frames. When enabled, devices can verify that deauth frames actually came from the real access point.\nNetworks immune to deauth\rWPA3 networks: PMF is mandatory. Deauth attacks will not work. WPA2/WPA3 mixed mode: Devices using WPA3 are protected; WPA2 devices may still be vulnerable. WPA2 with PMF enabled: Some enterprise networks enable PMF on WPA2. How to check\rWhen you scan networks on an ESP32-C5 or ESP32-C6, GhostESP shows the security type and PMF status:\nSSID: MyNetwork\rBand: 2.4GHz\rSecurity: WPA3\rPMF: Required If you see PMF: Required, deauth attacks will have no effect on that network.\nPrerequisites\rGhostESP device Target network on a supported frequency band (2.4 GHz for most boards, or 5 GHz with ESP32-C5) Country code set in device settings (see Troubleshooting if you get errors) Launching a deauth attack\rOn-device UI\rOpen Menu → WiFi → Scanning and wait for the scan to complete. Select your target with Select AP. Open Menu → WiFi → Attacks → Deauth. The device will continuously send deauth frames to all clients on that network. To stop, navigate to Menu → WiFi → Attacks → Stop Attack or run stopdeauth. Command line\rScan for networks: scanap List results: list -a Select your target (replace 1 with the network number): select -a 1 Start the attack: attack -d Stop the attack: stopdeauth Targeting multiple networks\rYou can select multiple access points at once:\nselect -a 1,3,5\rattack -d GhostESP groups APs by channel to minimize channel-switching overhead. APs on the same channel are attacked together before moving to the next channel.\nTroubleshooting\rESP_ERR_INVALID_ARG when deauthing\rThis error occurs when attempting to deauth a network on a channel not allowed by your current country code setting. By default, GhostESP uses \u0026ldquo;World Safe\u0026rdquo; mode (01) which only permits channels 1–11.\nIf your target network is on channel 12, 13, or 14, you must set the correct country code first.\nFix via on-device UI:\nOpen Menu → Settings → WiFi Country. Select your region. Restart the device. Fix via CLI (ESP32-C5 only):\nsetcountry \u0026lt;CC\u0026gt; Replace \u0026lt;CC\u0026gt; with one of the supported country codes:\nCode Region Code Region Code Region 01 World Safe AT Austria AU Australia BE Belgium BG Bulgaria BR Brazil CA Canada CH Switzerland CN China CY Cyprus CZ Czechia DE Germany DK Denmark EE Estonia ES Spain FI Finland FR France GB United Kingdom GR Greece HK Hong Kong HR Croatia HU Hungary IE Ireland IN India IS Iceland IT Italy JP Japan KR South Korea LI Liechtenstein LT Lithuania LU Luxembourg LV Latvia MT Malta MX Mexico NL Netherlands NO Norway NZ New Zealand PL Poland PT Portugal RO Romania SE Sweden SI Slovenia SK Slovakia TW Taiwan US United States Channel availability by region:\nUS, Canada (US, CA): Channels 1–11 Europe, Australia (GB, DE, AU, etc.): Channels 1–13 Japan (JP): Channels 1–14 Attack has no effect\rCheck the band: If the network is on 5 GHz and you\u0026rsquo;re using a 2.4 GHz-only board, the attack won\u0026rsquo;t work. Check for PMF: WPA3 networks and some WPA2 networks with PMF enabled are immune. Multiple APs: Some networks have multiple access points. You may need to target each one separately. Distance: Get closer to the access point for a stronger signal. Devices reconnect immediately\rDevices reconnect immediately after being kicked. If they keep getting back on:\nMake sure you\u0026rsquo;re only targeting one or two networks Move closer to the access point Check for other interference Cannot see 5 GHz networks\rYour board only supports 2.4 GHz. Use an ESP32-C5 based device to access 5 GHz networks.\nRelated attacks\rEAPOL Logoff (attack -e): Sends logoff frames instead of deauth frames. Works similarly but uses a different frame type. SAE Flood (attack -s): Floods WPA3 networks with authentication requests. Only available on ESP32-C5/C6. ","description":"Force devices to disconnect from a Wi-Fi network.","permalink":"/latest/wifi/deauth/","title":"Deauthentication Attacks"},{"content":"Deauthentication (deauth) attacks force devices to disconnect from a Wi-Fi network. This is useful for testing network resilience or capturing authentication handshakes when devices reconnect.\nNote: Only perform deauth attacks on networks you own or have explicit permission to test. Disrupting networks without authorization is illegal.\nHow it works\rWi-Fi networks use management frames to coordinate connections. Two of these frames can terminate a connection:\nDeauthentication frame: Ends the authentication relationship Disassociation frame: Ends the association relationship GhostESP sends both frame types. Since these frames are part of the original Wi-Fi standard (802.11), most devices have no way to verify if the message is legitimate.\nBroadcast and targeted attacks\rThe attack sends frames in two ways:\nBroadcast (FF:FF:FF:FF:FF:FF): Hits all devices on the network without needing to know who\u0026rsquo;s connected Targeted: If you\u0026rsquo;ve scanned for stations (scansta), GhostESP automatically includes any discovered clients associated with the selected AP Bidirectional frames\rFor targeted stations, GhostESP sends frames in both directions:\nAP → Station: Appears to come from the access point, telling the device to disconnect Station → AP: Appears to come from the device, telling the AP the device is leaving This makes the attack more reliable since both sides think the connection ended.\nFrequency band limitations\r2.4 GHz only (most boards)\rMost ESP32 boards (ESP32, ESP32-S2, ESP32-S3, ESP32-C3, ESP32-C6) only support 2.4 GHz Wi-Fi. This means:\nYou can only deauth networks on channels 1–14 5 GHz networks are invisible and unaffected Many modern routers use both bands—devices on the 5 GHz band will stay connected 5 GHz support (ESP32-C5)\rThe ESP32-C5 supports both 2.4 GHz and 5 GHz bands, allowing you to:\nScan and attack networks on all Wi-Fi channels Target devices on 5 GHz networks If your target network uses 5 GHz, you need an ESP32-C5 based device.\nProtected Management Frames (PMF)\rPMF (also called MFP or 802.11w) is a security feature that cryptographically signs management frames. When enabled, devices can verify that deauth frames actually came from the real access point.\nNetworks immune to deauth\rWPA3 networks: PMF is mandatory. Deauth attacks will not work. WPA2/WPA3 mixed mode: Devices using WPA3 are protected; WPA2 devices may still be vulnerable. WPA2 with PMF enabled: Some enterprise networks enable PMF on WPA2. How to check\rWhen you scan networks on an ESP32-C5 or ESP32-C6, GhostESP shows the security type and PMF status:\nSSID: MyNetwork\rBand: 2.4GHz\rSecurity: WPA3\rPMF: Required If you see PMF: Required, deauth attacks will have no effect on that network.\nPrerequisites\rGhostESP device Target network on a supported frequency band (2.4 GHz for most boards, or 5 GHz with ESP32-C5) Country code set in device settings (see Troubleshooting if you get errors) Launching a deauth attack\rOn-device UI\rOpen Menu → WiFi → Scanning and wait for the scan to complete. Select your target with Select AP. Open Menu → WiFi → Attacks → Deauth. The device will continuously send deauth frames to all clients on that network. To stop, navigate to Menu → WiFi → Attacks → Stop Attack or run stopdeauth. Command line\rScan for networks: scanap List results: list -a Select your target (replace 1 with the network number): select -a 1 Start the attack: attack -d Stop the attack: stopdeauth Targeting multiple networks\rYou can select multiple access points at once:\nselect -a 1,3,5\rattack -d GhostESP groups APs by channel to minimize channel-switching overhead. APs on the same channel are attacked together before moving to the next channel.\nTroubleshooting\rESP_ERR_INVALID_ARG when deauthing\rThis error occurs when attempting to deauth a network on a channel not allowed by your current country code setting. By default, GhostESP uses \u0026ldquo;World Safe\u0026rdquo; mode (01) which only permits channels 1–11.\nIf your target network is on channel 12, 13, or 14, you must set the correct country code first.\nFix via on-device UI:\nOpen Menu → Settings → WiFi Country. Select your region. Restart the device. Fix via CLI (ESP32-C5 only):\nsetcountry \u0026lt;CC\u0026gt; Replace \u0026lt;CC\u0026gt; with one of the supported country codes:\nCode Region Code Region Code Region 01 World Safe AT Austria AU Australia BE Belgium BG Bulgaria BR Brazil CA Canada CH Switzerland CN China CY Cyprus CZ Czechia DE Germany DK Denmark EE Estonia ES Spain FI Finland FR France GB United Kingdom GR Greece HK Hong Kong HR Croatia HU Hungary IE Ireland IN India IS Iceland IT Italy JP Japan KR South Korea LI Liechtenstein LT Lithuania LU Luxembourg LV Latvia MT Malta MX Mexico NL Netherlands NO Norway NZ New Zealand PL Poland PT Portugal RO Romania SE Sweden SI Slovenia SK Slovakia TW Taiwan US United States Channel availability by region:\nUS, Canada (US, CA): Channels 1–11 Europe, Australia (GB, DE, AU, etc.): Channels 1–13 Japan (JP): Channels 1–14 Attack has no effect\rCheck the band: If the network is on 5 GHz and you\u0026rsquo;re using a 2.4 GHz-only board, the attack won\u0026rsquo;t work. Check for PMF: WPA3 networks and some WPA2 networks with PMF enabled are immune. Multiple APs: Some networks have multiple access points. You may need to target each one separately. Distance: Get closer to the access point for a stronger signal. Devices reconnect immediately\rDevices reconnect immediately after being kicked. If they keep getting back on:\nMake sure you\u0026rsquo;re only targeting one or two networks Move closer to the access point Check for other interference Cannot see 5 GHz networks\rYour board only supports 2.4 GHz. Use an ESP32-C5 based device to access 5 GHz networks.\nRelated attacks\rEAPOL Logoff (attack -e): Sends logoff frames instead of deauth frames. Works similarly but uses a different frame type. SAE Flood (attack -s): Floods WPA3 networks with authentication requests. Only available on ESP32-C5/C6. ","description":"Force devices to disconnect from a Wi-Fi network.","permalink":"/v1.9/wifi/deauth/","title":"Deauthentication Attacks"},{"content":"\rOverview\rIR Dazzler emits continuous IR at 38 kHz to overwhelm night-vision cameras. Runs in hardware with minimal CPU use.\nNote: Continuous IR can warm the LED and draw more current. Stop when not in use.\nUse from the UI\rOpen the Infrared view. Select IR Dazzler. A popup appears and the LED begins emitting. To stop, press the on-screen Stop button or press any enter/confirm input (touch, joystick, encoder, keyboard) while the popup is active. The dazzler also stops automatically when you leave the Infrared view or run the global stop command.\nUse from the CLI\rir dazzler # start\rir dazzler stop # stop The stop command also halts any active dazzler session.\nCompatibility\rRequires a board built with IR transmit hardware; the feature is hidden when CONFIG_HAS_INFRARED is off. Uses the configured IR LED pin (CONFIG_INFRARED_LED_PIN) with a 38 kHz carrier and high duty cycle flood. ","description":"Continuous IR flood mode for camera interference","permalink":"/latest/infrared/dazzler/","title":"IR Dazzler"},{"content":"\rOverview\rIR Dazzler emits continuous IR at 38 kHz to overwhelm night-vision cameras. Runs in hardware with minimal CPU use.\nNote: Continuous IR can warm the LED and draw more current. Stop when not in use.\nUse from the UI\rOpen the Infrared view. Select IR Dazzler. A popup appears and the LED begins emitting. To stop, press the on-screen Stop button or press any enter/confirm input (touch, joystick, encoder, keyboard) while the popup is active. The dazzler also stops automatically when you leave the Infrared view or run the global stop command.\nUse from the CLI\rir dazzler # start\rir dazzler stop # stop The stop command also halts any active dazzler session.\nCompatibility\rRequires a board built with IR transmit hardware; the feature is hidden when CONFIG_HAS_INFRARED is off. Uses the configured IR LED pin (CONFIG_INFRARED_LED_PIN) with a 38 kHz carrier and high duty cycle flood. ","description":"Continuous IR flood mode for camera interference","permalink":"/v1.9/infrared/dazzler/","title":"IR Dazzler"},{"content":"Use your GhostESP as a USB wireless capture dongle for Wireshark. Instead of saving packets to an SD card, the device streams Wi-Fi and BLE traffic directly to your computer in real-time—just like a commercial Wi-Fi adapter in monitor mode.\nThis is perfect for live analysis, debugging networks, or learning how wireless protocols work without needing expensive hardware.\nPrerequisites\rGhostESP device connected via USB to your computer Wireshark installed on your computer Setup\rOption 1: GUI Installer (Recommended)\rThe easiest way to install is using the GUI installer, which automatically handles dependencies and installation:\nNavigate to scripts/wireshark_extcap_installer/ in your GhostESP repository Run the installer: python installer_gui.py Click Install in the GUI Restart Wireshark The installer will automatically:\nDetect your Wireshark installation Install the extcap files to the correct location Set up all required dependencies in an isolated environment Option 2: Manual Installation\rIf you prefer manual installation:\nPrerequisites for manual installation:\nPython 3.7+ installed pyserial Python package (pip install pyserial) Installation steps:\nCopy the extcap files to your Wireshark extcap folder:\nWindows: %APPDATA%\\Wireshark\\extcap\\ macOS: ~/.local/lib/wireshark/extcap/ Linux: ~/.local/lib/wireshark/extcap/ Files to copy from scripts/wireshark_extcap_installer/:\nghostesp_extcap.py ghostesp_extcap.bat (Windows only) Make the script executable (macOS/Linux only):\nchmod +x ~/.local/lib/wireshark/extcap/ghostesp_extcap.py Restart Wireshark.\nVerify installation\rOpen Wireshark. Go to Capture → Options or click the gear icon. Look for GhostESP WiFi/BLE Capture in the interface list. If you don\u0026rsquo;t see it, check that the files are in the correct extcap folder and Python is in your PATH. Capturing Wi-Fi traffic\rStart capture in Wireshark\rIn Wireshark, find GhostESP WiFi/BLE Capture in the interface list. Click the gear icon next to it to configure: Serial Port: Select your GhostESP COM port Baud Rate: Leave at 115200 (default) Capture Type: Select WiFi Channel Lock: Choose between: Auto (channel hopping): Continuously hop through all channels (default) Channel 1-13: Lock to a specific WiFi channel for focused capture Click Start to begin capturing. The GhostESP will automatically:\nEnter monitor mode Start capture based on your Channel Lock setting: Auto mode: Channel hop through all legal channels (150ms per channel) Fixed channel: Monitor only the selected channel continuously Stream packets in real-time to Wireshark What you\u0026rsquo;ll see\rWireshark will display:\nBeacon frames: Access points advertising their SSIDs Probe requests: Devices searching for known networks Data frames: Encrypted Wi-Fi traffic Management frames: Association, authentication, deauth Control frames: ACKs, RTS/CTS Channel hopping vs. Channel lock\rAuto (Channel Hopping)\nContinuously hops through all legal channels for your country 2.4 GHz: Channels 1-13 (or 1-14 for Japan) 5 GHz (ESP32-C5/C6 only): Country-specific channels US/CA: All UNII bands (36-165) EU: UNII-1, 2a, 2c (36-140) JP: UNII-1, 2a, 2c (36-140, no 165) CN: UNII-1, 2a, 3 (36-64, 149-165) Best for general surveillance and discovering networks Set your country with the setcountry command before starting capture Fixed Channel Lock\nMonitors only the selected channel continuously Higher packet capture rate on the target channel Ideal for: Analyzing traffic on a known network Capturing handshakes from a specific AP Debugging connectivity issues Following a specific conversation Set your country with the setcountry command before starting capture.\nStop capture\rClick the red Stop button in Wireshark or run capture -stop on the GhostESP terminal.\nCapturing BLE traffic\rStart BLE capture\rIn Wireshark, configure GhostESP WiFi/BLE Capture: Serial Port: Select your GhostESP COM port Capture Type: Select Bluetooth LE Click Start. The GhostESP will stream BLE advertising packets to Wireshark.\nWhat you\u0026rsquo;ll see\rWireshark will decode:\nLE Advertising Reports: Device advertisements with names, UUIDs, manufacturer data RSSI values: Signal strength for each packet MAC addresses: Device identifiers (public or random) Advertisement data: Service UUIDs, local names, flags Stop capture\rClick Stop in Wireshark or run capture -stop on the device.\nCommand line alternative\rYou can also start Wireshark mode from the GhostESP terminal without using the Wireshark interface:\nWi-Fi capture\rcapture -wireshark [-c \u0026lt;channel\u0026gt;] -c \u0026lt;channel\u0026gt;: Optional channel lock (1-13) Without -c: Auto channel hopping With -c: Lock to specific channel BLE capture\rcapture -wiresharkble Stop capture\rcapture -stop When using command line mode, you\u0026rsquo;ll need to manually configure Wireshark to capture from the serial port.\nTroubleshooting\rInterface not showing in Wireshark\rVerify the extcap files are in the correct folder Check that Python is installed and in your system PATH Restart Wireshark after copying the files Run python ghostesp_extcap.py --extcap-interfaces in the extcap folder to test No packets appearing\rConfirm the correct COM port is selected Check that the GhostESP is connected and powered on Verify the device responds to serial commands Try increasing the baud rate if packets are being dropped Malformed packets in Wi-Fi capture\rThis is normal for promiscuous mode capture The ESP32 captures everything including corrupted frames and radio noise Valid packets will appear alongside malformed ones Use Wireshark filters to focus on valid frames Slow packet rate\rUSB serial has limited throughput (~11 KB/s at 115200 baud) High-traffic environments may drop packets Channel hopping reduces time on each channel This is expected behavior for live capture Country setting not applied\rRun setcountry \u0026lt;code\u0026gt; before starting capture (e.g., setcountry US) Restart the device after changing country Verify with info command that country is set correctly Notes\rWireshark mode streams packets over USB/UART without saving to SD card The device automatically handles PCAP formatting and headers Auto mode: Channel hopping covers the full spectrum but reduces dwell time per channel Fixed channel: Higher packet capture rate on the selected channel For focused capture on a single channel, use either Channel Lock setting or file-based capture modes BLE capture does not hop channels (BLE uses 3 advertising channels: 37, 38, 39) Channel lock is only available for WiFi capture, not BLE Next steps\rCapturing packets to file — Save captures to SD card for later analysis Handshakes — Extract WPA/WPA2 authentication data Survey — Scan for networks and devices ","description":"Use GhostESP as a wireless capture dongle for Wireshark.","permalink":"/latest/wifi/wireshark/","title":"USB Dongle Mode (Wireshark)"},{"content":"Capture Wi-Fi authentication handshakes from nearby networks.\nLegal note: Only capture traffic from networks you own or have explicit permission to test. Unauthorized network testing is illegal in most jurisdictions.\nPrerequisites\rGhostESP with SD card mounted (for saving captures). A device to connect to the target network (so it can authenticate and create a handshake). Capturing a handshake\rOn-device UI\rOpen Menu → WiFi → Scanning and find your target network. Select it with Select AP to lock onto that channel. Open Menu → WiFi → Capture → Capture Eapol. The device will start listening for authentication activity. Wait for a device to connect or reconnect to the network. You should see Handshake found! when the capture succeeds. Back out to stop capturing. The capture is saved to the SD card under /mnt/ghostesp/pcaps/. Command line\rRun list -a to see nearby networks. Run select -a \u0026lt;number\u0026gt; to lock onto your target network. Run capture -eapol to start listening. Wait for a device to authenticate to the network. You should see Handshake found! when successful. Run stop to finish capturing. The file location will be shown in the log. Next steps\rCopy the .pcap file from the device to your computer for further analysis. For Flipper Zero saved files, copy the file from /ext/apps_data/ghost_esp/pcaps/ on the Flipper\u0026rsquo;s SD card. Troubleshooting\rNo handshake found: Make sure a device is actually connecting to the network. Try toggling Wi-Fi off and on on a connected device to trigger a new authentication. Capture file missing: Verify the SD card is mounted and has free space. Check that you stopped the capture. ","description":"Record Wi-Fi authentication data for analysis.","permalink":"/latest/wifi/handshakes/","title":"Capturing handshakes"},{"content":"Capture Wi-Fi authentication handshakes from nearby networks.\nLegal note: Only capture traffic from networks you own or have explicit permission to test. Unauthorized network testing is illegal in most jurisdictions.\nPrerequisites\rGhostESP with SD card mounted (for saving captures). A device to connect to the target network (so it can authenticate and create a handshake). Capturing a handshake\rOn-device UI\rOpen Menu → WiFi → Scanning and find your target network. Select it with Select AP to lock onto that channel. Open Menu → WiFi → Capture → Capture Eapol. The device will start listening for authentication activity. Wait for a device to connect or reconnect to the network. You should see Handshake found! when the capture succeeds. Back out to stop capturing. The capture is saved to the SD card under /mnt/ghostesp/pcaps/. Command line\rRun list -a to see nearby networks. Run select -a \u0026lt;number\u0026gt; to lock onto your target network. Run capture -eapol to start listening. Wait for a device to authenticate to the network. You should see Handshake found! when successful. Run stop to finish capturing. The file location will be shown in the log. Next steps\rCopy the .pcap file from the device to your computer for further analysis. For Flipper Zero saved files, copy the file from /ext/apps_data/ghost_esp/pcaps/ on the Flipper\u0026rsquo;s SD card. Troubleshooting\rNo handshake found: Make sure a device is actually connecting to the network. Try toggling Wi-Fi off and on on a connected device to trigger a new authentication. Capture file missing: Verify the SD card is mounted and has free space. Check that you stopped the capture. ","description":"Record Wi-Fi authentication data for analysis.","permalink":"/v1.8.1/wifi/handshakes/","title":"Capturing handshakes"},{"content":"Capture Wi-Fi authentication handshakes from nearby networks.\nLegal note: Only capture traffic from networks you own or have explicit permission to test. Unauthorized network testing is illegal in most jurisdictions.\nPrerequisites\rGhostESP with SD card mounted (for saving captures). A device to connect to the target network (so it can authenticate and create a handshake). Capturing a handshake\rOn-device UI\rOpen Menu → WiFi → Scanning and find your target network. Select it with Select AP to lock onto that channel. Open Menu → WiFi → Capture → Capture Eapol. The device will start listening for authentication activity. Wait for a device to connect or reconnect to the network. You should see Handshake found! when the capture succeeds. Back out to stop capturing. The capture is saved to the SD card under /mnt/ghostesp/pcaps/. Command line\rRun list -a to see nearby networks. Run select -a \u0026lt;number\u0026gt; to lock onto your target network. Run capture -eapol to start listening. Wait for a device to authenticate to the network. You should see Handshake found! when successful. Run stop to finish capturing. The file location will be shown in the log. Next steps\rCopy the .pcap file from the device to your computer for further analysis. For Flipper Zero saved files, copy the file from /ext/apps_data/ghost_esp/pcaps/ on the Flipper\u0026rsquo;s SD card. Troubleshooting\rNo handshake found: Make sure a device is actually connecting to the network. Try toggling Wi-Fi off and on on a connected device to trigger a new authentication. Capture file missing: Verify the SD card is mounted and has free space. Check that you stopped the capture. ","description":"Record Wi-Fi authentication data for analysis.","permalink":"/v1.8/wifi/handshakes/","title":"Capturing handshakes"},{"content":"Capture Wi-Fi authentication handshakes from nearby networks.\nLegal note: Only capture traffic from networks you own or have explicit permission to test. Unauthorized network testing is illegal in most jurisdictions.\nPrerequisites\rGhostESP with SD card mounted (for saving captures). A device to connect to the target network (so it can authenticate and create a handshake). Capturing a handshake\rOn-device UI\rOpen Menu → WiFi → Scanning and find your target network. Select it with Select AP to lock onto that channel. Open Menu → WiFi → Capture → Capture Eapol. The device will start listening for authentication activity. Wait for a device to connect or reconnect to the network. You should see Handshake found! when the capture succeeds. Back out to stop capturing. The capture is saved to the SD card under /mnt/ghostesp/pcaps/. Command line\rRun list -a to see nearby networks. Run select -a \u0026lt;number\u0026gt; to lock onto your target network. Run capture -eapol to start listening. Wait for a device to authenticate to the network. You should see Handshake found! when successful. Run stop to finish capturing. The file location will be shown in the log. Next steps\rCopy the .pcap file from the device to your computer for further analysis. For Flipper Zero saved files, copy the file from /ext/apps_data/ghost_esp/pcaps/ on the Flipper\u0026rsquo;s SD card. Troubleshooting\rNo handshake found: Make sure a device is actually connecting to the network. Try toggling Wi-Fi off and on on a connected device to trigger a new authentication. Capture file missing: Verify the SD card is mounted and has free space. Check that you stopped the capture. ","description":"Record Wi-Fi authentication data for analysis.","permalink":"/v1.9/wifi/handshakes/","title":"Capturing handshakes"},{"content":"Connect two ESP32 devices with wires to enable remote control. This allows one device to host the access point continuously while the other performs attacks or scans, all controllable from the web interface.\nPrerequisites\rTwo compatible ESP32 boards. Three wires (TX, RX, GND) to connect them. Both devices flashed with GhostESP firmware. How it works\rWire two ESP32s together via UART. They auto-discover and connect on boot. Send any GhostESP command from one device to the other. No manual connection commands needed in most cases. Wiring\rConnect the devices with 3 wires:\nTX of Device A → RX of Device B (GPIO 6 → GPIO 7 by default, 17 → 16 on base ESP32 models) RX of Device A → TX of Device B (GPIO 7 → GPIO 6 by default, 16 → 17 on base ESP32 models) GND → GND Both devices need power.\nBasic usage\rOnce wired and powered on, devices automatically find each other:\ncommstatus - Check if connected commsend \u0026lt;command\u0026gt; - Send any command to the other device commdisconnect - Disconnect if needed Examples\rcommstatus - Check connection commsend scanap - Send command to other device commsend attack -d - Start attack on other device commsend beaconspam -r - Start beacon spam on other device commsend capture -probe - Start probe capture on other device Changing pins\rDefault pins are TX: GPIO 6, RX: GPIO 7 (or 17 and 16 on base ESP32 models). To change them:\nRun commsetpins \u0026lt;TX_PIN\u0026gt; \u0026lt;RX_PIN\u0026gt; (for example, commsetpins 4 5).\nPin changes are saved and persist across reboots. You cannot change pins while connected.\nManual connection\rIf auto-connection fails, you can manually connect:\ncommdiscovery - Check discovery status commconnect ESP_A1B2C3 - Connect to specific device Device names are auto-generated based on MAC address (format: ESP_XXXXXX).\nTroubleshooting\rNot connecting: Check wiring (TX→RX, RX→TX, GND connected). Make sure both devices are powered. Reboot them simultaneously and wait 30 seconds for discovery. Run commstatus to check. Commands not working: Verify connection with commstatus. Use exact GhostESP command syntax. Use cases\rHidden device control: Hide one ESP32 and control it remotely with full functionality through the web interface. Coordinated attacks: Both devices attack different targets simultaneously. Continuous AP hosting: One device maintains the access point while the other performs intensive operations. Notes\rAuto-discovery happens every 3 seconds. Connection uses UART at 115,200 baud. The device with the \u0026ldquo;larger\u0026rdquo; name becomes master, but commands can be sent from both directions. Auto-reconnect is enabled; the connection will automatically restore if interrupted. Physical wired connection is required. ","description":"Connect two ESP32 devices to control one remotely while maintaining continuous AP hosting.","permalink":"/v1.8.1/getting-started/dual-communication/","title":"Dual Communication"},{"content":"Connect two ESP32 devices with wires to enable remote control. This allows one device to host the access point continuously while the other performs attacks or scans, all controllable from the web interface.\nPrerequisites\rTwo compatible ESP32 boards. Three wires (TX, RX, GND) to connect them. Both devices flashed with GhostESP firmware. How it works\rWire two ESP32s together via UART. They auto-discover and connect on boot. Send any GhostESP command from one device to the other. No manual connection commands needed in most cases. Wiring\rConnect the devices with 3 wires:\nTX of Device A → RX of Device B (GPIO 6 → GPIO 7 by default, 17 → 16 on base ESP32 models) RX of Device A → TX of Device B (GPIO 7 → GPIO 6 by default, 16 → 17 on base ESP32 models) GND → GND Both devices need power.\nBasic usage\rOnce wired and powered on, devices automatically find each other:\ncommstatus - Check if connected commsend \u0026lt;command\u0026gt; - Send any command to the other device commdisconnect - Disconnect if needed Examples\rcommstatus - Check connection commsend scanap - Send command to other device commsend attack -d - Start attack on other device commsend beaconspam -r - Start beacon spam on other device commsend capture -probe - Start probe capture on other device Changing pins\rDefault pins are TX: GPIO 6, RX: GPIO 7 (or 17 and 16 on base ESP32 models). To change them:\nRun commsetpins \u0026lt;TX_PIN\u0026gt; \u0026lt;RX_PIN\u0026gt; (for example, commsetpins 4 5).\nPin changes are saved and persist across reboots. You cannot change pins while connected.\nManual connection\rIf auto-connection fails, you can manually connect:\ncommdiscovery - Check discovery status commconnect ESP_A1B2C3 - Connect to specific device Device names are auto-generated based on MAC address (format: ESP_XXXXXX).\nTroubleshooting\rNot connecting: Check wiring (TX→RX, RX→TX, GND connected). Make sure both devices are powered. Reboot them simultaneously and wait 30 seconds for discovery. Run commstatus to check. Commands not working: Verify connection with commstatus. Use exact GhostESP command syntax. Use cases\rHidden device control: Hide one ESP32 and control it remotely with full functionality through the web interface. Coordinated attacks: Both devices attack different targets simultaneously. Continuous AP hosting: One device maintains the access point while the other performs intensive operations. Notes\rAuto-discovery happens every 3 seconds. Connection uses UART at 115,200 baud. The device with the \u0026ldquo;larger\u0026rdquo; name becomes master, but commands can be sent from both directions. Auto-reconnect is enabled; the connection will automatically restore if interrupted. Physical wired connection is required. ","description":"Connect two ESP32 devices to control one remotely while maintaining continuous AP hosting.","permalink":"/v1.8/getting-started/dual-communication/","title":"Dual Communication"},{"content":"GhostLink connects two ESP32 devices so one can host the AP while the other runs attacks.\nPrerequisites\rTwo compatible ESP32 boards. Three wires (TX, RX, GND) to connect them. Both devices flashed with GhostESP firmware. How it works\rWire two ESP32s together via UART. They auto-discover and connect on boot. Send any GhostESP command from one device to the other. No manual connection commands needed in most cases. Wiring\rConnect the devices with 3 wires:\nTX of Device A → RX of Device B (GPIO 6 → GPIO 7 by default, 17 → 16 on base ESP32 models) RX of Device A → TX of Device B (GPIO 7 → GPIO 6 by default, 16 → 17 on base ESP32 models) GND → GND Both devices need power.\nBasic usage\rOnce wired and powered on, devices automatically find each other:\ncommstatus - Check if connected commsend \u0026lt;command\u0026gt; - Send any command to the other device commdisconnect - Disconnect if needed Examples\rcommstatus - Check connection commsend scanap - Send command to other device commsend attack -d - Start attack on other device commsend beaconspam -r - Start beacon spam on other device commsend capture -probe - Start probe capture on other device Changing pins\rDefault pins are TX: GPIO 6, RX: GPIO 7 (or 17 and 16 on base ESP32 models). To change them:\nRun commsetpins \u0026lt;TX_PIN\u0026gt; \u0026lt;RX_PIN\u0026gt; (for example, commsetpins 4 5).\nPin changes are saved and persist across reboots. You cannot change pins while connected.\nManual connection\rIf auto-connection fails, you can manually connect:\ncommdiscovery - Check discovery status commconnect ESP_A1B2C3 - Connect to specific device Device names are auto-generated based on MAC address (format: ESP_XXXXXX).\nOn-screen UI\rWhen connected, the GhostLink menu appears. It uses a split-view terminal: local logs on the left, remote responses on the right.\nCommands sent via the menu automatically open this view.\nTroubleshooting\rNot connecting: Check wiring (TX→RX, RX→TX, GND connected). Make sure both devices are powered. Reboot them simultaneously and wait 30 seconds for discovery. Run commstatus to check. Commands not working: Verify connection with commstatus. Use exact GhostESP command syntax. Use cases\rHidden device control: Hide one ESP32 and control it remotely with full functionality through the web interface. Coordinated attacks: Both devices attack different targets simultaneously. Continuous AP hosting: One device maintains the access point while the other performs intensive operations. Notes\rAuto-discovery happens every 3 seconds. Connection uses UART at 115,200 baud. The device with the \u0026ldquo;larger\u0026rdquo; name becomes master, but commands can be sent from both directions. Auto-reconnect is enabled; the connection will automatically restore if interrupted. Physical wired connection is required. ","description":"GhostLink connects two ESP32 devices for remote control while maintaining continuous AP hosting.","permalink":"/latest/getting-started/dual-communication/","title":"GhostLink"},{"content":"GhostLink connects two ESP32 devices so one can host the AP while the other runs attacks.\nPrerequisites\rTwo compatible ESP32 boards. Three wires (TX, RX, GND) to connect them. Both devices flashed with GhostESP firmware. How it works\rWire two ESP32s together via UART. They auto-discover and connect on boot. Send any GhostESP command from one device to the other. No manual connection commands needed in most cases. Wiring\rConnect the devices with 3 wires:\nTX of Device A → RX of Device B (GPIO 6 → GPIO 7 by default, 17 → 16 on base ESP32 models) RX of Device A → TX of Device B (GPIO 7 → GPIO 6 by default, 16 → 17 on base ESP32 models) GND → GND Both devices need power.\nBasic usage\rOnce wired and powered on, devices automatically find each other:\ncommstatus - Check if connected commsend \u0026lt;command\u0026gt; - Send any command to the other device commdisconnect - Disconnect if needed Examples\rcommstatus - Check connection commsend scanap - Send command to other device commsend attack -d - Start attack on other device commsend beaconspam -r - Start beacon spam on other device commsend capture -probe - Start probe capture on other device Changing pins\rDefault pins are TX: GPIO 6, RX: GPIO 7 (or 17 and 16 on base ESP32 models). To change them:\nRun commsetpins \u0026lt;TX_PIN\u0026gt; \u0026lt;RX_PIN\u0026gt; (for example, commsetpins 4 5).\nPin changes are saved and persist across reboots. You cannot change pins while connected.\nManual connection\rIf auto-connection fails, you can manually connect:\ncommdiscovery - Check discovery status commconnect ESP_A1B2C3 - Connect to specific device Device names are auto-generated based on MAC address (format: ESP_XXXXXX).\nOn-screen UI\rWhen connected, the GhostLink menu appears. It uses a split-view terminal: local logs on the left, remote responses on the right.\nCommands sent via the menu automatically open this view.\nTroubleshooting\rNot connecting: Check wiring (TX→RX, RX→TX, GND connected). Make sure both devices are powered. Reboot them simultaneously and wait 30 seconds for discovery. Run commstatus to check. Commands not working: Verify connection with commstatus. Use exact GhostESP command syntax. Use cases\rHidden device control: Hide one ESP32 and control it remotely with full functionality through the web interface. Coordinated attacks: Both devices attack different targets simultaneously. Continuous AP hosting: One device maintains the access point while the other performs intensive operations. Notes\rAuto-discovery happens every 3 seconds. Connection uses UART at 115,200 baud. The device with the \u0026ldquo;larger\u0026rdquo; name becomes master, but commands can be sent from both directions. Auto-reconnect is enabled; the connection will automatically restore if interrupted. Physical wired connection is required. ","description":"GhostLink connects two ESP32 devices for remote control while maintaining continuous AP hosting.","permalink":"/v1.9/getting-started/dual-communication/","title":"GhostLink"},{"content":"\rDirectory layout\r/ghostesp/infrared/remotes — Individual remotes captured on-device /ghostesp/infrared/universals — Library files with many commands The Infrared UI reads from /mnt/ghostesp/infrared/... when the SD card is mounted. Flipper IR libraries\rGhostESP reads standard Flipper .ir format. Download packs from Lucaslhm/Flipper-IRDB.\nUniversal IR files are available at Momentum Flipper Firmware. Download and place them under infrared/universals.\nBuilt-in Universal IR file\rIn addition to SD card files, GhostESP includes a built-in Universal IR file with popular TV POWER signals. This file doesn\u0026rsquo;t require an SD card.\nAppend new signals\rChoose Add Signal while a remote is open to append a newly learned button. Easy Learn suggests button names; otherwise you will be prompted via the on-screen keyboard. Web UI management\rConnect to the GhostNet AP and open the web UI. Browse to the file manager tab and navigate to /ghostesp/infrared/. Upload .ir files to the appropriate folder or download existing ones for backups. Tips\rKeep file names short; the UI truncates long names in lists. After mass uploads, back out of the infrared file view on the on-board display UI to refresh the list. Back up your IR folder before flashing new firmware or reformatting the SD card. ","description":"Organize, rename, and edit GhostESP IR files","permalink":"/latest/infrared/files/","title":"Infrared Files"},{"content":"\rDirectory layout\r/ghostesp/infrared/remotes holds individual remotes captured on-device. /ghostesp/infrared/universals stores library files with many commands. The Infrared UI reads from /mnt/ghostesp/infrared/... when the SD card is mounted. Flipper IR libraries\rGhostESP reads the standard Flipper .ir format, so you can copy files from community packs. A large collection is available at Lucaslhm/Flipper-IRDB; place downloaded files under infrared/remote or infrared/universals for universal files which you can find in Momentum custom Flipper Zero firmware. Built-in Universal IR file\rIn addition to SD card files, GhostESP includes a built-in Universal IR file with popular TV POWER signals. This file doesn\u0026rsquo;t require an SD card.\nAppend new signals\rChoose Add Signal while a remote is open to append a newly learned button. Easy Learn suggests button names; otherwise you will be prompted via the on-screen keyboard. Web UI management\rConnect to the GhostNet AP and open the web UI. Browse to the file manager tab and navigate to /ghostesp/infrared/. Upload .ir files to the appropriate folder or download existing ones for backups. Tips\rKeep file names short; the UI truncates long names in lists. After mass uploads, back out of the infrared file view on the on-board display UI to refresh the list. Back up your IR folder before flashing new firmware or reformatting the SD card. ","description":"Organize, rename, and edit GhostESP IR files","permalink":"/v1.8.1/infrared/files/","title":"Infrared Files"},{"content":"\rDirectory layout\r/ghostesp/infrared/remotes holds individual remotes captured on-device. /ghostesp/infrared/universals stores library files with many commands. The Infrared UI reads from /mnt/ghostesp/infrared/... when the SD card is mounted. Flipper IR libraries\rGhostESP reads the standard Flipper .ir format, so you can copy files from community packs. A large collection is available at Lucaslhm/Flipper-IRDB; place downloaded files under infrared/remote or infrared/universals for universal files which you can find in Momentum custom Flipper Zero firmware. Append new signals\rChoose Add Signal while a remote is open to append a newly learned button. Easy Learn suggests button names; otherwise you will be prompted via the on-screen keyboard. Web UI management\rConnect to the GhostNet AP and open the web UI. Browse to the file manager tab and navigate to /ghostesp/infrared/. Upload .ir files to the appropriate folder or download existing ones for backups. Tips\rKeep file names short; the UI truncates long names in lists. After mass uploads, back out of the infrared file view on the on-board display UI to refresh the list. Back up your IR folder before flashing new firmware or reformatting the SD card. ","description":"Organize, rename, and edit GhostESP IR files","permalink":"/v1.8/infrared/files/","title":"Infrared Files"},{"content":"\rDirectory layout\r/ghostesp/infrared/remotes — Individual remotes captured on-device /ghostesp/infrared/universals — Library files with many commands The Infrared UI reads from /mnt/ghostesp/infrared/... when the SD card is mounted. Flipper IR libraries\rGhostESP reads standard Flipper .ir format. Download packs from Lucaslhm/Flipper-IRDB.\nUniversal IR files are available at Momentum Flipper Firmware. Download and place them under infrared/universals.\nBuilt-in Universal IR file\rIn addition to SD card files, GhostESP includes a built-in Universal IR file with popular TV POWER signals. This file doesn\u0026rsquo;t require an SD card.\nAppend new signals\rChoose Add Signal while a remote is open to append a newly learned button. Easy Learn suggests button names; otherwise you will be prompted via the on-screen keyboard. Web UI management\rConnect to the GhostNet AP and open the web UI. Browse to the file manager tab and navigate to /ghostesp/infrared/. Upload .ir files to the appropriate folder or download existing ones for backups. Tips\rKeep file names short; the UI truncates long names in lists. After mass uploads, back out of the infrared file view on the on-board display UI to refresh the list. Back up your IR folder before flashing new firmware or reformatting the SD card. ","description":"Organize, rename, and edit GhostESP IR files","permalink":"/v1.9/infrared/files/","title":"Infrared Files"},{"content":"\rPrerequisites\rAn NTAG .nfc file on the SD card under /mnt/ghostesp/nfc/. NTAG21x or Ultralight tag compatible with the captured image size (NTAG213/215/216 page counts). A PN532 or Chameleon Ultra enabled build with a connected PN532 module or Chameleon Ultra. Steps\rOpen NFC → Write. From the NFC menu, choose Write. You should see a list of .nfc files detected on the SD card.\nSelect an image. Tap the file you want to program. You should see a popup summarizing the tag model, UID (if present), and total pages.\nStart the write. Choose Write in the popup. You should see the status change to “Present tag to write\u0026hellip;” while GhostESP waits for a blank card.\nPresent the blank tag. Hold the target NTAG on the antenna until the title updates. You should see “Writing… X%” as each page is written, finishing at “Write complete”.\nChameleon Ultra Writing\rNo remote writes. GhostESP cannot program tags through the Chameleon Ultra; use the PN532 workflow above. Verify\rRe-scan the card using the Scan NFC Tags guide to confirm the UID (if applicable) and data match the source image. Check the popup for success messages; any failed page write will trigger an error log with the page number. Optional: load the card in an external reader to confirm the NDEF payload or application data. Troubleshooting\rFile list empty. Ensure .nfc files exist under /mnt/ghostesp/nfc/ and the SD card is mounted.\n“Present tag to write\u0026hellip;” never changes. The PN532 cannot see the card. Re-seat the antenna or try a different blank tag.\nWrite stops mid-way: Remove the tag, power-cycle GhostESP, and retry. Failures often mean the card\u0026rsquo;s capacity doesn\u0026rsquo;t match the image.\nFAQ\rCan I clone MIFARE Classic with this flow? No, the Write flow is limited to NTAG/Ultralight dumps today. Do I need to keep holding the card after 100%? Hold it until “Write complete” appears; the device finalizes status after the last page. Will the UID be overwritten? NTAG UIDs are read-only. The saved UID is used for naming and verification, but the physical card keeps its factory UID. ","description":"Program NTAG and Ultralight cards from saved dumps","permalink":"/latest/nfc/writing/","title":"Writing NTAG"},{"content":"\rPrerequisites\rAn NTAG .nfc file on the SD card under /mnt/ghostesp/nfc/ created from a previous scan or copied manually. NTAG21x or Ultralight tag compatible with the captured image size (NTAG213/215/216 page counts). A PN532 or Chameleon Ultra enabled build with a connected PN532 module or Chameleon Ultra. Steps\rOpen NFC → Write. From the NFC menu, choose Write. You should see a list of .nfc files detected on the SD card.\nSelect an image. Tap the file you want to program. You should see a popup summarizing the tag model, UID (if present), and total pages.\nStart the write. Choose Write in the popup. You should see the status change to “Present tag to write\u0026hellip;” while GhostESP waits for a blank card.\nPresent the blank tag. Hold the target NTAG on the antenna until the title updates. You should see “Writing… X%” as each page is written, finishing at “Write complete”.\nChameleon Ultra Writing\rNo remote writes. GhostESP cannot program tags through the Chameleon Ultra; use the PN532 workflow above. Verify\rRe-scan the card using the Scan NFC Tags guide to confirm the UID (if applicable) and data match the source image. Check the popup for success messages; any failed page write will trigger an error log with the page number. Optional: load the card in an external reader to confirm the NDEF payload or application data. Troubleshooting\rFile list empty. Ensure .nfc files exist under /mnt/ghostesp/nfc/ and the SD card is mounted.\n“Present tag to write\u0026hellip;” never changes. The PN532 cannot see the card. Re-seat the antenna or try a different blank tag.\nWrite stops mid-way. Remove the tag, power-cycle GhostESP, and retry. Persistent failures often mean the card’s capacity does not match the image (e.g., writing a 216-page dump to a 213 card).\nFAQ\rCan I clone MIFARE Classic with this flow? No, the Write flow is limited to NTAG/Ultralight dumps today. Do I need to keep holding the card after 100%? Hold it until “Write complete” appears; the device finalizes status after the last page. Will the UID be overwritten? NTAG UIDs are read-only. The saved UID is used for naming and verification, but the physical card keeps its factory UID. ","description":"Program NTAG and Ultralight cards from saved dumps","permalink":"/v1.8.1/nfc/writing/","title":"Writing NTAG"},{"content":"\rPrerequisites\rAn NTAG .nfc file on the SD card under /mnt/ghostesp/nfc/ created from a previous scan or copied manually. NTAG21x or Ultralight tag compatible with the captured image size (NTAG213/215/216 page counts). A PN532 or Chameleon Ultra enabled build with a connected PN532 module or Chameleon Ultra. Steps\rOpen NFC → Write. From the NFC menu, choose Write. You should see a list of .nfc files detected on the SD card.\nSelect an image. Tap the file you want to program. You should see a popup summarizing the tag model, UID (if present), and total pages.\nStart the write. Choose Write in the popup. You should see the status change to “Present tag to write\u0026hellip;” while GhostESP waits for a blank card.\nPresent the blank tag. Hold the target NTAG on the antenna until the title updates. You should see “Writing… X%” as each page is written, finishing at “Write complete”.\nChameleon Ultra Writing\rNo remote writes. GhostESP cannot program tags through the Chameleon Ultra; use the PN532 workflow above. Verify\rRe-scan the card using the Scan NFC Tags guide to confirm the UID (if applicable) and data match the source image. Check the popup for success messages; any failed page write will trigger an error log with the page number. Optional: load the card in an external reader to confirm the NDEF payload or application data. Troubleshooting\rFile list empty. Ensure .nfc files exist under /mnt/ghostesp/nfc/ and the SD card is mounted.\n“Present tag to write\u0026hellip;” never changes. The PN532 cannot see the card. Re-seat the antenna or try a different blank tag.\nWrite stops mid-way. Remove the tag, power-cycle GhostESP, and retry. Persistent failures often mean the card’s capacity does not match the image (e.g., writing a 216-page dump to a 213 card).\nFAQ\rCan I clone MIFARE Classic with this flow? No, the Write flow is limited to NTAG/Ultralight dumps today. Do I need to keep holding the card after 100%? Hold it until “Write complete” appears; the device finalizes status after the last page. Will the UID be overwritten? NTAG UIDs are read-only. The saved UID is used for naming and verification, but the physical card keeps its factory UID. ","description":"Program NTAG and Ultralight cards from saved dumps","permalink":"/v1.8/nfc/writing/","title":"Writing NTAG"},{"content":"\rPrerequisites\rAn NTAG .nfc file on the SD card under /mnt/ghostesp/nfc/. NTAG21x or Ultralight tag compatible with the captured image size (NTAG213/215/216 page counts). A PN532 or Chameleon Ultra enabled build with a connected PN532 module or Chameleon Ultra. Steps\rOpen NFC → Write. From the NFC menu, choose Write. You should see a list of .nfc files detected on the SD card.\nSelect an image. Tap the file you want to program. You should see a popup summarizing the tag model, UID (if present), and total pages.\nStart the write. Choose Write in the popup. You should see the status change to “Present tag to write\u0026hellip;” while GhostESP waits for a blank card.\nPresent the blank tag. Hold the target NTAG on the antenna until the title updates. You should see “Writing… X%” as each page is written, finishing at “Write complete”.\nChameleon Ultra Writing\rNo remote writes. GhostESP cannot program tags through the Chameleon Ultra; use the PN532 workflow above. Verify\rRe-scan the card using the Scan NFC Tags guide to confirm the UID (if applicable) and data match the source image. Check the popup for success messages; any failed page write will trigger an error log with the page number. Optional: load the card in an external reader to confirm the NDEF payload or application data. Troubleshooting\rFile list empty. Ensure .nfc files exist under /mnt/ghostesp/nfc/ and the SD card is mounted.\n“Present tag to write\u0026hellip;” never changes. The PN532 cannot see the card. Re-seat the antenna or try a different blank tag.\nWrite stops mid-way: Remove the tag, power-cycle GhostESP, and retry. Failures often mean the card\u0026rsquo;s capacity doesn\u0026rsquo;t match the image.\nFAQ\rCan I clone MIFARE Classic with this flow? No, the Write flow is limited to NTAG/Ultralight dumps today. Do I need to keep holding the card after 100%? Hold it until “Write complete” appears; the device finalizes status after the last page. Will the UID be overwritten? NTAG UIDs are read-only. The saved UID is used for naming and verification, but the physical card keeps its factory UID. ","description":"Program NTAG and Ultralight cards from saved dumps","permalink":"/v1.9/nfc/writing/","title":"Writing NTAG"},{"content":"View and control your device\u0026rsquo;s screen from your computer.\nPrerequisites\rA GhostESP device with a display (CYD, T-Deck, Cardputer, etc.) USB cable to connect the device Python 3.8 or newer (for desktop script only) Note: CYD devices require 460800 baud instead of the default 115200, and use 8-bit color mode which may result in reduced color quality and slowdowns Installation (Desktop Script)\rThe script is in scripts/screen_mirror/. It installs dependencies (pygame, pyserial, numpy) on first run.\nFor Web-Based Mirror: If you prefer not to install Python, use the web mirror at ghostesp.net/serial by opening the Web Serial tab.\nStarting the Mirror\rDesktop Script\rConnect your GhostESP device via USB Open a terminal in the scripts/screen_mirror folder Run the script: python ghost_mirror.py Or specify a port directly:\npython ghost_mirror.py COM3 For CYD devices, you must specify the higher baud rate:\npython ghost_mirror.py COM3 --baud 460800 To list available serial ports:\npython ghost_mirror.py --list Web-Based Mirror\rAlternatively, visit ghostesp.net/serial and open the Screen Mirror tab to use the browser-based mirror without installing Python. The web serial mirror also includes a console and file browser on the same page.\nDevice-Specific Considerations\rCYD Devices\rCYD devices need specific settings due to their 8-bit color mode:\nBaud Rate: Use --baud 460800; the default 115200 is too slow for CYD refresh rates. Color Mode: The mirror stream is truncated to 8 bits, so colors may shift compared to the physical display. Performance: Expect reduced frame rates and occasional slowdowns because the 8-bit stream is bandwidth-constrained. To connect to a CYD device:\npython ghost_mirror.py COM3 --baud 460800 Click Swap to fix inverted colors. Note that CYD mirroring is slower and has lower color quality.\nUsing the Mirror\rWindow Controls\rTitle bar: Drag to move the window × button: Close the application Port Selection\rUse the ◄ and ► buttons in the header to cycle through available COM ports. The current port is displayed between the buttons.\nConnection\rConnect: Opens the serial connection and enables mirroring Disconnect: Closes the connection cleanly Display Controls\rThe virtual D-pad on the right side mirrors the physical controls on your device:\nButton Action ▲ Navigate up ▼ Navigate down ◄ Navigate left / Go back ► Navigate right ● Select / Confirm Keyboard Shortcuts\rKey Action W / ↑ Up S / ↓ Down A / ← Left D / → Right Enter / Space Select Escape Exit Byte Swap Toggle\rIf colors appear wrong (inverted or incorrect), click the Swap button to toggle byte order. This forces a full screen refresh.\nNote on CYD Color Issues: CYD devices use 8-bit color mode during mirroring, which inherently produces less accurate colors than 16-bit modes. If toggling the Swap button doesn\u0026rsquo;t fully resolve color issues on a CYD device, this is expected behavior due to the 8-bit limitation.\nCommand Line Options\rOption Description --scale N Scale the display by factor N (default: 2) --baud N Set baud rate (default: 115200) --list List available serial ports Examples\r# Run with 3x scaling\rpython ghost_mirror.py COM3 --scale 3\r# CYD device (requires 460800 baud)\rpython ghost_mirror.py COM3 --baud 460800\r# Use a different baud rate\rpython ghost_mirror.py COM3 --baud 921600 Status Indicators\rGreen dot: Connected and receiving data Red dot: Disconnected or connection lost FPS counter: Shows current frame rate Resolution: Displays current screen dimensions Troubleshooting\rNo display or black screen\rEnsure the device is powered on and showing content on its physical display Try clicking Connect to re-establish the connection Check that the correct COM port is selected Wrong colors\rClick the Swap button to toggle byte order The display will refresh with corrected colors For CYD devices: Poor color fidelity is normal due to 8-bit color mode. Connection lost\rThe status indicator will turn red Click Connect to reconnect If the device was reset, wait for it to boot before reconnecting Device resets when connecting\rThis is normal for some boards on first connection The script disables DTR/RTS to prevent resets after initial connection Slow or laggy display\rScreen mirroring uses USB serial which has bandwidth limitations Reduce scale factor if needed Close other applications using the serial port For CYD devices: Slowdowns are expected due to 8-bit color mode and bandwidth constraints. Ensure you\u0026rsquo;re using --baud 460800 for optimal performance. If the display is still slow, try reducing the scale factor further. Notes\rBaud Rates: Desktop script uses 115200 baud by default. CYD devices require 460800 baud for proper operation. Color Modes: Most devices support 16-bit color. CYD devices use 8-bit color mode, resulting in reduced color accuracy and potential slowdowns. Performance: CYD devices may experience frame rate reductions and occasional slowdowns due to 8-bit mode and serial bandwidth limitations. This is normal and expected behavior. Web vs Desktop: The desktop script offers better performance and more features. The web-based mirror is a convenience option that works without additional software installation. Device Display: The mirror only shows content when the device\u0026rsquo;s display is actively updating. Input Control: Virtual D-pad buttons and keyboard shortcuts send commands as text over the same serial connection. Compatibility: Works with any GhostESP device that has a display (CYD, T-Deck, Cardputer, etc.). ","description":"Mirror your GhostESP display to your desktop for easier viewing and remote control.","permalink":"/latest/getting-started/screen-mirroring/","title":"Screen Mirroring"},{"content":"View and control your device\u0026rsquo;s screen from your computer.\nPrerequisites\rA GhostESP device with a display (CYD, T-Deck, Cardputer, etc.) USB cable to connect the device Python 3.8 or newer (for desktop script only) Note: CYD devices require 460800 baud instead of the default 115200, and use 8-bit color mode which may result in reduced color quality and slowdowns Installation (Desktop Script)\rThe script is in scripts/screen_mirror/. It installs dependencies (pygame, pyserial, numpy) on first run.\nFor Web-Based Mirror: If you prefer not to install Python, use the web mirror at ghostesp.net/serial by opening the Web Serial tab.\nStarting the Mirror\rDesktop Script\rConnect your GhostESP device via USB Open a terminal in the scripts/screen_mirror folder Run the script: python ghost_mirror.py Or specify a port directly:\npython ghost_mirror.py COM3 For CYD devices, you must specify the higher baud rate:\npython ghost_mirror.py COM3 --baud 460800 To list available serial ports:\npython ghost_mirror.py --list Web-Based Mirror\rAlternatively, visit ghostesp.net/serial and open the Screen Mirror tab to use the browser-based mirror without installing Python. The web serial mirror also includes a console and file browser on the same page.\nDevice-Specific Considerations\rCYD Devices\rCYD devices need specific settings due to their 8-bit color mode:\nBaud Rate: Use --baud 460800; the default 115200 is too slow for CYD refresh rates. Color Mode: The mirror stream is truncated to 8 bits, so colors may shift compared to the physical display. Performance: Expect reduced frame rates and occasional slowdowns because the 8-bit stream is bandwidth-constrained. To connect to a CYD device:\npython ghost_mirror.py COM3 --baud 460800 Click Swap to fix inverted colors. Note that CYD mirroring is slower and has lower color quality.\nUsing the Mirror\rWindow Controls\rTitle bar: Drag to move the window × button: Close the application Port Selection\rUse the ◄ and ► buttons in the header to cycle through available COM ports. The current port is displayed between the buttons.\nConnection\rConnect: Opens the serial connection and enables mirroring Disconnect: Closes the connection cleanly Display Controls\rThe virtual D-pad on the right side mirrors the physical controls on your device:\nButton Action ▲ Navigate up ▼ Navigate down ◄ Navigate left / Go back ► Navigate right ● Select / Confirm Keyboard Shortcuts\rKey Action W / ↑ Up S / ↓ Down A / ← Left D / → Right Enter / Space Select Escape Exit Byte Swap Toggle\rIf colors appear wrong (inverted or incorrect), click the Swap button to toggle byte order. This forces a full screen refresh.\nNote on CYD Color Issues: CYD devices use 8-bit color mode during mirroring, which inherently produces less accurate colors than 16-bit modes. If toggling the Swap button doesn\u0026rsquo;t fully resolve color issues on a CYD device, this is expected behavior due to the 8-bit limitation.\nCommand Line Options\rOption Description --scale N Scale the display by factor N (default: 2) --baud N Set baud rate (default: 115200) --list List available serial ports Examples\r# Run with 3x scaling\rpython ghost_mirror.py COM3 --scale 3\r# CYD device (requires 460800 baud)\rpython ghost_mirror.py COM3 --baud 460800\r# Use a different baud rate\rpython ghost_mirror.py COM3 --baud 921600 Status Indicators\rGreen dot: Connected and receiving data Red dot: Disconnected or connection lost FPS counter: Shows current frame rate Resolution: Displays current screen dimensions Troubleshooting\rNo display or black screen\rEnsure the device is powered on and showing content on its physical display Try clicking Connect to re-establish the connection Check that the correct COM port is selected Wrong colors\rClick the Swap button to toggle byte order The display will refresh with corrected colors For CYD devices: Poor color fidelity is normal due to 8-bit color mode. Connection lost\rThe status indicator will turn red Click Connect to reconnect If the device was reset, wait for it to boot before reconnecting Device resets when connecting\rThis is normal for some boards on first connection The script disables DTR/RTS to prevent resets after initial connection Slow or laggy display\rScreen mirroring uses USB serial which has bandwidth limitations Reduce scale factor if needed Close other applications using the serial port For CYD devices: Slowdowns are expected due to 8-bit color mode and bandwidth constraints. Ensure you\u0026rsquo;re using --baud 460800 for optimal performance. If the display is still slow, try reducing the scale factor further. Notes\rBaud Rates: Desktop script uses 115200 baud by default. CYD devices require 460800 baud for proper operation. Color Modes: Most devices support 16-bit color. CYD devices use 8-bit color mode, resulting in reduced color accuracy and potential slowdowns. Performance: CYD devices may experience frame rate reductions and occasional slowdowns due to 8-bit mode and serial bandwidth limitations. This is normal and expected behavior. Web vs Desktop: The desktop script offers better performance and more features. The web-based mirror is a convenience option that works without additional software installation. Device Display: The mirror only shows content when the device\u0026rsquo;s display is actively updating. Input Control: Virtual D-pad buttons and keyboard shortcuts send commands as text over the same serial connection. Compatibility: Works with any GhostESP device that has a display (CYD, T-Deck, Cardputer, etc.). ","description":"Mirror your GhostESP display to your desktop for easier viewing and remote control.","permalink":"/v1.9/getting-started/screen-mirroring/","title":"Screen Mirroring"},{"content":"The WebUI allows you to configure GhostESP and manage files from your browser.\nNote: Wi-Fi/BLE commands require GhostLink because the radio cannot scan and host the AP simultaneously.\nConnecting to the WebUI\rPrerequisites\rGhostESP device powered on and booted A computer, phone, or tablet with a web browser Wi-Fi capability Steps\rFind the GhostNet network\nOn your device, scan for Wi-Fi networks and look for GhostNet. Connect to it using the password GhostNet. Open the web interface\nOpen a web browser and navigate to one of: ghostesp.local (requires mDNS support; works on most networks) 192.168.4.1 (direct IP; always works) Authentication (optional)\nWebUI authentication is disabled by default for faster access. To enable it, run webauth on in the serial CLI or WebUI terminal. When enabled, the default credentials are GhostNet / GhostNet, protected by HTTP Digest (RFC2617) with signed nonces. Tabs and Features\rThe WebUI has five main tabs:\nSettings\rConfigure device behavior through multiple pages:\nMiscellaneous: General device settings WiFi: Wi-Fi configuration options Evil Portal: Portal settings and credential management Power Printer: Power printer configuration RGB: LED/RGB lighting settings Watch / RTC: Real-time clock and watch settings SD Card Config: SD card configuration SD Card\rBrowse and manage files on the SD card:\nNavigate /mnt/ghostesp/ directory structure Download PCAP captures, portal credentials, and other files Delete files to free space Upload custom portal HTML files Terminal\rExecute commands directly from the browser:\nType any GhostESP command (same as serial CLI) View command output in real time Useful for quick diagnostics and file transfers Limitation: Wi-Fi and BLE commands (e.g., scanap, karma start, blescan) cannot run here because the device\u0026rsquo;s radio is hosting the access point. Running them locally temporarily suspends the AP; to keep GhostNet online, use the Dual Comm tab to send these commands to a paired device instead.\nHelp\rAccess built-in documentation for features and commands:\nWi-Fi: Scanning and attack commands BLE: Bluetooth Low Energy operations Communication: GhostLink dual communication setup SD Card: SD card operations LED / RGB: LED and RGB lighting GPS: GPS functionality Misc: Miscellaneous features Evil Portal: Portal configuration Printer: Power printer features YouTube Cast: YouTube casting Capture: Packet capture modes Beacon: Beacon spam options Attack: Attack command reference GhostLink\rManage a GhostLink connection between a paired ESP32 device:\nView connection status Send commands to the paired device Monitor GhostLink link health Important Limitations\rWi-Fi and BLE Commands Require GhostLink\rThe WebUI cannot directly run Wi-Fi or BLE commands (e.g., scanap, karma start, blescan). These commands require the device\u0026rsquo;s radio hardware, which conflicts with hosting the Wi-Fi access point.\nTo run Wi-Fi or BLE commands from the WebUI:\nSet up GhostLink with two ESP32 devices wired together. One device hosts the access point (runs WebUI). The other device performs attacks/scans. Send commands through the WebUI using commsend \u0026lt;command\u0026gt;. Example workflow:\nDevice A (with WebUI): Hosts GhostNet AP Device B (attack device): Wired to Device A via UART From WebUI on Device A: commsend scanap → scans on Device B From WebUI on Device A: commsend karma start → runs Karma on Device B Commands that work directly in WebUI:\rNFC commands (scanning, writing, saving) Infrared commands (learning, transmitting) File management Device configuration Help and diagnostics Tips and Tricks\rFaster File Transfers\rUse a card reader for faster file transfers. The WebUI file manager is convenient but slower over Wi-Fi. Toggle Authentication When Needed\rwebauth on — enable HTTP Digest authentication for the WebUI. webauth off — return to the default open-access mode. Troubleshooting\rCan\u0026rsquo;t connect to GhostNet\rGhostNet not visible: Reboot the device. It should broadcast the AP within 10 seconds of boot. Connection drops: Move closer to the device or check for interference. Wrong password: Default is GhostNet (case-sensitive). Can\u0026rsquo;t reach the WebUI\rPage won\u0026rsquo;t load: Try 192.168.4.1 instead of ghostesp.local. \u0026ldquo;Connection refused\u0026rdquo;: The device may still be booting. Wait 10 seconds and refresh. Timeout: Check that you\u0026rsquo;re connected to the GhostNet AP, not a different network. Login fails\rAuthentication prompts unexpectedly: Run webauth off to confirm the feature is disabled. Credentials rejected: If you enabled auth, defaults are GhostNet / GhostNet (case-sensitive). Forgot credentials: Reboot the device to reset to defaults. Wi-Fi commands don\u0026rsquo;t work\r\u0026ldquo;Command not available\u0026rdquo;: You need GhostLink. See GhostLink for setup. Command times out: Verify the second device is wired correctly and powered on. File manager is slow\rDownloads are slow: Use a USB card reader instead. Uploads fail: Ensure the SD card has free space and is properly mounted. Next Steps\rSet up GhostLink to run Wi-Fi and BLE attacks from the WebUI. Explore the Command Line Reference for available commands. Review Wi-Fi Basics to learn about attacks and scanning. ","description":"Access and control GhostESP through the web interface.","permalink":"/latest/getting-started/webui-guide/","title":"WebUI"},{"content":"The GhostNet WebUI is a browser-based control panel for managing GhostESP settings and controlling certain features. It runs on the device\u0026rsquo;s built-in access point and is accessible from any device on the same network.\nNote: Wi-Fi and BLE commands cannot be run directly through the WebUI because the device\u0026rsquo;s radio is in use hosting the access point. When you launch those commands from the device or serial CLI, the GhostNet AP is paused until the radio work finishes. Use Dual Communication to run them remotely without losing the AP.\nConnecting to the WebUI\rPrerequisites\rGhostESP device powered on and booted A computer, phone, or tablet with a web browser Wi-Fi capability Steps\rFind the GhostNet network\nOn your device, scan for Wi-Fi networks and look for GhostNet. Connect to it using the password GhostNet. Open the web interface\nOpen a web browser and navigate to one of: ghostesp.local (requires mDNS support; works on most networks) 192.168.4.1 (direct IP; always works) Authentication (optional)\nWebUI authentication is disabled by default for faster access. To enable it, run webauth on in the serial CLI or WebUI terminal. When enabled, the default credentials are GhostNet / GhostNet, protected by HTTP Digest (RFC2617) with signed nonces. Tabs and Features\rThe WebUI has five main tabs:\nSettings\rConfigure device behavior through multiple pages:\nMiscellaneous: General device settings WiFi: Wi-Fi configuration options Evil Portal: Portal settings and credential management Power Printer: Power printer configuration RGB: LED/RGB lighting settings Watch / RTC: Real-time clock and watch settings SD Card Config: SD card configuration SD Card\rBrowse and manage files on the SD card:\nNavigate /mnt/ghostesp/ directory structure Download PCAP captures, portal credentials, and other files Delete files to free space Upload custom portal HTML files Terminal\rExecute commands directly from the browser:\nType any GhostESP command (same as serial CLI) View command output in real time Useful for quick diagnostics and file transfers Limitation: Wi-Fi and BLE commands (e.g., scanap, karma start, blescan) cannot run here because the device\u0026rsquo;s radio is hosting the access point. Running them locally temporarily suspends the AP; to keep GhostNet online, use the Dual Comm tab to send these commands to a paired device instead.\nHelp\rAccess built-in documentation for features and commands:\nWi-Fi: Scanning and attack commands BLE: Bluetooth Low Energy operations Communication: Dual communication setup SD Card: SD card operations LED / RGB: LED and RGB lighting GPS: GPS functionality Misc: Miscellaneous features Evil Portal: Portal configuration Printer: Power printer features YouTube Cast: YouTube casting Capture: Packet capture modes Beacon: Beacon spam options Attack: Attack command reference Dual Comm\rManage dual communication with a paired ESP32 device:\nView connection status Send commands to the paired device Monitor dual communication link health Important Limitations\rWi-Fi and BLE Commands Require Dual Communication\rThe WebUI cannot directly run Wi-Fi or BLE commands (e.g., scanap, karma start, blescan). These commands require the device\u0026rsquo;s radio hardware, which conflicts with hosting the Wi-Fi access point.\nTo run Wi-Fi or BLE commands from the WebUI:\nSet up Dual Communication with two ESP32 devices wired together. One device hosts the access point (runs WebUI). The other device performs attacks/scans. Send commands through the WebUI using commsend \u0026lt;command\u0026gt;. Example workflow:\nDevice A (with WebUI): Hosts GhostNet AP Device B (attack device): Wired to Device A via UART From WebUI on Device A: commsend scanap → scans on Device B From WebUI on Device A: commsend karma start → runs Karma on Device B Commands that work directly in WebUI:\rNFC commands (scanning, writing, saving) Infrared commands (learning, transmitting) File management Device configuration Help and diagnostics Tips and Tricks\rFaster File Transfers\rUse a card reader connected to your computer instead of the WebUI for faster PCAP and file transfers. The WebUI file manager is convenient but slower over Wi-Fi. Toggle Authentication When Needed\rwebauth on — enable HTTP Digest authentication for the WebUI. webauth off — return to the default open-access mode. Troubleshooting\rCan\u0026rsquo;t connect to GhostNet\rGhostNet not visible: Reboot the device. It should broadcast the AP within 10 seconds of boot. Connection drops: Move closer to the device or check for interference. Wrong password: Default is GhostNet (case-sensitive). Can\u0026rsquo;t reach the WebUI\rPage won\u0026rsquo;t load: Try 192.168.4.1 instead of ghostesp.local. \u0026ldquo;Connection refused\u0026rdquo;: The device may still be booting. Wait 10 seconds and refresh. Timeout: Check that you\u0026rsquo;re connected to the GhostNet AP, not a different network. Login fails\rAuthentication prompts unexpectedly: Run webauth off to confirm the feature is disabled. Credentials rejected: If you enabled auth, defaults are GhostNet / GhostNet (case-sensitive). Forgot credentials: Reboot the device to reset to defaults. Wi-Fi commands don\u0026rsquo;t work\r\u0026ldquo;Command not available\u0026rdquo;: You need dual communication. See Dual Communication for setup. Command times out: Verify the second device is wired correctly and powered on. File manager is slow\rDownloads are slow: Use a USB card reader instead. Uploads fail: Ensure the SD card has free space and is properly mounted. Next Steps\rSet up Dual Communication to run Wi-Fi and BLE attacks from the WebUI. Explore the Command Line Reference for available commands. Review Wi-Fi Basics to learn about attacks and scanning. ","description":"Access and control GhostESP through the web interface.","permalink":"/v1.8.1/getting-started/webui-guide/","title":"WebUI"},{"content":"The GhostNet WebUI is a browser-based control panel for managing GhostESP settings and controlling certain features. It runs on the device\u0026rsquo;s built-in access point and is accessible from any device on the same network.\nNote: Wi-Fi and BLE commands cannot be run directly through the WebUI because the device\u0026rsquo;s radio is in use hosting the access point. Use Dual Communication to run these commands remotely.\nConnecting to the WebUI\rPrerequisites\rGhostESP device powered on and booted A computer, phone, or tablet with a web browser Wi-Fi capability Steps\rFind the GhostNet network\nOn your device, scan for Wi-Fi networks and look for GhostNet. Connect to it using the password GhostNet. Open the web interface\nOpen a web browser and navigate to one of: ghostesp.local (requires mDNS support; works on most networks) 192.168.4.1 (direct IP; always works) Log in\nUsername: GhostNet Password: GhostNet To disable authentication, run webauth off in the serial CLI or WebUI terminal. Tabs and Features\rThe WebUI has five main tabs:\nSettings\rConfigure device behavior through multiple pages:\nMiscellaneous: General device settings WiFi: Wi-Fi configuration options Evil Portal: Portal settings and credential management Power Printer: Power printer configuration RGB: LED/RGB lighting settings Watch / RTC: Real-time clock and watch settings SD Card Config: SD card configuration SD Card\rBrowse and manage files on the SD card:\nNavigate /mnt/ghostesp/ directory structure Download PCAP captures, portal credentials, and other files Delete files to free space Upload custom portal HTML files Terminal\rExecute commands directly from the browser:\nType any GhostESP command (same as serial CLI) View command output in real time Useful for quick diagnostics and file transfers Limitation: Wi-Fi and BLE commands (e.g., scanap, karma start, blescan) cannot run here because the device\u0026rsquo;s radio is hosting the access point. Use the Dual Comm tab to send these commands to a paired device instead.\nHelp\rAccess built-in documentation for features and commands:\nWi-Fi: Scanning and attack commands BLE: Bluetooth Low Energy operations Communication: Dual communication setup SD Card: SD card operations LED / RGB: LED and RGB lighting GPS: GPS functionality Misc: Miscellaneous features Evil Portal: Portal configuration Printer: Power printer features YouTube Cast: YouTube casting Capture: Packet capture modes Beacon: Beacon spam options Attack: Attack command reference Dual Comm\rManage dual communication with a paired ESP32 device:\nView connection status Send commands to the paired device Monitor dual communication link health Important Limitations\rWi-Fi and BLE Commands Require Dual Communication\rThe WebUI cannot directly run Wi-Fi or BLE commands (e.g., scanap, karma start, blescan). These commands require the device\u0026rsquo;s radio hardware, which conflicts with hosting the Wi-Fi access point.\nTo run Wi-Fi or BLE commands from the WebUI:\nSet up Dual Communication with two ESP32 devices wired together. One device hosts the access point (runs WebUI). The other device performs attacks/scans. Send commands through the WebUI using commsend \u0026lt;command\u0026gt;. Example workflow:\nDevice A (with WebUI): Hosts GhostNet AP Device B (attack device): Wired to Device A via UART From WebUI on Device A: commsend scanap → scans on Device B From WebUI on Device A: commsend karma start → runs Karma on Device B Commands that work directly in WebUI:\rNFC commands (scanning, writing, saving) Infrared commands (learning, transmitting) File management Device configuration Help and diagnostics Tips and Tricks\rFaster File Transfers\rUse a card reader connected to your computer instead of the WebUI for faster PCAP and file transfers. The WebUI file manager is convenient but slower over Wi-Fi. Disable Authentication for Local Networks\rIf you\u0026rsquo;re on a trusted local network:\nwebauth off This removes the login requirement and speeds up access.\nAccess from Mobile\rThe WebUI is fully responsive and works on phones and tablets. Connect to GhostNet and navigate to ghostesp.local or 192.168.4.1.\nTroubleshooting\rCan\u0026rsquo;t connect to GhostNet\rGhostNet not visible: Reboot the device. It should broadcast the AP within 10 seconds of boot. Connection drops: Move closer to the device or check for interference. Wrong password: Default is GhostNet (case-sensitive). Can\u0026rsquo;t reach the WebUI\rPage won\u0026rsquo;t load: Try 192.168.4.1 instead of ghostesp.local. \u0026ldquo;Connection refused\u0026rdquo;: The device may still be booting. Wait 10 seconds and refresh. Timeout: Check that you\u0026rsquo;re connected to the GhostNet AP, not a different network. Login fails\rCredentials rejected: Default is GhostNet / GhostNet (case-sensitive). Forgot credentials: Reboot the device to reset to defaults. Can\u0026rsquo;t disable auth: Run webauth off from the serial CLI, not the WebUI terminal. Wi-Fi commands don\u0026rsquo;t work\r\u0026ldquo;Command not available\u0026rdquo;: You need dual communication. See Dual Communication for setup. Command times out: Verify the second device is wired correctly and powered on. File manager is slow\rDownloads are slow: Use a USB card reader instead. Uploads fail: Ensure the SD card has free space and is properly mounted. Next Steps\rSet up Dual Communication to run Wi-Fi and BLE attacks from the WebUI. Explore the Command Line Reference for available commands. Review Wi-Fi Basics to learn about attacks and scanning. ","description":"Access and control GhostESP through the web interface.","permalink":"/v1.8/getting-started/webui-guide/","title":"WebUI"},{"content":"The WebUI allows you to configure GhostESP and manage files from your browser.\nNote: Wi-Fi/BLE commands require GhostLink because the radio cannot scan and host the AP simultaneously.\nConnecting to the WebUI\rPrerequisites\rGhostESP device powered on and booted A computer, phone, or tablet with a web browser Wi-Fi capability Steps\rFind the GhostNet network\nOn your device, scan for Wi-Fi networks and look for GhostNet. Connect to it using the password GhostNet. Open the web interface\nOpen a web browser and navigate to one of: ghostesp.local (requires mDNS support; works on most networks) 192.168.4.1 (direct IP; always works) Authentication (optional)\nWebUI authentication is disabled by default for faster access. To enable it, run webauth on in the serial CLI or WebUI terminal. When enabled, the default credentials are GhostNet / GhostNet, protected by HTTP Digest (RFC2617) with signed nonces. Tabs and Features\rThe WebUI has five main tabs:\nSettings\rConfigure device behavior through multiple pages:\nMiscellaneous: General device settings WiFi: Wi-Fi configuration options Evil Portal: Portal settings and credential management Power Printer: Power printer configuration RGB: LED/RGB lighting settings Watch / RTC: Real-time clock and watch settings SD Card Config: SD card configuration SD Card\rBrowse and manage files on the SD card:\nNavigate /mnt/ghostesp/ directory structure Download PCAP captures, portal credentials, and other files Delete files to free space Upload custom portal HTML files Terminal\rExecute commands directly from the browser:\nType any GhostESP command (same as serial CLI) View command output in real time Useful for quick diagnostics and file transfers Limitation: Wi-Fi and BLE commands (e.g., scanap, karma start, blescan) cannot run here because the device\u0026rsquo;s radio is hosting the access point. Running them locally temporarily suspends the AP; to keep GhostNet online, use the Dual Comm tab to send these commands to a paired device instead.\nHelp\rAccess built-in documentation for features and commands:\nWi-Fi: Scanning and attack commands BLE: Bluetooth Low Energy operations Communication: GhostLink dual communication setup SD Card: SD card operations LED / RGB: LED and RGB lighting GPS: GPS functionality Misc: Miscellaneous features Evil Portal: Portal configuration Printer: Power printer features YouTube Cast: YouTube casting Capture: Packet capture modes Beacon: Beacon spam options Attack: Attack command reference GhostLink\rManage a GhostLink connection between a paired ESP32 device:\nView connection status Send commands to the paired device Monitor GhostLink link health Important Limitations\rWi-Fi and BLE Commands Require GhostLink\rThe WebUI cannot directly run Wi-Fi or BLE commands (e.g., scanap, karma start, blescan). These commands require the device\u0026rsquo;s radio hardware, which conflicts with hosting the Wi-Fi access point.\nTo run Wi-Fi or BLE commands from the WebUI:\nSet up GhostLink with two ESP32 devices wired together. One device hosts the access point (runs WebUI). The other device performs attacks/scans. Send commands through the WebUI using commsend \u0026lt;command\u0026gt;. Example workflow:\nDevice A (with WebUI): Hosts GhostNet AP Device B (attack device): Wired to Device A via UART From WebUI on Device A: commsend scanap → scans on Device B From WebUI on Device A: commsend karma start → runs Karma on Device B Commands that work directly in WebUI:\rNFC commands (scanning, writing, saving) Infrared commands (learning, transmitting) File management Device configuration Help and diagnostics Tips and Tricks\rFaster File Transfers\rUse a card reader for faster file transfers. The WebUI file manager is convenient but slower over Wi-Fi. Toggle Authentication When Needed\rwebauth on — enable HTTP Digest authentication for the WebUI. webauth off — return to the default open-access mode. Troubleshooting\rCan\u0026rsquo;t connect to GhostNet\rGhostNet not visible: Reboot the device. It should broadcast the AP within 10 seconds of boot. Connection drops: Move closer to the device or check for interference. Wrong password: Default is GhostNet (case-sensitive). Can\u0026rsquo;t reach the WebUI\rPage won\u0026rsquo;t load: Try 192.168.4.1 instead of ghostesp.local. \u0026ldquo;Connection refused\u0026rdquo;: The device may still be booting. Wait 10 seconds and refresh. Timeout: Check that you\u0026rsquo;re connected to the GhostNet AP, not a different network. Login fails\rAuthentication prompts unexpectedly: Run webauth off to confirm the feature is disabled. Credentials rejected: If you enabled auth, defaults are GhostNet / GhostNet (case-sensitive). Forgot credentials: Reboot the device to reset to defaults. Wi-Fi commands don\u0026rsquo;t work\r\u0026ldquo;Command not available\u0026rdquo;: You need GhostLink. See GhostLink for setup. Command times out: Verify the second device is wired correctly and powered on. File manager is slow\rDownloads are slow: Use a USB card reader instead. Uploads fail: Ensure the SD card has free space and is properly mounted. Next Steps\rSet up GhostLink to run Wi-Fi and BLE attacks from the WebUI. Explore the Command Line Reference for available commands. Review Wi-Fi Basics to learn about attacks and scanning. ","description":"Access and control GhostESP through the web interface.","permalink":"/v1.9/getting-started/webui-guide/","title":"WebUI"},{"content":"Create a fake Wi-Fi network that shows a login page when users connect.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rSD card inserted and mounted. Portal files saved to the SD card (optional; there\u0026rsquo;s a default portal built in). Custom portal files go in /mnt/ghostesp/evil_portal/portals/ on the SD card. Place your HTML (and any referenced assets) there so listportals can find them. Starting a portal\rOn-device UI\rOpen WiFi → Evil Portal → Start Evil Portal. The device will launch the built-in default portal. To use a custom HTML page, choose Start Custom Evil Portal instead. Select your page and enter the network name and optional password. The portal is now running. Clients connecting to the network will see a login page. To stop, go back to the menu or run stopportal in the terminal. From the Flipper app\rOn the Flipper app, open WiFi → Evil Portal \u0026amp; Network → Set Evil Portal HTML. Pick your HTML file (up to 2048 bytes) from the file browser; it is sent and stored for the next start. Back in Evil Portal, choose Evil Portal to run the command. The UI appends startportal and prompts for arguments. Command format: startportal file/default SSID PSK. SSID/PSK should be entered without spaces (use dashes/underscores instead) or the command parser will split them incorrectly. If you already pushed HTML from the Flipper app, enter default for \u0026lt;file\u0026gt; to use the stored page automatically. Clients connecting to the network will see your uploaded portal. Command line\rRun listportals to see available portal pages. Run startportal default MyNetworkName to start with the built-in portal. Or use startportal mypage.html MyNetworkName for a custom page. (Optional) Add a password: startportal mypage.html MyNetworkName MyPassword. Avoid spaces in SSID/PSK here as well; use dashes/underscores so the CLI doesn\u0026rsquo;t misparse arguments. Run stopportal or stop to shut it down. What gets recorded\rSubmitted credentials are saved to /mnt/ghostesp/evil_portal/portal_creds_\u0026lt;n\u0026gt;.txt on the SD card. Keystrokes are logged to /mnt/ghostesp/evil_portal/portal_keystrokes_\u0026lt;n\u0026gt;.txt. Testing the portal\rConnect to the network from another device. Open a web browser and navigate to any website. You should see the login page instead. Submit test credentials. Check the SD card files to confirm they were recorded. Tips\rKeep custom portal pages simple and small for faster loading. Use a card reader to transfer files to/from the SD card quickly. Troubleshooting\rNo portal pages found: Make sure the SD card is mounted and has a /mnt/ghostesp/evil_portal/portals/ folder. Credentials not being saved: Verify the SD card has free space and is properly mounted. Clients don\u0026rsquo;t see the login page: Try opening a new browser tab or clearing the browser cache on the client device. Also make sure any \u0026lsquo;Private DNS\u0026rsquo; or similar setting on the client is turned off. ","description":"Host a fake Wi-Fi login page to test security awareness.","permalink":"/latest/wifi/evil-portal/","title":"Evil Portal"},{"content":"Create a fake Wi-Fi network that shows a login page when users connect.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rSD card inserted and mounted. Portal files saved to the SD card (optional; there\u0026rsquo;s a default portal built in). Starting a portal\rOn-device UI\rOpen WiFi → Evil Portal → Start Evil Portal. The device will launch the built-in default portal. To use a custom HTML page, choose Start Custom Evil Portal instead. Select your page and enter the network name and optional password. The portal is now running. Clients connecting to the network will see a login page. To stop, go back to the menu or run stopportal in the terminal. Command line\rRun listportals to see available portal pages. Run startportal default MyNetworkName to start with the built-in portal. Or use startportal mypage.html MyNetworkName for a custom page. (Optional) Add a password: startportal mypage.html MyNetworkName MyPassword. Run stopportal or stop to shut it down. What gets recorded\rSubmitted credentials are saved to /mnt/ghostesp/evil_portal/portal_creds_\u0026lt;n\u0026gt;.txt on the SD card. Keystrokes are logged to /mnt/ghostesp/evil_portal/portal_keystrokes_\u0026lt;n\u0026gt;.txt. Testing the portal\rConnect to the network from another device. Open a web browser and navigate to any website. You should see the login page instead. Submit test credentials. Check the SD card files to confirm they were recorded. Tips\rKeep custom portal pages simple and small for faster loading. Use a card reader to transfer files to/from the SD card quickly. Troubleshooting\rNo portal pages found: Make sure the SD card is mounted and has a /mnt/ghostesp/evil_portal/portals/ folder. Credentials not being saved: Verify the SD card has free space and is properly mounted. Clients don\u0026rsquo;t see the login page: Try opening a new browser tab or clearing the browser cache on the client device. Also make sure any \u0026lsquo;Private DNS\u0026rsquo; or similar setting on the client is turned off. ","description":"Host a fake Wi-Fi login page to test security awareness.","permalink":"/v1.8.1/wifi/evil-portal/","title":"Evil Portal"},{"content":"Create a fake Wi-Fi network that shows a login page when users connect.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rSD card inserted and mounted. Portal files saved to the SD card (optional; there\u0026rsquo;s a default portal built in). Starting a portal\rOn-device UI\rOpen WiFi → Evil Portal → Start Evil Portal. The device will launch the built-in default portal. To use a custom HTML page, choose Start Custom Evil Portal instead. Select your page and enter the network name and optional password. The portal is now running. Clients connecting to the network will see a login page. To stop, go back to the menu or run stopportal in the terminal. Command line\rRun listportals to see available portal pages. Run startportal default MyNetworkName to start with the built-in portal. Or use startportal mypage.html MyNetworkName for a custom page. (Optional) Add a password: startportal mypage.html MyNetworkName MyPassword. Run stopportal or stop to shut it down. What gets recorded\rSubmitted credentials are saved to /mnt/ghostesp/evil_portal/portal_creds_\u0026lt;n\u0026gt;.txt on the SD card. Keystrokes are logged to /mnt/ghostesp/evil_portal/portal_keystrokes_\u0026lt;n\u0026gt;.txt. Testing the portal\rConnect to the network from another device. Open a web browser and navigate to any website. You should see the login page instead. Submit test credentials. Check the SD card files to confirm they were recorded. Tips\rKeep custom portal pages simple and small for faster loading. Use a card reader to transfer files to/from the SD card quickly. Troubleshooting\rNo portal pages found: Make sure the SD card is mounted and has a /mnt/ghostesp/evil_portal/portals/ folder. Credentials not being saved: Verify the SD card has free space and is properly mounted. Clients don\u0026rsquo;t see the login page: Try opening a new browser tab or clearing the browser cache on the client device. Also make sure any \u0026lsquo;Private DNS\u0026rsquo; or similar setting on the client is turned off. ","description":"Host a fake Wi-Fi login page to test security awareness.","permalink":"/v1.8/wifi/evil-portal/","title":"Evil Portal"},{"content":"Create a fake Wi-Fi network that shows a login page when users connect.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rSD card inserted and mounted. Portal files saved to the SD card (optional; there\u0026rsquo;s a default portal built in). Custom portal files go in /mnt/ghostesp/evil_portal/portals/ on the SD card. Place your HTML (and any referenced assets) there so listportals can find them. Starting a portal\rOn-device UI\rOpen WiFi → Evil Portal → Start Evil Portal. The device will launch the built-in default portal. To use a custom HTML page, choose Start Custom Evil Portal instead. Select your page and enter the network name and optional password. The portal is now running. Clients connecting to the network will see a login page. To stop, go back to the menu or run stopportal in the terminal. From the Flipper app\rOn the Flipper app, open WiFi → Evil Portal \u0026amp; Network → Set Evil Portal HTML. Pick your HTML file (up to 2048 bytes) from the file browser; it is sent and stored for the next start. Back in Evil Portal, choose Evil Portal to run the command. The UI appends startportal and prompts for arguments. Command format: startportal file/default SSID PSK. SSID/PSK should be entered without spaces (use dashes/underscores instead) or the command parser will split them incorrectly. If you already pushed HTML from the Flipper app, enter default for \u0026lt;file\u0026gt; to use the stored page automatically. Clients connecting to the network will see your uploaded portal. Command line\rRun listportals to see available portal pages. Run startportal default MyNetworkName to start with the built-in portal. Or use startportal mypage.html MyNetworkName for a custom page. (Optional) Add a password: startportal mypage.html MyNetworkName MyPassword. Avoid spaces in SSID/PSK here as well; use dashes/underscores so the CLI doesn\u0026rsquo;t misparse arguments. Run stopportal or stop to shut it down. What gets recorded\rSubmitted credentials are saved to /mnt/ghostesp/evil_portal/portal_creds_\u0026lt;n\u0026gt;.txt on the SD card. Keystrokes are logged to /mnt/ghostesp/evil_portal/portal_keystrokes_\u0026lt;n\u0026gt;.txt. Testing the portal\rConnect to the network from another device. Open a web browser and navigate to any website. You should see the login page instead. Submit test credentials. Check the SD card files to confirm they were recorded. Tips\rKeep custom portal pages simple and small for faster loading. Use a card reader to transfer files to/from the SD card quickly. Troubleshooting\rNo portal pages found: Make sure the SD card is mounted and has a /mnt/ghostesp/evil_portal/portals/ folder. Credentials not being saved: Verify the SD card has free space and is properly mounted. Clients don\u0026rsquo;t see the login page: Try opening a new browser tab or clearing the browser cache on the client device. Also make sure any \u0026lsquo;Private DNS\u0026rsquo; or similar setting on the client is turned off. ","description":"Host a fake Wi-Fi login page to test security awareness.","permalink":"/v1.9/wifi/evil-portal/","title":"Evil Portal"},{"content":"\rFrequently Asked Questions\r1. What are the default network credentials?\rSSID: GhostNet Password: GhostNet 2. What are the default credentials for the web interface?\rAuthentication is off by default in v1.8.1. If you enable it with webauth on, the defaults are: Username: GhostNet Password: GhostNet 3. How do I access the web interface?\rConnect to the GhostNet WiFi network. Open your browser and visit: ghostesp.local or 192.168.4.1 4. Why don’t the default credentials work for the web interface?\rThe web interface uses the same credentials as your WiFi AP. If you’ve changed your WiFi SSID or password, your web interface credentials also change. To disable authentication, open the GhostESP terminal or a serial console and run webauth off, then restart the device. Note\nThe firmware has a subtle password-length mismatch: the AP code falls back to the default password unless the saved password is longer than 8 characters, while web authentication treats passwords of length 8 as valid. If you set an exactly 8-character password you may see the web UI and AP use different credentials; use a password longer than 8 characters to avoid this.\n5. How do I flash my board?\rSee the Installation Guide. Use the web flasher at: https://flasher.ghostesp.net/ 6. Can I upload custom Evil Portal HTML over Serial or from my Flipper Zero?\rSD Card: Place custom HTML in /ghostesp/evil_portal/portals on your SD card. Flipper Zero App: You can upload simple HTML (max 2048 bytes) directly via the app (v1.4+ and firmware v1.7+). 7. My board isn’t currently supported. Will you add support?\rUnless something is said otherwise, no. Feel free to do it yourself—we accept and appreciate PRs. 8. Why does my connection to the GhostESP AP drop when issuing WiFi commands?\rThe ESP32 can’t operate as both an Access Point and WiFi Client at the same time. Switching modes will disconnect your device from the AP. 9. I’m not seeing any output when connecting via Serial.\rThe firmware is silent unless a command is running. Try sending the help command to verify your connection or reconnecting; sometimes you will have a bad connection. 10. Why won’t my SD card work?\r\u0026ldquo;Generic\u0026rdquo; firmware builds include SD card support by default; use sd_config to see the pins or sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; to set SPI pins and sd_save_config to save the pin config to SD card. Ensure your SD card is formatted as FAT32. Try using a SanDisk brand SD card 32GB or less. ","description":"Frequently asked questions about GhostESP setup, credentials, and troubleshooting.","permalink":"/latest/getting-started/faq/","title":"FAQ"},{"content":"\rFrequently Asked Questions\r1. What are the default network credentials?\rSSID: GhostNet Password: GhostNet 2. What are the default credentials for the web interface?\rAuthentication is off by default in v1.8.1. If you enable it with webauth on, the defaults are: Username: GhostNet Password: GhostNet 3. How do I access the web interface?\rConnect to the GhostNet WiFi network. Open your browser and visit: ghostesp.local or 192.168.4.1 4. Why don’t the default credentials work for the web interface?\rThe web interface uses the same credentials as your WiFi AP. If you’ve changed your WiFi SSID or password, your web interface credentials also change. To disable authentication, open the GhostESP terminal or a serial console and run webauth off, then restart the device. Note\nThe firmware has a subtle password-length mismatch: the AP code falls back to the default password unless the saved password is longer than 8 characters, while web authentication treats passwords of length 8 as valid. If you set an exactly 8-character password you may see the web UI and AP use different credentials; use a password longer than 8 characters to avoid this.\n5. How do I flash my board?\rSee the Installation Guide. Use the web flasher at: https://flasher.ghostesp.net/ 6. Can I upload custom Evil Portal HTML over Serial or from my Flipper Zero?\rSD Card: Place custom HTML in /ghostesp/evil_portal/portals on your SD card. Flipper Zero App: You can upload simple HTML (max 2048 bytes) directly via the app (v1.4+ and firmware v1.7+). 7. My board isn’t currently supported. Will you add support?\rUnless something is said otherwise, no. Feel free to do it yourself—we accept and appreciate PRs. 8. Why does my connection to the GhostESP AP drop when issuing WiFi commands?\rThe ESP32 can’t operate as both an Access Point and WiFi Client at the same time. Switching modes will disconnect your device from the AP. 9. I’m not seeing any output when connecting via Serial.\rThe firmware is silent unless a command is running. Try sending the help command to verify your connection or reconnecting; sometimes you will have a bad connection. 10. Why won’t my SD card work?\r\u0026ldquo;Generic\u0026rdquo; firmware builds include SD card support by default; use sd_config to see the pins or sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; to set SPI pins and sd_save_config to save the pin config to SD card. Ensure your SD card is formatted as FAT32. Try using a SanDisk brand SD card 32GB or less. ","description":"Frequently asked questions about GhostESP setup, credentials, and troubleshooting.","permalink":"/v1.8.1/getting-started/faq/","title":"FAQ"},{"content":"\rFrequently Asked Questions\r1. What are the default network credentials?\rSSID: GhostNet Password: GhostNet 2. What are the default credentials for the web interface?\rUsername: GhostNet Password: GhostNet 3. How do I access the web interface?\rConnect to the GhostNet WiFi network. Open your browser and visit: ghostesp.local or 192.168.4.1 4. Why don’t the default credentials work for the web interface?\rThe web interface uses the same credentials as your WiFi AP. If you’ve changed your WiFi SSID or password, your web interface credentials also change. If you want to disable authentication entirely, open the GhostESP terminal or a serial console and run webauth off, then restart the device. Note\nThe firmware has a subtle password-length mismatch: the AP code falls back to the default password unless the saved password is longer than 8 characters, while web authentication treats passwords of length 8 as valid. If you set an exactly 8-character password you may see the web UI and AP use different credentials; use a password longer than 8 characters to avoid this.\n5. How do I flash my board?\rSee the Installation Guide. Use the web flasher at: https://flasher.ghostesp.net/ 6. Can I upload custom Evil Portal HTML over Serial or from my Flipper Zero?\rSD Card: Place custom HTML in /ghostesp/evil_portal/portals on your SD card. Flipper Zero App: You can upload simple HTML (max 2048 bytes) directly via the app (v1.4+ and firmware v1.7+). 7. My board isn’t currently supported. Will you add support?\rUnless something is said otherwise, no. Feel free to do it yourself—we accept and appreciate PRs. 8. Why does my connection to the GhostESP AP drop when issuing WiFi commands?\rThe ESP32 can’t operate as both an Access Point and WiFi Client at the same time. Switching modes will disconnect your device from the AP. 9. I’m not seeing any output when connecting via Serial.\rThe firmware is silent unless a command is running. Try sending the help command to verify your connection or reconnecting; sometimes you will have a bad connection. 10. Why won’t my SD card work?\r\u0026ldquo;Generic\u0026rdquo; firmware builds include SD card support by default; use sd_config to see the pins or sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; to set SPI pins and sd_save_config to save the pin config to SD card. Ensure your SD card is formatted as FAT32. Try using a SanDisk brand SD card 32GB or less. ","description":"Frequently asked questions about GhostESP setup, credentials, and troubleshooting.","permalink":"/v1.8/getting-started/faq/","title":"FAQ"},{"content":"\rFrequently Asked Questions\r1. What are the default network credentials?\rSSID: GhostNet Password: GhostNet 2. What are the default credentials for the web interface?\rAuthentication is off by default in v1.8.1. If you enable it with webauth on, the defaults are: Username: GhostNet Password: GhostNet 3. How do I access the web interface?\rConnect to the GhostNet WiFi network. Open your browser and visit: ghostesp.local or 192.168.4.1 4. Why don’t the default credentials work for the web interface?\rThe web interface uses the same credentials as your WiFi AP. If you’ve changed your WiFi SSID or password, your web interface credentials also change. To disable authentication, open the GhostESP terminal or a serial console and run webauth off, then restart the device. Note\nThe firmware has a subtle password-length mismatch: the AP code falls back to the default password unless the saved password is longer than 8 characters, while web authentication treats passwords of length 8 as valid. If you set an exactly 8-character password you may see the web UI and AP use different credentials; use a password longer than 8 characters to avoid this.\n5. How do I flash my board?\rSee the Installation Guide. Use the web flasher at: https://flasher.ghostesp.net/ 6. Can I upload custom Evil Portal HTML over Serial or from my Flipper Zero?\rSD Card: Place custom HTML in /ghostesp/evil_portal/portals on your SD card. Flipper Zero App: You can upload simple HTML (max 2048 bytes) directly via the app (v1.4+ and firmware v1.7+). 7. My board isn’t currently supported. Will you add support?\rUnless something is said otherwise, no. Feel free to do it yourself—we accept and appreciate PRs. 8. Why does my connection to the GhostESP AP drop when issuing WiFi commands?\rThe ESP32 can’t operate as both an Access Point and WiFi Client at the same time. Switching modes will disconnect your device from the AP. 9. I’m not seeing any output when connecting via Serial.\rThe firmware is silent unless a command is running. Try sending the help command to verify your connection or reconnecting; sometimes you will have a bad connection. 10. Why won’t my SD card work?\r\u0026ldquo;Generic\u0026rdquo; firmware builds include SD card support by default; use sd_config to see the pins or sd_pins_spi \u0026lt;cs\u0026gt; \u0026lt;clk\u0026gt; \u0026lt;miso\u0026gt; \u0026lt;mosi\u0026gt; to set SPI pins and sd_save_config to save the pin config to SD card. Ensure your SD card is formatted as FAT32. Try using a SanDisk brand SD card 32GB or less. ","description":"Frequently asked questions about GhostESP setup, credentials, and troubleshooting.","permalink":"/v1.9/getting-started/faq/","title":"FAQ"},{"content":"\rSupported boards\rGhostESP exposes IR features only when the board is built with IR RX or TX enabled.\nLilyGo S3TWatch — IR transmit ESP32-S3 Cardputer / Cardputer ADV — IR transmit LilyGo TEmbed C1101 — IR transmit and receive Other boards may ship with TX-only support or no IR hardware at all. Look for infrared support listed in the release notes or above before flashing.\nWiring and Developer notes\rIR LED: Connected to CONFIG_INFRARED_LED_PIN. Use a current-limiting resistor if adding an external LED. IR Receiver: Required for learning. Boards with CONFIG_HAS_INFRARED_RX set expose the pin via CONFIG_INFRARED_RX_PIN. Power and positioning\rKeep the LED unobstructed and aimed at the target device. For learning, place the source remote close to the receiver window and shield it from direct sunlight or fluorescent flicker. ","description":"Boards and peripherals required for GhostESP infrared","permalink":"/latest/infrared/hardware/","title":"Hardware Support"},{"content":"\rSupported boards\rGhostESP exposes Infrared features only when the target board is built with Infrared RX or TX enabled\nLilyGo S3TWatch — IR transmit ESP32-S3 Cardputer / Cardputer ADV — IR transmit LilyGo TEmbed C1101 — IR transmit and receive Other boards may ship with TX-only support or no IR hardware at all. Look for infrared support listed in the release notes or above before flashing.\nWiring and Developer notes\rIR LED: Connected to the configured TX pin (CONFIG_INFRARED_LED_PIN). Ensure correct polarity and a current-limiting resistor if you add an external LED. IR Receiver: Required for learning. Boards with CONFIG_HAS_INFRARED_RX set expose the pin via CONFIG_INFRARED_RX_PIN. Power and positioning\rKeep the LED unobstructed; align it with the target device for reliable transmission. For learning, place the source remote close to the receiver window and shield it from direct sunlight or fluorescent flicker. ","description":"Boards and peripherals required for GhostESP infrared","permalink":"/v1.8.1/infrared/hardware/","title":"Hardware Support"},{"content":"\rSupported boards\rGhostESP exposes Infrared features only when the target board is built with Infrared RX or TX enabled\nLilyGo S3TWatch — IR transmit ESP32-S3 Cardputer / Cardputer ADV — IR transmit LilyGo TEmbed C1101 — IR transmit and receive Other boards may ship with TX-only support or no IR hardware at all. Look for infrared support listed in the release notes or above before flashing.\nWiring and Developer notes\rIR LED: Connected to the configured TX pin (CONFIG_INFRARED_LED_PIN). Ensure correct polarity and a current-limiting resistor if you add an external LED. IR Receiver: Required for learning. Boards with CONFIG_HAS_INFRARED_RX set expose the pin via CONFIG_INFRARED_RX_PIN. Power and positioning\rKeep the LED unobstructed; align it with the target device for reliable transmission. For learning, place the source remote close to the receiver window and shield it from direct sunlight or fluorescent flicker. ","description":"Boards and peripherals required for GhostESP infrared","permalink":"/v1.8/infrared/hardware/","title":"Hardware Support"},{"content":"\rSupported boards\rGhostESP exposes IR features only when the board is built with IR RX or TX enabled.\nLilyGo S3TWatch — IR transmit ESP32-S3 Cardputer / Cardputer ADV — IR transmit LilyGo TEmbed C1101 — IR transmit and receive Other boards may ship with TX-only support or no IR hardware at all. Look for infrared support listed in the release notes or above before flashing.\nWiring and Developer notes\rIR LED: Connected to CONFIG_INFRARED_LED_PIN. Use a current-limiting resistor if adding an external LED. IR Receiver: Required for learning. Boards with CONFIG_HAS_INFRARED_RX set expose the pin via CONFIG_INFRARED_RX_PIN. Power and positioning\rKeep the LED unobstructed and aimed at the target device. For learning, place the source remote close to the receiver window and shield it from direct sunlight or fluorescent flicker. ","description":"Boards and peripherals required for GhostESP infrared","permalink":"/v1.9/infrared/hardware/","title":"Hardware Support"},{"content":"GhostESP uses SD cards to store captures, logs, and files. Learn how to manage files and configure pins.\nStorage Structure\rWhen initialized, GhostESP creates the following directory structure:\n/mnt/ghostesp/\r├── debug/ # Debug logs\r├── pcaps/ # Packet captures\r├── scans/ # Scan results\r├── gps/ # GPS/wardriving logs\r├── games/ # Game saves\r├── evil_portal/\r│ └── portals/ # Custom portal HTML files\r├── infrared/\r│ ├── remotes/ # Learned IR signals\r│ └── universals/ # Universal IR databases\r└── nfc/ # NFC card data (if enabled) Web Serial Interface\rFor the easiest file management experience, use the Web Serial Interface at:\nghostesp.net/serial\nThis browser-based tool connects directly to your GhostESP via USB and provides:\nFile Browser — Browse, upload, and download files using the SD CLI Serial Console — Full terminal access to all CLI commands Screen Mirror — View your device\u0026rsquo;s display in real-time Note: Requires a Chromium-based browser (Chrome, Edge, Brave) with Web Serial API support.\nWebUI File Manager\rAccess the SD card through the WebUI\u0026rsquo;s SD Card tab:\nConnect to GhostNet and open 192.168.4.1 or ghostesp.local Navigate to the SD Card tab Browse the /mnt/ghostesp/ directory structure Capabilities\rNavigate — Click folders to browse Download — Download PCAP captures, logs, and other files Upload — Add custom portal HTML files or IR remotes Delete — Remove files to free space Tip: For large file transfers (\u0026gt;1MB), use a USB card reader for faster speeds.\nCLI Commands\rThe sd command allows scripting and direct file access.\nStatus\rsd status Output format:\nSD:STATUS:mounted=true\rSD:STATUS:type=physical\rSD:STATUS:name=SD32G\rSD:STATUS:capacity_mb=30436\rSD:STATUS:used_pct=12\rSD:STATUS:free_mb=26784 List Files\rsd list [path] Lists files and directories with indices for quick reference:\nSD:LIST:/mnt/ghostesp\rSD:DIR:[0] pcaps\rSD:DIR:[1] scans\rSD:FILE:[2] config.txt 1024\rSD:FILE:[3] log.csv 8192\rSD:OK:listed 4 entries Use indices in subsequent commands:\nsd info 2 # Get info for config.txt\rsd cat 3 1000 # Read first 1000 bytes of log.csv File Info\rsd info \u0026lt;index|path\u0026gt; Shows file or directory details:\nSD:INFO:path=/mnt/ghostesp/pcaps/capture.pcap\rSD:INFO:type=file\rSD:INFO:size=524288\rSD:OK Read File\rsd read \u0026lt;index|path\u0026gt; [offset] [length] Reads file contents with optional offset and length for chunked downloads. No size limit:\nSD:READ:BEGIN:/mnt/ghostesp/capture.pcap\rSD:READ:SIZE:1048576\rSD:READ:OFFSET:0\rSD:READ:LENGTH:65536\r... binary file contents ...\rSD:READ:END:bytes=65536\rSD:OK Example chunked download:\nsd read myfile.bin 0 65536 # First 64KB\rsd read myfile.bin 65536 65536 # Next 64KB\rsd read myfile.bin 131072 65536 # Next 64KB... File Size\rsd size \u0026lt;index|path\u0026gt; Quick file size check (useful before downloads):\nSD:SIZE:1048576\rSD:OK Write File\rsd write \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; Creates or overwrites a file with base64-decoded data:\nsd write myfile.txt SGVsbG8gV29ybGQh\rSD:WRITE:bytes=12\rSD:OK:created:/mnt/ghostesp/myfile.txt Append to File\rsd append \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; Appends base64-decoded data to an existing file:\nsd append myfile.txt IG1vcmUgZGF0YQ==\rSD:APPEND:bytes=10\rSD:OK:appended:/mnt/ghostesp/myfile.txt Note: For large file uploads via WebUI, use the HTTP API which handles binary data directly. The CLI uses base64 encoding due to serial protocol limitations.\nCreate Directory\rsd mkdir \u0026lt;path\u0026gt; Creates a new directory:\nsd mkdir mydata\rSD:OK:created:/mnt/ghostesp/mydata Delete\rsd rm \u0026lt;index|path\u0026gt; Removes a file or empty directory:\nsd rm 2\rSD:OK:removed:/mnt/ghostesp/config.txt Tree View\rsd tree [path] [depth] Recursive directory listing (default depth: 2, max: 10):\nSD:TREE:/mnt/ghostesp\r[D] pcaps/\r[F] capture_001.pcap (524288)\r[F] capture_002.pcap (131072)\r[D] scans/\r[D] infrared/\r[D] remotes/\rSD:OK:tree 5 items Pin Configuration\rSD card pins can be reconfigured at runtime without recompiling.\nSPI Mode\rMost boards use SPI mode. Configure pins with:\nsd_pins_spi \u0026lt;CS\u0026gt; \u0026lt;CLK\u0026gt; \u0026lt;MISO\u0026gt; \u0026lt;MOSI\u0026gt; Example:\nsd_pins_spi 5 18 19 23\rsd_save_config SDMMC Mode\rSome boards support faster SDMMC (1-bit or 4-bit):\nsd_pins_mmc \u0026lt;CLK\u0026gt; \u0026lt;CMD\u0026gt; \u0026lt;D0\u0026gt; \u0026lt;D1\u0026gt; \u0026lt;D2\u0026gt; \u0026lt;D3\u0026gt; Example (4-bit):\nsd_pins_mmc 39 38 40 41 42 2\rsd_save_config View Current Config\rsd_config Shows current pin assignments for both modes.\nSave Configuration\rsd_save_config Persists pin settings to NVS. Changes apply on next boot.\nVirtual Storage\rDevices without SD slots (like S3TWatch) use internal flash as virtual storage (limited to ~4MB).\nCheck storage type:\nsd status Output:\nSD:STATUS:mounted=true\rSD:STATUS:type=virtual Machine-Parsable Output\rAll sd command responses use a consistent format for scripting:\nPrefix Meaning SD:OK:... Success with optional message SD:ERR:... Error with reason SD:STATUS:key=value Status key-value pair SD:LIST:path Directory listing header SD:DIR:[n] name Directory entry with index SD:FILE:[n] name size File entry with index and size SD:INFO:key=value File info key-value pair SD:CAT:BEGIN:path File content start marker SD:CAT:END:bytes=n File content end marker SD:TREE:path Tree listing header SD:EMPTY Empty directory Troubleshooting\rSD Card Not Detected\rVerify the card is formatted as FAT32 Check pin configuration matches your hardware Ensure the card is fully inserted Try a different SD card Mount Failures\rsd status\rSD:STATUS:mounted=false Run sd_config to verify pin settings Some boards require specific pin configurations at compile time Slow Transfers\rUse a Class 10 or higher SD card For large files, use a USB card reader instead of WebUI Reduce concurrent operations Next Steps\rWebUI Guide — File manager and settings Command Line Reference — Full CLI documentation Infrared — Store IR remotes on SD card ","description":"Using SD card storage with GhostESP for file management, captures, and configuration.","permalink":"/latest/getting-started/sd-card/","title":"SD Card"},{"content":"GhostESP uses SD cards to store captures, logs, and files. Learn how to manage files and configure pins.\nStorage Structure\rWhen initialized, GhostESP creates the following directory structure:\n/mnt/ghostesp/\r├── debug/ # Debug logs\r├── pcaps/ # Packet captures\r├── scans/ # Scan results\r├── gps/ # GPS/wardriving logs\r├── games/ # Game saves\r├── evil_portal/\r│ └── portals/ # Custom portal HTML files\r├── infrared/\r│ ├── remotes/ # Learned IR signals\r│ └── universals/ # Universal IR databases\r└── nfc/ # NFC card data (if enabled) Web Serial Interface\rFor the easiest file management experience, use the Web Serial Interface at:\nghostesp.net/serial\nThis browser-based tool connects directly to your GhostESP via USB and provides:\nFile Browser — Browse, upload, and download files using the SD CLI Serial Console — Full terminal access to all CLI commands Screen Mirror — View your device\u0026rsquo;s display in real-time Note: Requires a Chromium-based browser (Chrome, Edge, Brave) with Web Serial API support.\nWebUI File Manager\rAccess the SD card through the WebUI\u0026rsquo;s SD Card tab:\nConnect to GhostNet and open 192.168.4.1 or ghostesp.local Navigate to the SD Card tab Browse the /mnt/ghostesp/ directory structure Capabilities\rNavigate — Click folders to browse Download — Download PCAP captures, logs, and other files Upload — Add custom portal HTML files or IR remotes Delete — Remove files to free space Tip: For large file transfers (\u0026gt;1MB), use a USB card reader for faster speeds.\nCLI Commands\rThe sd command allows scripting and direct file access.\nStatus\rsd status Output format:\nSD:STATUS:mounted=true\rSD:STATUS:type=physical\rSD:STATUS:name=SD32G\rSD:STATUS:capacity_mb=30436\rSD:STATUS:used_pct=12\rSD:STATUS:free_mb=26784 List Files\rsd list [path] Lists files and directories with indices for quick reference:\nSD:LIST:/mnt/ghostesp\rSD:DIR:[0] pcaps\rSD:DIR:[1] scans\rSD:FILE:[2] config.txt 1024\rSD:FILE:[3] log.csv 8192\rSD:OK:listed 4 entries Use indices in subsequent commands:\nsd info 2 # Get info for config.txt\rsd cat 3 1000 # Read first 1000 bytes of log.csv File Info\rsd info \u0026lt;index|path\u0026gt; Shows file or directory details:\nSD:INFO:path=/mnt/ghostesp/pcaps/capture.pcap\rSD:INFO:type=file\rSD:INFO:size=524288\rSD:OK Read File\rsd read \u0026lt;index|path\u0026gt; [offset] [length] Reads file contents with optional offset and length for chunked downloads. No size limit:\nSD:READ:BEGIN:/mnt/ghostesp/capture.pcap\rSD:READ:SIZE:1048576\rSD:READ:OFFSET:0\rSD:READ:LENGTH:65536\r... binary file contents ...\rSD:READ:END:bytes=65536\rSD:OK Example chunked download:\nsd read myfile.bin 0 65536 # First 64KB\rsd read myfile.bin 65536 65536 # Next 64KB\rsd read myfile.bin 131072 65536 # Next 64KB... File Size\rsd size \u0026lt;index|path\u0026gt; Quick file size check (useful before downloads):\nSD:SIZE:1048576\rSD:OK Write File\rsd write \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; Creates or overwrites a file with base64-decoded data:\nsd write myfile.txt SGVsbG8gV29ybGQh\rSD:WRITE:bytes=12\rSD:OK:created:/mnt/ghostesp/myfile.txt Append to File\rsd append \u0026lt;path\u0026gt; \u0026lt;base64data\u0026gt; Appends base64-decoded data to an existing file:\nsd append myfile.txt IG1vcmUgZGF0YQ==\rSD:APPEND:bytes=10\rSD:OK:appended:/mnt/ghostesp/myfile.txt Note: For large file uploads via WebUI, use the HTTP API which handles binary data directly. The CLI uses base64 encoding due to serial protocol limitations.\nCreate Directory\rsd mkdir \u0026lt;path\u0026gt; Creates a new directory:\nsd mkdir mydata\rSD:OK:created:/mnt/ghostesp/mydata Delete\rsd rm \u0026lt;index|path\u0026gt; Removes a file or empty directory:\nsd rm 2\rSD:OK:removed:/mnt/ghostesp/config.txt Tree View\rsd tree [path] [depth] Recursive directory listing (default depth: 2, max: 10):\nSD:TREE:/mnt/ghostesp\r[D] pcaps/\r[F] capture_001.pcap (524288)\r[F] capture_002.pcap (131072)\r[D] scans/\r[D] infrared/\r[D] remotes/\rSD:OK:tree 5 items Pin Configuration\rSD card pins can be reconfigured at runtime without recompiling.\nSPI Mode\rMost boards use SPI mode. Configure pins with:\nsd_pins_spi \u0026lt;CS\u0026gt; \u0026lt;CLK\u0026gt; \u0026lt;MISO\u0026gt; \u0026lt;MOSI\u0026gt; Example:\nsd_pins_spi 5 18 19 23\rsd_save_config SDMMC Mode\rSome boards support faster SDMMC (1-bit or 4-bit):\nsd_pins_mmc \u0026lt;CLK\u0026gt; \u0026lt;CMD\u0026gt; \u0026lt;D0\u0026gt; \u0026lt;D1\u0026gt; \u0026lt;D2\u0026gt; \u0026lt;D3\u0026gt; Example (4-bit):\nsd_pins_mmc 39 38 40 41 42 2\rsd_save_config View Current Config\rsd_config Shows current pin assignments for both modes.\nSave Configuration\rsd_save_config Persists pin settings to NVS. Changes apply on next boot.\nVirtual Storage\rDevices without SD slots (like S3TWatch) use internal flash as virtual storage (limited to ~4MB).\nCheck storage type:\nsd status Output:\nSD:STATUS:mounted=true\rSD:STATUS:type=virtual Machine-Parsable Output\rAll sd command responses use a consistent format for scripting:\nPrefix Meaning SD:OK:... Success with optional message SD:ERR:... Error with reason SD:STATUS:key=value Status key-value pair SD:LIST:path Directory listing header SD:DIR:[n] name Directory entry with index SD:FILE:[n] name size File entry with index and size SD:INFO:key=value File info key-value pair SD:CAT:BEGIN:path File content start marker SD:CAT:END:bytes=n File content end marker SD:TREE:path Tree listing header SD:EMPTY Empty directory Troubleshooting\rSD Card Not Detected\rVerify the card is formatted as FAT32 Check pin configuration matches your hardware Ensure the card is fully inserted Try a different SD card Mount Failures\rsd status\rSD:STATUS:mounted=false Run sd_config to verify pin settings Some boards require specific pin configurations at compile time Slow Transfers\rUse a Class 10 or higher SD card For large files, use a USB card reader instead of WebUI Reduce concurrent operations Next Steps\rWebUI Guide — File manager and settings Command Line Reference — Full CLI documentation Infrared — Store IR remotes on SD card ","description":"Using SD card storage with GhostESP for file management, captures, and configuration.","permalink":"/v1.9/getting-started/sd-card/","title":"SD Card"},{"content":"\rOverview\rGhostESP\u0026rsquo;s PN532 stack focuses on ISO14443A tags. This page summarizes current support.\nNTAG / Ultralight\rModels: NTAG213 (45 pages), NTAG215 (135 pages), NTAG216 (231 pages), and Ultralight variants with similar memory layouts.\nSave: Exports to Flipper .nfc files including UID, header metadata, and all user pages.\nWrite: Supported. GhostESP programs NTAG images back to blank tags, enforcing the original page count before starting.\nNotes: UID is read-only; the saved UID is used for filenames and verification only.\nMIFARE Classic\rModels: 1K, 4K, Mini (via SAK/ATQA detection).\nRead: Sector-by-sector brute-force with layered keys:\nUser dictionary file on the SD card (/mnt/ghostesp/nfc/mfc_user_keys.nfc), which you will have to edit manually. Built-in common keys. Flipper Zero dictionary pre-compiled in. User Dictionary: Successful keys are appended to /mnt/ghostesp/nfc/mfc_user_keys.nfc for future scans.\nSave: Unlocked sectors and recovered keys are stored in Flipper formatted .nfc files.\nWrite: Not currently supported from GhostESP.\nNotes: UI shows progress as “Bruteforcing keys…” and “Reading sectors…” while blocks are cached. Classic tags with the well-known magic backdoor are detected; when enabled, GhostESP can read blocks without authenticating that sector first.\nOther ISO14443A\rDetection: GhostESP reports UID, ATQA, SAK, and basic type info for ISO14443A tags that don’t fit the above categories.\nRead/Write: Not implemented beyond basic presence detection.\nNotes: Future firmware updates may expand support; check release notes for changes.\nUnsupported Families\rMIFARE DESFire / Plus: Not supported. ISO14443B, ISO15693, FeliCa: Not supported by the current PN532 integration. Emulation / Peer-to-Peer: Not supported. ","description":"Reference for NFC tag support in GhostESP","permalink":"/latest/nfc/supported/","title":"Supported Tags"},{"content":"\rOverview\rGhostESP’s PN532 stack focuses on ISO14443A tags. This page summarizes what the firmware supports today and what the UI exposes for each family.\nNTAG / Ultralight\rModels: NTAG213 (45 pages), NTAG215 (135 pages), NTAG216 (231 pages), and Ultralight variants with similar memory layouts.\nRead: Full user memory, signature, version, and counter/tearing registers. NDEF TLVs are parsed into human-readable summaries.\nSave: Exports to Flipper .nfc files including UID, header metadata, and all user pages.\nWrite: Supported. GhostESP programs NTAG images back to blank tags, enforcing the original page count before starting.\nNotes: UID is read-only; the saved UID is used for filenames and verification only.\nMIFARE Classic\rModels: 1K, 4K, Mini (via SAK/ATQA detection).\nRead: Sector-by-sector brute-force with layered keys:\nUser dictionary file on the SD card (/mnt/ghostesp/nfc/mfc_user_keys.nfc), which you will have to edit manually. Built-in common keys. Flipper Zero dictionary pre-compiled in. User Dictionary: Successful keys are appended to the user dictionary on the mounted sd card so future scans start with known values.\nSave: Unlocked sectors and recovered keys are stored in Flipper formatted .nfc files.\nWrite: Not currently supported from GhostESP.\nNotes: UI shows progress as “Bruteforcing keys…” and “Reading sectors…” while blocks are cached. Classic tags with the well-known magic backdoor are detected; when enabled, GhostESP can read blocks without authenticating that sector first.\nOther ISO14443A\rDetection: GhostESP reports UID, ATQA, SAK, and basic type info for ISO14443A tags that don’t fit the above categories.\nRead/Write: Not implemented beyond basic presence detection.\nNotes: Future firmware updates may expand support; check release notes for changes.\nUnsupported Families\rMIFARE DESFire / Plus: Not supported. ISO14443B, ISO15693, FeliCa: Not supported by the current PN532 integration. Emulation / Peer-to-Peer: Not supported. ","description":"Reference for NFC tag support in GhostESP","permalink":"/v1.8.1/nfc/supported/","title":"Supported Tags"},{"content":"\rOverview\rGhostESP’s PN532 stack focuses on ISO14443A tags. This page summarizes what the firmware supports today and what the UI exposes for each family.\nNTAG / Ultralight\rModels: NTAG213 (45 pages), NTAG215 (135 pages), NTAG216 (231 pages), and Ultralight variants with similar memory layouts.\nRead: Full user memory, signature, version, and counter/tearing registers. NDEF TLVs are parsed into human-readable summaries.\nSave: Exports to Flipper .nfc files including UID, header metadata, and all user pages.\nWrite: Supported. GhostESP programs NTAG images back to blank tags, enforcing the original page count before starting.\nNotes: UID is read-only; the saved UID is used for filenames and verification only.\nMIFARE Classic\rModels: 1K, 4K, Mini (via SAK/ATQA detection).\nRead: Sector-by-sector brute-force with layered keys:\nUser dictionary file on the SD card (/mnt/ghostesp/nfc/mfc_user_keys.nfc), which you will have to edit manually. Built-in common keys. Flipper Zero dictionary pre-compiled in. User Dictionary: Successful keys are appended to the user dictionary on the mounted sd card so future scans start with known values.\nSave: Unlocked sectors and recovered keys are stored in Flipper formatted .nfc files.\nWrite: Not currently supported from GhostESP.\nNotes: UI shows progress as “Bruteforcing keys…” and “Reading sectors…” while blocks are cached. Classic tags with the well-known magic backdoor are detected; when enabled, GhostESP can read blocks without authenticating that sector first.\nOther ISO14443A\rDetection: GhostESP reports UID, ATQA, SAK, and basic type info for ISO14443A tags that don’t fit the above categories.\nRead/Write: Not implemented beyond basic presence detection.\nNotes: Future firmware updates may expand support; check release notes for changes.\nUnsupported Families\rMIFARE DESFire / Plus: Not supported. ISO14443B, ISO15693, FeliCa: Not supported by the current PN532 integration. Emulation / Peer-to-Peer: Not supported. ","description":"Reference for NFC tag support in GhostESP","permalink":"/v1.8/nfc/supported/","title":"Supported Tags"},{"content":"\rOverview\rGhostESP\u0026rsquo;s PN532 stack focuses on ISO14443A tags. This page summarizes current support.\nNTAG / Ultralight\rModels: NTAG213 (45 pages), NTAG215 (135 pages), NTAG216 (231 pages), and Ultralight variants with similar memory layouts.\nSave: Exports to Flipper .nfc files including UID, header metadata, and all user pages.\nWrite: Supported. GhostESP programs NTAG images back to blank tags, enforcing the original page count before starting.\nNotes: UID is read-only; the saved UID is used for filenames and verification only.\nMIFARE Classic\rModels: 1K, 4K, Mini (via SAK/ATQA detection).\nRead: Sector-by-sector brute-force with layered keys:\nUser dictionary file on the SD card (/mnt/ghostesp/nfc/mfc_user_keys.nfc), which you will have to edit manually. Built-in common keys. Flipper Zero dictionary pre-compiled in. User Dictionary: Successful keys are appended to /mnt/ghostesp/nfc/mfc_user_keys.nfc for future scans.\nSave: Unlocked sectors and recovered keys are stored in Flipper formatted .nfc files.\nWrite: Not currently supported from GhostESP.\nNotes: UI shows progress as “Bruteforcing keys…” and “Reading sectors…” while blocks are cached. Classic tags with the well-known magic backdoor are detected; when enabled, GhostESP can read blocks without authenticating that sector first.\nOther ISO14443A\rDetection: GhostESP reports UID, ATQA, SAK, and basic type info for ISO14443A tags that don’t fit the above categories.\nRead/Write: Not implemented beyond basic presence detection.\nNotes: Future firmware updates may expand support; check release notes for changes.\nUnsupported Families\rMIFARE DESFire / Plus: Not supported. ISO14443B, ISO15693, FeliCa: Not supported by the current PN532 integration. Emulation / Peer-to-Peer: Not supported. ","description":"Reference for NFC tag support in GhostESP","permalink":"/v1.9/nfc/supported/","title":"Supported Tags"},{"content":"Create fake Wi-Fi networks based on SSIDs that nearby devices are searching for. When devices search for a network, Karma broadcasts it back to them.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Optional: SD card for evil portal integration. Legal and ethical\rOnly test on your own devices or with written permission. Never use Karma on networks you don\u0026rsquo;t own. Starting Karma\rOn-device UI\rOpen Menu → WiFi → Attacks → Start Karma Attack. The device will begin learning SSIDs from probe requests. To use specific SSIDs instead, choose Start Karma Attack (Custom SSIDs). Enter the SSIDs you want to broadcast (separated by commas). The device will start broadcasting fake networks. Leave it running to catch devices. To stop, go back to the menu or select Stop Karma Attack. Command line\rRun karma start to begin automatic SSID learning. The device will cache SSIDs from probe requests. Or run karma start SSID1 SSID2 SSID3 to use specific SSIDs. Example: karma start FreeWiFi Starbucks McDonald's Run karma stop when you\u0026rsquo;re done. How it works\rAutomatic mode: Karma listens for Wi-Fi probe requests from nearby devices and broadcasts fake networks with the SSIDs they\u0026rsquo;re searching for.\nCustom mode: You specify which SSIDs to broadcast instead of learning them automatically.\nWhen a device connects to a fake network, a captive portal starts automatically to capture credentials.\nTroubleshooting\rFake networks not appearing: Try restarting with karma stop then karma start. No devices connecting: Ensure devices are actually searching for networks. Try moving closer to the ESP32. ","description":"Automatically respond to device probes with fake networks.","permalink":"/latest/wifi/karma/","title":"Karma Attack"},{"content":"Create fake Wi-Fi networks based on SSIDs that nearby devices are searching for. When devices search for a network, Karma broadcasts it back to them.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Optional: SD card for evil portal integration. Legal and ethical\rOnly test on your own devices or with explicit written permission. Use in controlled environments only. Obtain proper authorization before testing. Stop attacks immediately when testing is complete. Use Karma for educational purposes and authorized security testing only. Never use Karma to attack networks you don\u0026rsquo;t own. Starting Karma\rOn-device UI\rOpen Menu → WiFi → Attacks → Start Karma Attack. The device will begin learning SSIDs from probe requests. To use specific SSIDs instead, choose Start Karma Attack (Custom SSIDs). Enter the SSIDs you want to broadcast (separated by commas). The device will start broadcasting fake networks. Leave it running to catch devices. To stop, go back to the menu or select Stop Karma Attack. Command line\rRun karma start to begin automatic SSID learning. The device will cache SSIDs from probe requests. Or run karma start SSID1 SSID2 SSID3 to use specific SSIDs. Example: karma start FreeWiFi Starbucks McDonald's Run karma stop when you\u0026rsquo;re done. How it works\rAutomatic mode: Karma listens for WiFi probe requests from nearby devices and broadcasts fake networks with the SSIDs they\u0026rsquo;re searching for.\nCustom mode: You specify which SSIDs to broadcast instead of learning them automatically.\nWhen a device connects to a fake network, a captive portal starts automatically to capture credentials.\nTroubleshooting\rFake networks not appearing: Try restarting with karma stop then karma start. No devices connecting: Ensure devices are actually searching for networks. Try moving closer to the ESP32. ","description":"Automatically respond to device probes with fake networks.","permalink":"/v1.8.1/wifi/karma/","title":"Karma Attack"},{"content":"Create fake Wi-Fi networks based on SSIDs that nearby devices are searching for. When devices search for a network, Karma broadcasts it back to them.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Optional: SD card for evil portal integration. Legal and ethical\rOnly test on your own devices or with explicit written permission. Use in controlled environments only. Obtain proper authorization before testing. Stop attacks immediately when testing is complete. Use Karma for educational purposes and authorized security testing only. Never use Karma to attack networks you don\u0026rsquo;t own. Starting Karma\rOn-device UI\rOpen Menu → WiFi → Attacks → Start Karma Attack. The device will begin learning SSIDs from probe requests. To use specific SSIDs instead, choose Start Karma Attack (Custom SSIDs). Enter the SSIDs you want to broadcast (separated by commas). The device will start broadcasting fake networks. Leave it running to catch devices. To stop, go back to the menu or select Stop Karma Attack. Command line\rRun karma start to begin automatic SSID learning. The device will cache SSIDs from probe requests. Or run karma start SSID1 SSID2 SSID3 to use specific SSIDs. Example: karma start FreeWiFi Starbucks McDonald's Run karma stop when you\u0026rsquo;re done. How it works\rAutomatic mode: Karma listens for WiFi probe requests from nearby devices and broadcasts fake networks with the SSIDs they\u0026rsquo;re searching for.\nCustom mode: You specify which SSIDs to broadcast instead of learning them automatically.\nWhen a device connects to a fake network, a captive portal starts automatically to capture credentials.\nTroubleshooting\rFake networks not appearing: Try restarting with karma stop then karma start. No devices connecting: Ensure devices are actually searching for networks. Try moving closer to the ESP32. ","description":"Automatically respond to device probes with fake networks.","permalink":"/v1.8/wifi/karma/","title":"Karma Attack"},{"content":"Create fake Wi-Fi networks based on SSIDs that nearby devices are searching for. When devices search for a network, Karma broadcasts it back to them.\nNote: Only test this on networks you own or have explicit permission to test. Unauthorized access to networks is illegal in most jurisdictions.\nPrerequisites\rGhostESP flashed device, powered on with a wireless antenna. Optional: SD card for evil portal integration. Legal and ethical\rOnly test on your own devices or with written permission. Never use Karma on networks you don\u0026rsquo;t own. Starting Karma\rOn-device UI\rOpen Menu → WiFi → Attacks → Start Karma Attack. The device will begin learning SSIDs from probe requests. To use specific SSIDs instead, choose Start Karma Attack (Custom SSIDs). Enter the SSIDs you want to broadcast (separated by commas). The device will start broadcasting fake networks. Leave it running to catch devices. To stop, go back to the menu or select Stop Karma Attack. Command line\rRun karma start to begin automatic SSID learning. The device will cache SSIDs from probe requests. Or run karma start SSID1 SSID2 SSID3 to use specific SSIDs. Example: karma start FreeWiFi Starbucks McDonald's Run karma stop when you\u0026rsquo;re done. How it works\rAutomatic mode: Karma listens for Wi-Fi probe requests from nearby devices and broadcasts fake networks with the SSIDs they\u0026rsquo;re searching for.\nCustom mode: You specify which SSIDs to broadcast instead of learning them automatically.\nWhen a device connects to a fake network, a captive portal starts automatically to capture credentials.\nTroubleshooting\rFake networks not appearing: Try restarting with karma stop then karma start. No devices connecting: Ensure devices are actually searching for networks. Try moving closer to the ESP32. ","description":"Automatically respond to device probes with fake networks.","permalink":"/v1.9/wifi/karma/","title":"Karma Attack"},{"content":"GhostESP’s aerial detector watches both Wi-Fi and BLE airspace to find Remote ID beacons, DJI links, and drone-branded networks. It alternates radios so scans run reliably on every ESP32 board.\nOverview\rPhase 1 – Wi-Fi sniffing: Promiscuous capture with channel hopping looks for OpenDroneID NAN frames, DJI OUIs, and drone SSIDs. Phase 2 – BLE scanning: Wi-Fi is suspended so BLE can search for OpenDroneID (UUID 0xFFFA) and DJI advertisements (UUID 0xFFE0). Automatic recovery: When BLE stops, GhostNet AP and STA sessions return without user interaction. Prerequisites\rESP32 board with both Wi-Fi and BLE (ESP32-S2 can only run Wi-Fi phase). Latest GhostESP firmware with aerial detector enabled. Serial, GhostLink display, or WebUI terminal access. Optional GPS for pairing detections with coordinates. How to Use\rVia Terminal\rScan for aerial devices (default 30 seconds): aerialscan 30 Review captured drones: aeriallist Track one device by index or MAC: aerialtrack 0 Stop scanning or tracking at any time: aerialstop Via Display\rOpen the on-device BLE menu. Select Aerial Detector. Choose an action such as Scan Aerial Devices, List Aerial Devices, or Track Aerial Device. Wait for the command to finish in the terminal pane, then review the results card. Note for Flipper app: The Aerial Detector submenu is under the Wi-Fi category (not BLE) in the Flipper UI. On-device displays keep it under BLE.\nWhat Gets Detected\rOpenDroneID Remote ID (ASTM F3411) — Wi-Fi NAN frames and BLE service 0xFFFA decode BasicID, Location, System, SelfID, and OperatorID messages. DJI protocols — MAC OUI matching and BLE service 0xFFE0 flag Mavic, Phantom, Inspire, and other DJI links. Drone SSIDs — Pattern matching for DJI, Parrot, Autel, Skydio, and FPV networks. Telemetry frameworks — Optional MAVLink, FrSky Sport, and CRSF signatures when UART monitoring is enabled. Each device record stores MAC, vendor, RSSI, GPS/altitude (if broadcast), operator position, and flight status so you can triage real aircraft versus test spoofers.\nSpoofing Remote ID for Testing\rUse the spoof workflow to broadcast a test drone and confirm your detector (or another receiver) reacts:\naerialspoof DRONE-TEST 37.7749 -122.4194 120 Sends alternating BasicID and Location frames once per second. Wi-Fi remains suspended until you run aerialspoofstop. Pair a second GhostESP, run aerialscan, and verify it lists DRONE-TEST. Troubleshooting\r“Wi-Fi suspended” message: Normal during BLE phase or spoofing. It clears after the command finishes or you run aerialstop. No detections: Increase scan time (aerialscan 60) so each phase lasts longer, or move closer to the suspected drone. ESP32-S2 board: Only Wi-Fi detections work; BLE phase is skipped. Heap errors during repeated scans: Restart your device ","description":"Detect drones, controllers, and OpenDroneID broadcasts with sequential Wi-Fi/BLE sweeps.","permalink":"/latest/wifi/aerial-detection/","title":"Aerial Detection"},{"content":"GhostESP’s aerial detector watches both Wi-Fi and BLE airspace to find Remote ID beacons, DJI links, and drone-branded networks. It alternates radios so scans run reliably on every ESP32 board.\nOverview\rPhase 1 – Wi-Fi sniffing: Promiscuous capture with channel hopping looks for OpenDroneID NAN frames, DJI OUIs, and drone SSIDs. Phase 2 – BLE scanning: Wi-Fi is suspended so BLE can search for OpenDroneID (UUID 0xFFFA) and DJI advertisements (UUID 0xFFE0). Automatic recovery: When BLE stops, GhostNet AP and STA sessions return without user interaction. Prerequisites\rESP32 board with both Wi-Fi and BLE (ESP32-S2 can only run Wi-Fi phase). Latest GhostESP firmware with aerial detector enabled. Serial, GhostLink display, or WebUI terminal access. Optional GPS for pairing detections with coordinates. How to Use\rVia Terminal\rScan for aerial devices (default 30 seconds): aerialscan 30 Review captured drones: aeriallist Track one device by index or MAC: aerialtrack 0 Stop scanning or tracking at any time: aerialstop Via Display\rOpen the on-device BLE menu. Select Aerial Detector. Choose an action such as Scan Aerial Devices, List Aerial Devices, or Track Aerial Device. Wait for the command to finish in the terminal pane, then review the results card. Note for Flipper app: The Aerial Detector submenu is under the Wi-Fi category (not BLE) in the Flipper UI. On-device displays keep it under BLE.\nWhat Gets Detected\rOpenDroneID Remote ID (ASTM F3411) — Wi-Fi NAN frames and BLE service 0xFFFA decode BasicID, Location, System, SelfID, and OperatorID messages. DJI protocols — MAC OUI matching and BLE service 0xFFE0 flag Mavic, Phantom, Inspire, and other DJI links. Drone SSIDs — Pattern matching for DJI, Parrot, Autel, Skydio, and FPV networks. Telemetry frameworks — Optional MAVLink, FrSky Sport, and CRSF signatures when UART monitoring is enabled. Each device record stores MAC, vendor, RSSI, GPS/altitude (if broadcast), operator position, and flight status so you can triage real aircraft versus test spoofers.\nSpoofing Remote ID for Testing\rUse the spoof workflow to broadcast a test drone and confirm your detector (or another receiver) reacts:\naerialspoof DRONE-TEST 37.7749 -122.4194 120 Sends alternating BasicID and Location frames once per second. Wi-Fi remains suspended until you run aerialspoofstop. Pair a second GhostESP, run aerialscan, and verify it lists DRONE-TEST. Troubleshooting\r“Wi-Fi suspended” message: Normal during BLE phase or spoofing. It clears after the command finishes or you run aerialstop. No detections: Increase scan time (aerialscan 60) so each phase lasts longer, or move closer to the suspected drone. ESP32-S2 board: Only Wi-Fi detections work; BLE phase is skipped. Heap errors during repeated scans: Restart your device ","description":"Detect drones, controllers, and OpenDroneID broadcasts with sequential Wi-Fi/BLE sweeps.","permalink":"/v1.9/wifi/aerial-detection/","title":"Aerial Detection"},{"content":"Cast random YouTube videos to all DIAL-enabled devices (Chromecasts, smart TVs, Roku, etc.) on your network.\nNote: Only test this on networks and devices you own or have explicit permission to test.\nPrerequisites\rGhostESP flashed device, powered on. Connected to the same Wi-Fi network as the target devices (run connect SSID PASSWORD first). DIAL-enabled devices on the network (Chromecast, smart TV with YouTube app, Roku, etc.). How to use\rOn-device UI\rFirst connect to a Wi-Fi network: Menu → WiFi → Connect. Go to Menu → WiFi → DIAL Connect. The device will discover smart TVs and cast a random YouTube video. Command line\rCast to first available device:\ndialconnect Cast to ALL devices on the network:\ndialconnect all or\ndialconnect -a Set a custom device name (shown on TV):\ndialconnect MyDevice Cast to all with custom name:\ndialconnect all GhostESP What happens\rGhostESP discovers DIAL-enabled devices using SSDP (multicast discovery). For each device found, it fetches the device description to get the app launch URL. It sends a POST request to launch YouTube with a random video ID. The TV should start playing the video within seconds. Supported devices\rDIAL Connect works with any device that supports the DIAL protocol:\nGoogle Chromecast (all versions) Android TV (Sony, Philips, TCL, etc.) Roku devices Samsung Smart TVs (Tizen-based) LG Smart TVs (webOS) Fire TV devices Troubleshooting\rNo devices found: Make sure GhostESP is connected to the same network as your smart TVs. Run connect SSID PASSWORD first. 404 errors: The YouTube app may not be installed or available on that device. 403 errors: The device may have DIAL restrictions enabled. Some Roku devices require enabling \u0026ldquo;Screen Mirroring\u0026rdquo; in settings. Connection timeouts: The device may be on a different subnet or have firewall rules blocking DIAL. How it works\rDIAL (Discovery and Launch) is a protocol developed by Netflix and YouTube that allows second-screen devices to discover and launch apps on first-screen devices (TVs). GhostESP uses this protocol to:\nSend an SSDP M-SEARCH request to discover DIAL devices. Fetch device descriptions to get the Application-URL. POST to the YouTube app endpoint with a video ID parameter. The TV receives the launch request and starts playing the specified video.\n","description":"Cast YouTube videos to smart TVs on your network.","permalink":"/latest/wifi/dial-connect/","title":"DIAL Connect"}]